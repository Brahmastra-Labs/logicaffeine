use crate::arena_ctx::AstContext;
use crate::ast::{AspectOperator, Expr, ModalDomain, ModalVector, NeoEventData, NounPhrase, QuantifierKind, TemporalOperator, VoiceOperator, Term, ThematicRole};
use crate::context::{DiscourseContext, Entity, Gender, Number};
use crate::error::{ParseError, ParseErrorKind};
use crate::intern::{Interner, Symbol, SymbolEq};
use crate::lexer::Lexer;
use crate::lexicon::{self, Aspect, Definiteness, Time};
use crate::token::{MeasureKind, PresupKind, Token, TokenType};

type ParseResult<T> = Result<T, ParseError>;

use std::ops::{Deref, DerefMut};

#[derive(Clone)]
struct ParserCheckpoint {
    pos: usize,
    var_counter: usize,
    bindings_len: usize,
    island: u32,
    time: Option<Time>,
    negative_depth: u32,
}

pub struct ParserGuard<'p, 'a, 'ctx, 'int> {
    parser: &'p mut Parser<'a, 'ctx, 'int>,
    checkpoint: ParserCheckpoint,
    committed: bool,
}

impl<'p, 'a, 'ctx, 'int> ParserGuard<'p, 'a, 'ctx, 'int> {
    pub fn commit(mut self) {
        self.committed = true;
    }
}

impl<'p, 'a, 'ctx, 'int> Drop for ParserGuard<'p, 'a, 'ctx, 'int> {
    fn drop(&mut self) {
        if !self.committed {
            self.parser.restore(self.checkpoint.clone());
        }
    }
}

impl<'p, 'a, 'ctx, 'int> Deref for ParserGuard<'p, 'a, 'ctx, 'int> {
    type Target = Parser<'a, 'ctx, 'int>;
    fn deref(&self) -> &Self::Target {
        self.parser
    }
}

impl<'p, 'a, 'ctx, 'int> DerefMut for ParserGuard<'p, 'a, 'ctx, 'int> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.parser
    }
}

pub struct Parser<'a, 'ctx, 'int> {
    tokens: Vec<Token>,
    current: usize,
    var_counter: usize,
    pending_time: Option<Time>,
    context: Option<&'ctx mut DiscourseContext>,
    donkey_bindings: Vec<(Symbol, Symbol, bool)>, // (noun_class, var_name, used_by_pronoun)
    interner: &'int mut Interner,
    ctx: AstContext<'a>,
    current_island: u32,
    pp_attach_to_noun: bool,
    filler_gap: Option<Symbol>,
    negative_depth: u32,
}

impl<'a, 'ctx, 'int> Parser<'a, 'ctx, 'int> {
    pub fn new(
        tokens: Vec<Token>,
        interner: &'int mut Interner,
        ctx: AstContext<'a>,
    ) -> Self {
        Parser {
            tokens,
            current: 0,
            var_counter: 0,
            pending_time: None,
            context: None,
            donkey_bindings: Vec::new(),
            interner,
            ctx,
            current_island: 0,
            pp_attach_to_noun: false,
            filler_gap: None,
            negative_depth: 0,
        }
    }

    pub fn with_context(
        tokens: Vec<Token>,
        context: &'ctx mut DiscourseContext,
        interner: &'int mut Interner,
        ctx: AstContext<'a>,
    ) -> Self {
        Parser {
            tokens,
            current: 0,
            var_counter: 0,
            pending_time: None,
            context: Some(context),
            donkey_bindings: Vec::new(),
            interner,
            ctx,
            current_island: 0,
            pp_attach_to_noun: false,
            filler_gap: None,
            negative_depth: 0,
        }
    }

    pub fn set_pp_attachment_mode(&mut self, attach_to_noun: bool) {
        self.pp_attach_to_noun = attach_to_noun;
    }

    fn register_entity(&mut self, symbol: &str, noun_class: &str, gender: Gender, number: Number) {
        if let Some(ref mut ctx) = self.context {
            ctx.register(Entity {
                symbol: symbol.to_string(),
                gender,
                number,
                noun_class: noun_class.to_string(),
            });
        }
    }

    fn resolve_pronoun(&mut self, gender: Gender, number: Number) -> Option<Symbol> {
        self.context
            .as_ref()
            .and_then(|ctx| ctx.resolve_pronoun(gender, number))
            .map(|e| e.symbol.clone())
            .map(|s| self.interner.intern(&s))
    }

    fn resolve_donkey_pronoun(&mut self, gender: Gender) -> Option<Symbol> {
        for (noun_class, var_name, used) in self.donkey_bindings.iter_mut().rev() {
            let noun_str = self.interner.resolve(*noun_class);
            let noun_gender = Self::infer_noun_gender(noun_str);
            if noun_gender == gender || gender == Gender::Neuter || noun_gender == Gender::Unknown {
                *used = true; // Mark as used by a pronoun (donkey anaphor)
                return Some(*var_name);
            }
        }
        None
    }

    fn infer_noun_gender(noun: &str) -> Gender {
        let lower = noun.to_lowercase();
        if lexicon::is_female_noun(&lower) {
            Gender::Female
        } else if lexicon::is_male_noun(&lower) {
            Gender::Male
        } else {
            Gender::Unknown
        }
    }

    fn is_plural_noun(noun: &str) -> bool {
        let lower = noun.to_lowercase();
        if lexicon::is_irregular_plural(&lower) {
            return true;
        }
        lower.ends_with('s') && !lower.ends_with("ss") && lower.len() > 2
    }

    fn singularize_noun(noun: &str) -> String {
        let lower = noun.to_lowercase();
        if let Some(singular) = lexicon::singularize(&lower) {
            return singular.to_string();
        }
        if lower.ends_with('s') && !lower.ends_with("ss") && lower.len() > 2 {
            let base = &lower[..lower.len() - 1];
            let mut chars: Vec<char> = base.chars().collect();
            if !chars.is_empty() {
                chars[0] = chars[0].to_uppercase().next().unwrap();
            }
            return chars.into_iter().collect();
        }
        let mut chars: Vec<char> = lower.chars().collect();
        if !chars.is_empty() {
            chars[0] = chars[0].to_uppercase().next().unwrap();
        }
        chars.into_iter().collect()
    }

    fn infer_gender(name: &str) -> Gender {
        let lower = name.to_lowercase();
        if lexicon::is_male_name(&lower) {
            Gender::Male
        } else if lexicon::is_female_name(&lower) {
            Gender::Female
        } else {
            Gender::Unknown
        }
    }

    fn parse_predicate_with_subject(&mut self, subject_symbol: Symbol) -> ParseResult<&'a Expr<'a>> {
        let subject_term = Term::Constant(subject_symbol);

        // Handle aspect chain: "would have been being eaten"
        if self.check(&TokenType::Would) {
            return self.parse_aspect_chain(subject_symbol);
        }

        // Handle "has/have" as perfect aspect marker: "John has run"
        if self.check_content_word() {
            let next_word = self.interner.resolve(self.peek().lexeme).to_lowercase();
            if next_word == "has" || next_word == "have" || next_word == "had" {
                return self.parse_aspect_chain(subject_symbol);
            }
        }

        // Handle auxiliary: set pending_time for later use, handle negation
        if self.check_auxiliary() {
            let aux_time = if let TokenType::Auxiliary(time) = self.advance().kind {
                time
            } else {
                Time::None
            };
            self.pending_time = Some(aux_time);

            // Handle negation after auxiliary: "I did not see dogs"
            if self.match_token(&[TokenType::Not]) {
                self.negative_depth += 1;

                if self.check_verb() {
                    let verb = self.consume_verb();

                    // Check for quantified object: "I did not see any dogs"
                    if self.check_quantifier() {
                        let quantifier_token = self.advance().kind.clone();
                        let object_np = self.parse_noun_phrase(false)?;
                        let obj_var = self.next_var_name();

                        let obj_restriction = self.ctx.exprs.alloc(Expr::Predicate {
                            name: object_np.noun,
                            args: self.ctx.terms.alloc_slice([Term::Variable(obj_var)]),
                        });

                        let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
                            name: verb,
                            args: self.ctx.terms.alloc_slice([subject_term, Term::Variable(obj_var)]),
                        });

                        let (kind, body) = match quantifier_token {
                            TokenType::Any => {
                                if self.is_negative_context() {
                                    (QuantifierKind::Existential,
                                     self.ctx.exprs.alloc(Expr::BinaryOp {
                                         left: obj_restriction,
                                         op: TokenType::And,
                                         right: verb_pred,
                                     }))
                                } else {
                                    (QuantifierKind::Universal,
                                     self.ctx.exprs.alloc(Expr::BinaryOp {
                                         left: obj_restriction,
                                         op: TokenType::If,
                                         right: verb_pred,
                                     }))
                                }
                            }
                            TokenType::Some => (QuantifierKind::Existential,
                                self.ctx.exprs.alloc(Expr::BinaryOp {
                                    left: obj_restriction,
                                    op: TokenType::And,
                                    right: verb_pred,
                                })),
                            TokenType::All => (QuantifierKind::Universal,
                                self.ctx.exprs.alloc(Expr::BinaryOp {
                                    left: obj_restriction,
                                    op: TokenType::If,
                                    right: verb_pred,
                                })),
                            _ => (QuantifierKind::Existential,
                                self.ctx.exprs.alloc(Expr::BinaryOp {
                                    left: obj_restriction,
                                    op: TokenType::And,
                                    right: verb_pred,
                                })),
                        };

                        let quantified = self.ctx.exprs.alloc(Expr::Quantifier {
                            kind,
                            variable: obj_var,
                            body,
                            island_id: self.current_island,
                        });

                        // Use pending_time pattern - add temporal modifier
                        let effective_time = self.pending_time.take().unwrap_or(Time::None);
                        let with_time = match effective_time {
                            Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                                operator: TemporalOperator::Past,
                                body: quantified,
                            }),
                            Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                                operator: TemporalOperator::Future,
                                body: quantified,
                            }),
                            _ => quantified,
                        };

                        self.negative_depth -= 1;
                        return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                            op: TokenType::Not,
                            operand: with_time,
                        }));
                    }

                    // Regular negated verb without quantified object
                    let mut roles: Vec<(ThematicRole, Term<'a>)> = vec![(ThematicRole::Agent, subject_term)];

                    if self.check_content_word() || self.check_article() {
                        let object = self.parse_noun_phrase(false)?;
                        let object_term = self.noun_phrase_to_term(&object);
                        roles.push((ThematicRole::Theme, object_term));
                    }

                    let event_var = self.interner.intern("e");
                    let effective_time = self.pending_time.take().unwrap_or(Time::None);
                    let mut modifiers = Vec::new();
                    match effective_time {
                        Time::Past => modifiers.push(self.interner.intern("Past")),
                        Time::Future => modifiers.push(self.interner.intern("Future")),
                        _ => {}
                    }

                    let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                        event_var,
                        verb,
                        roles: self.ctx.roles.alloc_slice(roles),
                        modifiers: self.ctx.syms.alloc_slice(modifiers),
                    })));

                    self.negative_depth -= 1;
                    return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: neo_event,
                    }));
                }

                self.negative_depth -= 1;
            }
            // Non-negated auxiliary: pending_time is set, fall through to normal verb handling
        }

        // Handle copula: "it is raining"
        if self.check(&TokenType::Is) || self.check(&TokenType::Are)
            || self.check(&TokenType::Was) || self.check(&TokenType::Were)
        {
            let copula_time = if self.check(&TokenType::Was) || self.check(&TokenType::Were) {
                Time::Past
            } else {
                Time::Present
            };
            self.advance();

            if self.check_verb() {
                let (verb, _verb_time, verb_aspect) = self.consume_verb_with_metadata();
                let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([subject_term]),
                });

                let with_aspect = if verb_aspect == Aspect::Progressive {
                    self.ctx.exprs.alloc(Expr::Aspectual {
                        operator: AspectOperator::Progressive,
                        body: predicate,
                    })
                } else {
                    predicate
                };

                return Ok(if copula_time == Time::Past {
                    self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body: with_aspect,
                    })
                } else {
                    with_aspect
                });
            }

            let predicate = self.consume_content_word()?;
            return Ok(self.ctx.exprs.alloc(Expr::Atom(predicate)));
        }

        if self.check_verb() {
            let (verb, verb_time, verb_aspect) = self.consume_verb_with_metadata();
            let mut args = vec![subject_term];

            let mut object_term: Option<Term<'a>> = None;
            let mut second_object_term: Option<Term<'a>> = None;
            if self.check(&TokenType::Reflexive) {
                self.advance();
                let term = Term::Constant(subject_symbol);
                object_term = Some(term);
                args.push(term);
            } else if self.check_pronoun() {
                let token = self.advance().clone();
                if let TokenType::Pronoun { gender, number, .. } = token.kind {
                    let resolved = self.resolve_pronoun(gender, number)
                        .unwrap_or_else(|| self.interner.intern("?"));
                    let term = Term::Constant(resolved);
                    object_term = Some(term);
                    args.push(term);

                    // Check for ditransitive: "She told him a story"
                    let verb_str = self.interner.resolve(verb);
                    if Lexer::is_ditransitive_verb(verb_str) && (self.check_content_word() || self.check_article()) {
                        let second_np = self.parse_noun_phrase(false)?;
                        let second_term = Term::Constant(second_np.noun);
                        second_object_term = Some(second_term);
                        args.push(second_term);
                    }
                }
            } else if self.check_quantifier() || self.check_article() {
                // Quantified object: "John loves every woman" or "John saw a dog"
                let obj_quantifier = if self.check_quantifier() {
                    Some(self.advance().kind.clone())
                } else {
                    let art = self.advance().kind.clone();
                    if let TokenType::Article(def) = art {
                        if def == Definiteness::Indefinite {
                            Some(TokenType::Some)
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                };

                let object_np = self.parse_noun_phrase(false)?;

                if let Some(obj_q) = obj_quantifier {
                    let obj_var = self.next_var_name();
                    let obj_restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: object_np.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(obj_var)]),
                    });

                    let event_var = self.interner.intern("e");
                    let mut modifiers = self.collect_adverbs();
                    let effective_time = self.pending_time.take().unwrap_or(verb_time);
                    match effective_time {
                        Time::Past => modifiers.push(self.interner.intern("Past")),
                        Time::Future => modifiers.push(self.interner.intern("Future")),
                        _ => {}
                    }

                    let roles = vec![
                        (ThematicRole::Agent, subject_term),
                        (ThematicRole::Theme, Term::Variable(obj_var)),
                    ];

                    let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                        event_var,
                        verb,
                        roles: self.ctx.roles.alloc_slice(roles),
                        modifiers: self.ctx.syms.alloc_slice(modifiers),
                    })));

                    let obj_kind = match obj_q {
                        TokenType::All => QuantifierKind::Universal,
                        TokenType::Some => QuantifierKind::Existential,
                        TokenType::No => QuantifierKind::Universal,
                        TokenType::Most => QuantifierKind::Most,
                        TokenType::Few => QuantifierKind::Few,
                        TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                        TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                        TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                        _ => QuantifierKind::Existential,
                    };

                    let obj_body = match obj_q {
                        TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::If,
                            right: neo_event,
                        }),
                        TokenType::No => {
                            let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                                op: TokenType::Not,
                                operand: neo_event,
                            });
                            self.ctx.exprs.alloc(Expr::BinaryOp {
                                left: obj_restriction,
                                op: TokenType::If,
                                right: neg,
                            })
                        }
                        _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::And,
                            right: neo_event,
                        }),
                    };

                    return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: obj_kind,
                        variable: obj_var,
                        body: obj_body,
                        island_id: self.current_island,
                    }));
                } else {
                    let term = Term::Constant(object_np.noun);
                    object_term = Some(term);
                    args.push(term);
                }
            } else if self.check_content_word() {
                let potential_object = self.parse_noun_phrase(false)?;

                // Check if this is actually a clausal complement (NP followed by verb)
                if self.check_verb() && self.filler_gap.is_some() {
                    // "John say Mary loves" - Mary is subject of embedded clause
                    let embedded_subject = potential_object.noun;
                    let embedded_pred = self.parse_predicate_with_subject(embedded_subject)?;

                    // Create outer predicate: Say(J, embedded_clause)
                    let main_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: verb,
                        args: self.ctx.terms.alloc_slice([subject_term]),
                    });

                    let combined = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: main_pred,
                        op: TokenType::And,
                        right: embedded_pred,
                    });

                    let effective_time = self.pending_time.take().unwrap_or(verb_time);
                    return Ok(if effective_time == Time::Past {
                        self.ctx.exprs.alloc(Expr::Temporal {
                            operator: TemporalOperator::Past,
                            body: combined,
                        })
                    } else {
                        combined
                    });
                }

                let term = Term::Constant(potential_object.noun);
                object_term = Some(term);
                args.push(term);

                // Check for ditransitive: "John gave Mary a book"
                // First object (Mary) is Recipient, second object (book) is Theme
                let verb_str = self.interner.resolve(verb);
                if Lexer::is_ditransitive_verb(verb_str) && (self.check_content_word() || self.check_article()) {
                    let second_np = self.parse_noun_phrase(false)?;
                    let second_term = Term::Constant(second_np.noun);
                    second_object_term = Some(second_term);
                    args.push(second_term);
                }
            } else if self.filler_gap.is_some() && !self.check_content_word() && !self.check_pronoun() {
                // No object found but we have a filler_gap - use it
                let gap_var = self.filler_gap.take().unwrap();
                let term = Term::Variable(gap_var);
                object_term = Some(term);
                args.push(term);
            }

            let unknown = self.interner.intern("?");
            let mut pp_predicates: Vec<&'a Expr<'a>> = Vec::new();
            while self.check_preposition() {
                let prep_token = self.advance().clone();
                let prep_name = if let TokenType::Preposition(sym) = prep_token.kind {
                    sym
                } else {
                    continue;
                };

                let pp_obj_term = if self.check(&TokenType::Reflexive) {
                    self.advance();
                    Term::Constant(subject_symbol)
                } else if self.check_pronoun() {
                    let token = self.advance().clone();
                    if let TokenType::Pronoun { gender, number, .. } = token.kind {
                        let resolved = self.resolve_pronoun(gender, number)
                            .unwrap_or(unknown);
                        Term::Constant(resolved)
                    } else {
                        continue;
                    }
                } else if self.check_content_word() {
                    let prep_obj = self.parse_noun_phrase(true)?;
                    Term::Constant(prep_obj.noun)
                } else {
                    continue;
                };

                if self.pp_attach_to_noun {
                    // NP-attachment: PP modifies the object noun
                    if let Some(obj) = object_term {
                        let pp_pred = self.ctx.exprs.alloc(Expr::Predicate {
                            name: prep_name,
                            args: self.ctx.terms.alloc_slice([obj, pp_obj_term]),
                        });
                        pp_predicates.push(pp_pred);
                    } else {
                        args.push(pp_obj_term);
                    }
                } else {
                    // VP-attachment: PP modifies the event (instrument/manner)
                    let event_sym = self.interner.intern("e");
                    let pp_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: prep_name,
                        args: self.ctx.terms.alloc_slice([Term::Variable(event_sym), pp_obj_term]),
                    });
                    pp_predicates.push(pp_pred);
                }
            }

            // Check for trailing relative clause on object NP: "the girl with the telescope that laughed"
            if self.check(&TokenType::That) || self.check(&TokenType::Who) {
                self.advance();
                let rel_var = self.next_var_name();
                let rel_pred = self.parse_relative_clause(rel_var)?;
                pp_predicates.push(rel_pred);
            }

            // Collect adverbs
            let mut modifiers = self.collect_adverbs();

            // Add temporal modifier
            let effective_time = self.pending_time.take().unwrap_or(verb_time);
            match effective_time {
                Time::Past => modifiers.push(self.interner.intern("Past")),
                Time::Future => modifiers.push(self.interner.intern("Future")),
                _ => {}
            }

            // Add aspect modifier
            if verb_aspect == Aspect::Progressive {
                modifiers.push(self.interner.intern("Progressive"));
            } else if verb_aspect == Aspect::Perfect {
                modifiers.push(self.interner.intern("Perfect"));
            }

            // Build thematic roles
            let mut roles: Vec<(ThematicRole, Term<'a>)> = Vec::new();
            roles.push((ThematicRole::Agent, subject_term));
            if let Some(second_obj) = second_object_term {
                // Ditransitive: first object is Recipient, second is Theme
                if let Some(first_obj) = object_term {
                    roles.push((ThematicRole::Recipient, first_obj));
                }
                roles.push((ThematicRole::Theme, second_obj));
            } else if let Some(obj) = object_term {
                // Normal transitive: object is Theme
                roles.push((ThematicRole::Theme, obj));
            }

            let event_var = self.interner.intern("e");
            let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                event_var,
                verb,
                roles: self.ctx.roles.alloc_slice(roles),
                modifiers: self.ctx.syms.alloc_slice(modifiers),
            })));

            // Combine with PP predicates if any
            let with_pps = if pp_predicates.is_empty() {
                neo_event
            } else {
                let mut combined = neo_event;
                for pp in pp_predicates {
                    combined = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: combined,
                        op: TokenType::And,
                        right: pp,
                    });
                }
                combined
            };

            Ok(with_pps)
        } else {
            Ok(self.ctx.exprs.alloc(Expr::Atom(subject_symbol)))
        }
    }

    fn next_var_name(&mut self) -> Symbol {
        const VARS: &[&str] = &["x", "y", "z", "w", "v", "u"];
        let idx = self.var_counter;
        self.var_counter += 1;
        if idx < VARS.len() {
            self.interner.intern(VARS[idx])
        } else {
            let name = format!("x{}", idx - VARS.len() + 1);
            self.interner.intern(&name)
        }
    }

    pub fn parse(&mut self) -> ParseResult<&'a Expr<'a>> {
        self.parse_sentence()
    }

    fn parse_sentence(&mut self) -> ParseResult<&'a Expr<'a>> {
        // Check for imperative: "Go!" (verb at start followed by !)
        if self.check_verb() {
            let verb_pos = self.current;
            // Look ahead for exclamation
            let mut temp_pos = self.current + 1;
            while temp_pos < self.tokens.len() {
                if matches!(self.tokens[temp_pos].kind, TokenType::Exclamation) {
                    // This is an imperative
                    self.current = verb_pos;
                    let verb = self.consume_verb();
                    // Skip to exclamation
                    while !matches!(self.peek().kind, TokenType::Exclamation | TokenType::EOF) {
                        self.advance();
                    }
                    if self.check(&TokenType::Exclamation) {
                        self.advance();
                    }
                    let addressee = self.interner.intern("addressee");
                    let action = self.ctx.exprs.alloc(Expr::Predicate {
                        name: verb,
                        args: self.ctx.terms.alloc_slice([Term::Variable(addressee)]),
                    });
                    return Ok(self.ctx.exprs.alloc(Expr::Imperative { action }));
                }
                if matches!(self.tokens[temp_pos].kind, TokenType::Period | TokenType::EOF) {
                    break;
                }
                temp_pos += 1;
            }
        }

        // Check for wh-questions: "Who loves Mary?" or "What does John love?"
        if self.check_wh_word() {
            return self.parse_wh_question();
        }

        // Check for yes/no questions: "Does John love Mary?", "Is John running?", "Can you help?"
        if self.check(&TokenType::Does) || self.check(&TokenType::Do)
            || self.check(&TokenType::Is) || self.check(&TokenType::Are)
            || self.check(&TokenType::Was) || self.check(&TokenType::Were)
            || self.check(&TokenType::Would) || self.check(&TokenType::Could)
            || self.check(&TokenType::Can) {
            return self.parse_yes_no_question();
        }

        if self.match_token(&[TokenType::If]) {
            return self.parse_conditional();
        }

        // Modals at sentence level (standalone modal)
        if self.check_modal() {
            self.advance();
            return self.parse_modal();
        }

        if self.match_token(&[TokenType::Not]) {
            self.negative_depth += 1;
            let inner = self.parse_sentence()?;
            self.negative_depth -= 1;
            return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                op: TokenType::Not,
                operand: inner,
            }));
        }

        // Let parse_conjunction handle quantifiers so "All X and Some Y" works
        self.parse_conjunction()
    }

    fn check_wh_word(&self) -> bool {
        // Direct wh-word
        if matches!(
            self.peek().kind,
            TokenType::Who | TokenType::What | TokenType::Where | TokenType::When | TokenType::Why
        ) {
            return true;
        }
        // Pied-piping: "To whom", "For what", etc.
        if self.check_preposition() && self.current + 1 < self.tokens.len() {
            matches!(
                self.tokens[self.current + 1].kind,
                TokenType::Who | TokenType::What | TokenType::Where | TokenType::When | TokenType::Why
            )
        } else {
            false
        }
    }

    fn parse_wh_question(&mut self) -> ParseResult<&'a Expr<'a>> {
        // Handle pied-piping: "To whom did John give the book?"
        let pied_piping_prep = if self.check_preposition() {
            let prep = self.advance().kind.clone();
            Some(prep)
        } else {
            None
        };

        let wh_token = self.advance().kind.clone();
        let var_name = self.interner.intern("x");
        let var_term = Term::Variable(var_name);

        // Pied-piping: "To whom did John give the book?"
        if pied_piping_prep.is_some() && self.check_auxiliary() {
            let aux_token = self.advance().clone();
            if let TokenType::Auxiliary(time) = aux_token.kind {
                self.pending_time = Some(time);
            }

            let subject = self.parse_noun_phrase(true)?;
            let verb = self.consume_verb();

            // Parse direct object if present
            let mut args = vec![Term::Constant(subject.noun)];
            if self.check_content_word() || self.check_article() {
                let object = self.parse_noun_phrase(false)?;
                args.push(Term::Constant(object.noun));
            }
            // The wh-word (whom) is the indirect object (the recipient of "give")
            args.push(var_term);

            let body = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice(args),
            });
            return Ok(self.ctx.exprs.alloc(Expr::Question {
                wh_variable: var_name,
                body,
            }));
        }

        // "Who loves Mary?" - who is the subject
        if self.check_verb() {
            let verb = self.consume_verb();
            let mut args = vec![var_term];

            if self.check_content_word() {
                let object = self.parse_noun_phrase(false)?;
                args.push(Term::Constant(object.noun));
            }

            let body = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice(args),
            });
            return Ok(self.ctx.exprs.alloc(Expr::Question {
                wh_variable: var_name,
                body,
            }));
        }

        // "What does John love?" - what is the object (present tense)
        if self.check(&TokenType::Does) || self.check(&TokenType::Do) {
            self.advance();
            let subject = self.parse_noun_phrase(true)?;
            let verb = self.consume_verb();

            let body = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject.noun), var_term]),
            });
            return Ok(self.ctx.exprs.alloc(Expr::Question {
                wh_variable: var_name,
                body,
            }));
        }

        // "Who did John say Mary loves?" - long-distance wh-movement
        if self.check_auxiliary() {
            let aux_token = self.advance().clone();
            if let TokenType::Auxiliary(time) = aux_token.kind {
                self.pending_time = Some(time);
            }

            self.filler_gap = Some(var_name);

            let subject = self.parse_noun_phrase(true)?;
            let body = self.parse_predicate_with_subject(subject.noun)?;

            self.filler_gap = None;

            return Ok(self.ctx.exprs.alloc(Expr::Question {
                wh_variable: var_name,
                body,
            }));
        }

        let unknown = self.interner.intern(&format!("{:?}", wh_token));
        Ok(self.ctx.exprs.alloc(Expr::Atom(unknown)))
    }

    fn parse_yes_no_question(&mut self) -> ParseResult<&'a Expr<'a>> {
        let aux_token = self.advance().kind.clone();

        // Determine auxiliary type
        let is_modal = matches!(aux_token, TokenType::Can | TokenType::Could | TokenType::Would | TokenType::May | TokenType::Must | TokenType::Should);
        let is_copula = matches!(aux_token, TokenType::Is | TokenType::Are | TokenType::Was | TokenType::Were);
        let copula_time = if matches!(aux_token, TokenType::Was | TokenType::Were) {
            Time::Past
        } else {
            Time::Present
        };

        // Parse subject: pronoun, quantified phrase, or noun phrase
        // Check for quantified subject: "Can every student..."
        if self.check_quantifier() {
            self.advance();
            let quantified = self.parse_quantified()?;
            let wrapped = if is_modal {
                let vector = self.aux_token_to_modal_vector(&aux_token);
                self.ctx.exprs.alloc(Expr::Modal {
                    vector,
                    operand: quantified,
                })
            } else {
                quantified
            };
            return Ok(self.ctx.exprs.alloc(Expr::YesNoQuestion { body: wrapped }));
        }

        let subject_symbol = if self.check_pronoun() {
            let token = self.advance().clone();
            if let TokenType::Pronoun { gender, number, .. } = token.kind {
                let token_text = self.interner.resolve(token.lexeme);
                if token_text.eq_ignore_ascii_case("you") {
                    self.interner.intern("Addressee")
                } else {
                    self.resolve_pronoun(gender, number)
                        .unwrap_or_else(|| self.interner.intern("?"))
                }
            } else {
                self.interner.intern("?")
            }
        } else {
            self.parse_noun_phrase(true)?.noun
        };

        // Handle "please" marker for polite requests
        let please_sym = self.interner.intern("please");
        self.match_token(&[TokenType::Adverb(please_sym)]);

        // For copulas (Is/Are/Was/Were), handle progressive or adjective predication
        if is_copula {
            let body = if self.check_verb() {
                let (verb, _, verb_aspect) = self.consume_verb_with_metadata();
                let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_symbol)]),
                });
                let with_aspect = if verb_aspect == Aspect::Progressive {
                    self.ctx.exprs.alloc(Expr::Aspectual {
                        operator: AspectOperator::Progressive,
                        body: predicate,
                    })
                } else {
                    predicate
                };
                if copula_time == Time::Past {
                    self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body: with_aspect,
                    })
                } else {
                    with_aspect
                }
            } else if self.check_content_word() {
                let adj = self.consume_content_word()?;
                self.ctx.exprs.alloc(Expr::Predicate {
                    name: adj,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_symbol)]),
                })
            } else {
                self.ctx.exprs.alloc(Expr::Atom(subject_symbol))
            };
            return Ok(self.ctx.exprs.alloc(Expr::YesNoQuestion { body }));
        }

        // For modals and simple auxiliaries, delegate to robust predicate parsing
        let body = self.parse_predicate_with_subject(subject_symbol)?;

        // Wrap in Modal if the auxiliary was a modal verb
        let wrapped_body = if is_modal {
            let vector = self.aux_token_to_modal_vector(&aux_token);
            self.ctx.exprs.alloc(Expr::Modal {
                vector,
                operand: body,
            })
        } else {
            body
        };

        Ok(self.ctx.exprs.alloc(Expr::YesNoQuestion { body: wrapped_body }))
    }

    fn aux_token_to_modal_vector(&self, token: &TokenType) -> ModalVector {
        match token {
            TokenType::Can => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.5,
            },
            TokenType::Could => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.4,
            },
            TokenType::Would => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.6,
            },
            TokenType::May => ModalVector {
                domain: ModalDomain::Deontic,
                force: 0.5,
            },
            TokenType::Must => ModalVector {
                domain: ModalDomain::Alethic,
                force: 1.0,
            },
            TokenType::Should => ModalVector {
                domain: ModalDomain::Deontic,
                force: 0.6,
            },
            _ => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.5,
            },
        }
    }

    fn parse_conditional(&mut self) -> ParseResult<&'a Expr<'a>> {
        // Check for counterfactual markers in antecedent
        let is_counterfactual = self.is_counterfactual_context();

        let antecedent = self.parse_counterfactual_antecedent()?;

        if self.check(&TokenType::Comma) {
            self.advance();
        }

        if self.check(&TokenType::Then) {
            self.advance();
        }

        let consequent = self.parse_counterfactual_consequent()?;

        Ok(if is_counterfactual {
            self.ctx.exprs.alloc(Expr::Counterfactual {
                antecedent,
                consequent,
            })
        } else {
            self.ctx.exprs.alloc(Expr::BinaryOp {
                left: antecedent,
                op: TokenType::If,
                right: consequent,
            })
        })
    }

    fn is_counterfactual_context(&self) -> bool {
        // Look ahead for subjunctive markers: "were", "had"
        for i in 0..5 {
            if self.current + i >= self.tokens.len() {
                break;
            }
            let token = &self.tokens[self.current + i];
            if matches!(token.kind, TokenType::Were | TokenType::Had) {
                return true;
            }
            if matches!(token.kind, TokenType::Comma | TokenType::Period) {
                break;
            }
        }
        false
    }

    fn parse_counterfactual_antecedent(&mut self) -> ParseResult<&'a Expr<'a>> {
        let unknown = self.interner.intern("?");
        // Handle subjunctive constructions
        if self.check_content_word() || self.check_pronoun() {
            let subject = if self.check_pronoun() {
                let token = self.advance().clone();
                if let TokenType::Pronoun { gender, number, .. } = token.kind {
                    self.resolve_pronoun(gender, number)
                        .unwrap_or(unknown)
                } else {
                    unknown
                }
            } else {
                self.parse_noun_phrase(true)?.noun
            };

            // "I were you" or "John had run"
            if self.check(&TokenType::Were) {
                self.advance();
                let predicate = if self.check_pronoun() {
                    let token = self.advance().clone();
                    if let TokenType::Pronoun { gender, number, .. } = token.kind {
                        let token_text = self.interner.resolve(token.lexeme);
                        if token_text.eq_ignore_ascii_case("i") {
                            self.interner.intern("Speaker")
                        } else if token_text.eq_ignore_ascii_case("you") {
                            self.interner.intern("Addressee")
                        } else {
                            self.resolve_pronoun(gender, number).unwrap_or(unknown)
                        }
                    } else {
                        unknown
                    }
                } else {
                    self.consume_content_word()?
                };
                let be = self.interner.intern("Be");
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: be,
                    args: self.ctx.terms.alloc_slice([
                        Term::Constant(subject),
                        Term::Constant(predicate),
                    ]),
                }));
            }

            if self.check(&TokenType::Had) {
                self.advance();
                let verb = self.consume_content_word()?;
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject)]),
                }));
            }

            // Fall back to regular parsing
            return self.parse_predicate_with_subject(subject);
        }

        self.parse_sentence()
    }

    fn parse_counterfactual_consequent(&mut self) -> ParseResult<&'a Expr<'a>> {
        let unknown = self.interner.intern("?");
        // Handle "would" in consequent
        if self.check_content_word() || self.check_pronoun() {
            let subject = if self.check_pronoun() {
                let token = self.advance().clone();
                if let TokenType::Pronoun { gender, number, .. } = token.kind {
                    self.resolve_pronoun(gender, number)
                        .unwrap_or(unknown)
                } else {
                    unknown
                }
            } else {
                self.parse_noun_phrase(true)?.noun
            };

            // "I would quit" or "he would have won"
            if self.check(&TokenType::Would) {
                self.advance();
                // Skip "have" if present
                if self.check_content_word() {
                    let next_word = self.interner.resolve(self.peek().lexeme).to_lowercase();
                    if next_word == "have" {
                        self.advance();
                    }
                }
                let verb = self.consume_content_word()?;
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject)]),
                }));
            }

            return self.parse_predicate_with_subject(subject);
        }

        self.parse_sentence()
    }

    fn checkpoint(&self) -> ParserCheckpoint {
        ParserCheckpoint {
            pos: self.current,
            var_counter: self.var_counter,
            bindings_len: self.donkey_bindings.len(),
            island: self.current_island,
            time: self.pending_time,
            negative_depth: self.negative_depth,
        }
    }

    fn restore(&mut self, cp: ParserCheckpoint) {
        self.current = cp.pos;
        self.var_counter = cp.var_counter;
        self.donkey_bindings.truncate(cp.bindings_len);
        self.current_island = cp.island;
        self.pending_time = cp.time;
        self.negative_depth = cp.negative_depth;
    }

    fn is_negative_context(&self) -> bool {
        self.negative_depth % 2 == 1
    }

    pub fn guard(&mut self) -> ParserGuard<'_, 'a, 'ctx, 'int> {
        ParserGuard {
            checkpoint: self.checkpoint(),
            parser: self,
            committed: false,
        }
    }

    fn try_parse<F, T>(&mut self, op: F) -> Option<T>
    where
        F: FnOnce(&mut Self) -> ParseResult<T>,
    {
        let cp = self.checkpoint();
        match op(self) {
            Ok(res) => Some(res),
            Err(_) => {
                self.restore(cp);
                None
            }
        }
    }

    fn extract_verb_from_expr(&self, expr: &Expr<'a>) -> Option<Symbol> {
        match expr {
            Expr::Predicate { name, .. } => Some(*name),
            Expr::NeoEvent(data) => Some(data.verb),
            Expr::BinaryOp { right, .. } => self.extract_verb_from_expr(right),
            Expr::Modal { operand, .. } => self.extract_verb_from_expr(operand),
            Expr::Presupposition { assertion, .. } => self.extract_verb_from_expr(assertion),
            Expr::Control { verb, .. } => Some(*verb),
            Expr::Temporal { body, .. } => self.extract_verb_from_expr(body),
            Expr::Aspectual { body, .. } => self.extract_verb_from_expr(body),
            Expr::Quantifier { body, .. } => self.extract_verb_from_expr(body),
            _ => None,
        }
    }

    fn parse_gapped_clause(&mut self, borrowed_verb: Symbol) -> ParseResult<&'a Expr<'a>> {
        let subject = self.parse_noun_phrase(true)?;

        if self.check(&TokenType::Comma) {
            self.advance();
        }

        let object = self.parse_noun_phrase(false)?;

        let subject_term = self.noun_phrase_to_term(&subject);
        let object_term = self.noun_phrase_to_term(&object);

        let roles = vec![
            (ThematicRole::Agent, subject_term),
            (ThematicRole::Theme, object_term),
        ];
        let event_var = self.interner.intern("e");

        Ok(self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
            event_var,
            verb: borrowed_verb,
            roles: self.ctx.roles.alloc_slice(roles),
            modifiers: self.ctx.syms.alloc_slice(vec![]),
        }))))
    }

    fn is_complete_clause(&self, expr: &Expr<'a>) -> bool {
        match expr {
            Expr::Atom(_) => false,
            Expr::Predicate { .. } => true,
            Expr::Quantifier { .. } => true,
            Expr::Modal { .. } => true,
            Expr::Temporal { .. } => true,
            Expr::Aspectual { .. } => true,
            Expr::BinaryOp { .. } => true,
            Expr::UnaryOp { .. } => true,
            Expr::Control { .. } => true,
            Expr::Presupposition { .. } => true,
            Expr::Categorical(_) => true,
            Expr::Relation(_) => true,
            _ => true,
        }
    }

    fn parse_conjunction(&mut self) -> ParseResult<&'a Expr<'a>> {
        let mut expr = self.parse_atom()?;

        // Handle causal connective: "X because Y"
        if self.check(&TokenType::Because) {
            self.advance();
            let cause = self.parse_atom()?;
            return Ok(self.ctx.exprs.alloc(Expr::Causal {
                effect: expr,
                cause,
            }));
        }

        while self.check(&TokenType::Comma)
            || self.check(&TokenType::And)
            || self.check(&TokenType::Or)
            || self.check(&TokenType::Iff)
        {
            if self.check(&TokenType::Comma) {
                self.advance();
            }
            if !self.match_token(&[TokenType::And, TokenType::Or, TokenType::Iff]) {
                break;
            }
            let operator = self.previous().kind.clone();
            self.current_island += 1;

            let saved_pos = self.current;
            let standard_attempt = self.try_parse(|p| p.parse_atom());

            let use_gapping = match &standard_attempt {
                Some(right) => {
                    !self.is_complete_clause(right)
                        && (self.check(&TokenType::Comma) || self.check_content_word())
                }
                None => true,
            };

            if !use_gapping {
                if let Some(right) = standard_attempt {
                    expr = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: expr,
                        op: operator,
                        right,
                    });
                }
            } else {
                self.current = saved_pos;

                let borrowed_verb = self.extract_verb_from_expr(expr).ok_or(ParseError {
                    kind: ParseErrorKind::GappingResolutionFailed,
                    span: self.current_span(),
                })?;

                let right = self.parse_gapped_clause(borrowed_verb)?;

                expr = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: expr,
                    op: operator,
                    right,
                });
            }
        }

        Ok(expr)
    }

    fn parse_quantified(&mut self) -> ParseResult<&'a Expr<'a>> {
        let quantifier_token = self.previous().kind.clone();
        let var_name = self.next_var_name();

        // Parse subject restriction: "happy dogs that bark"  Happy(x)  Dog(x)  Bark(x)
        let subject_pred = self.parse_restriction(var_name)?;

        // Check for modal operator (e.g., "All cats must sleep")
        if self.check_modal() {
            self.advance();
            let vector = self.token_to_vector(&self.previous().kind.clone());
            let verb = self.consume_content_word()?;

            let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
            });

            // Build: Modal(Quantifier(x, S(x)  V(x)))
            let body = match quantifier_token {
                TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::If,
                    right: verb_pred,
                }),
                TokenType::Any => {
                    if self.is_negative_context() {
                        self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::And,
                            right: verb_pred,
                        })
                    } else {
                        self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::If,
                            right: verb_pred,
                        })
                    }
                }
                TokenType::Some | TokenType::Most | TokenType::Few
                | TokenType::Cardinal(_) | TokenType::AtLeast(_) | TokenType::AtMost(_) => {
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::And,
                        right: verb_pred,
                    })
                }
                TokenType::No => {
                    let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: verb_pred,
                    });
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::If,
                        right: neg,
                    })
                }
                _ => return Err(ParseError {
                    kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                    span: self.current_span(),
                }),
            };

            let kind = match quantifier_token {
                TokenType::All | TokenType::No => QuantifierKind::Universal,
                TokenType::Any => {
                    if self.is_negative_context() {
                        QuantifierKind::Existential
                    } else {
                        QuantifierKind::Universal
                    }
                }
                TokenType::Some => QuantifierKind::Existential,
                TokenType::Most => QuantifierKind::Most,
                TokenType::Few => QuantifierKind::Few,
                TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                _ => return Err(ParseError {
                    kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                    span: self.current_span(),
                }),
            };

            let quantified = self.ctx.exprs.alloc(Expr::Quantifier {
                kind,
                variable: var_name,
                body,
                island_id: self.current_island,
            });

            return Ok(self.ctx.exprs.alloc(Expr::Modal {
                vector,
                operand: quantified,
            }));
        }

        // Check for auxiliary + (not) + verb pattern: "Every student did not pass"
        if self.check_auxiliary() {
            let aux_token = self.advance();
            let aux_time = if let TokenType::Auxiliary(time) = aux_token.kind.clone() {
                time
            } else {
                Time::None
            };
            self.pending_time = Some(aux_time);

            // Check for negation after auxiliary
            let is_negated = self.match_token(&[TokenType::Not]);
            if is_negated {
                self.negative_depth += 1;
            }

            // Now expect the main verb
            if self.check_verb() {
                let verb = self.consume_verb();
                let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                // Apply negation if present
                let maybe_negated = if is_negated {
                    self.negative_depth -= 1;
                    self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: verb_pred,
                    })
                } else {
                    verb_pred
                };

                let body = match quantifier_token {
                    TokenType::All | TokenType::Any => self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::If,
                        right: maybe_negated,
                    }),
                    _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::And,
                        right: maybe_negated,
                    }),
                };

                let kind = match quantifier_token {
                    TokenType::All | TokenType::No => QuantifierKind::Universal,
                    TokenType::Some => QuantifierKind::Existential,
                    TokenType::Most => QuantifierKind::Most,
                    TokenType::Few => QuantifierKind::Few,
                    TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                    TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                    TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                    _ => QuantifierKind::Universal,
                };

                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind,
                    variable: var_name,
                    body,
                    island_id: self.current_island,
                }));
            }
        }

        // Check for presupposition triggers: "Every student stopped smoking"
        if self.check_presup_trigger() {
            let presup_kind = if let TokenType::PresupTrigger(kind) = self.advance().kind {
                kind
            } else {
                panic!("Expected presupposition trigger");
            };

            // Parse the complement (gerund like "smoking")
            let complement = if self.check_verb() {
                let verb = self.consume_verb();
                self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                })
            } else {
                let unknown = self.interner.intern("?");
                self.ctx.exprs.alloc(Expr::Atom(unknown))
            };

            // Build presupposition based on trigger type
            let verb_pred = match presup_kind {
                PresupKind::Stop => {
                    // "stopped smoking"  Smoke(x)
                    self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: complement,
                    })
                }
                PresupKind::Start | PresupKind::Continue => {
                    // "started/continued running"  Run(x)
                    complement
                }
                PresupKind::Regret | PresupKind::Realize | PresupKind::Know => {
                    // Factive: complement is presupposed true
                    complement
                }
            };

            let body = match quantifier_token {
                TokenType::All | TokenType::Any => self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::If,
                    right: verb_pred,
                }),
                _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::And,
                    right: verb_pred,
                }),
            };

            let kind = match quantifier_token {
                TokenType::All | TokenType::No => QuantifierKind::Universal,
                TokenType::Some => QuantifierKind::Existential,
                TokenType::Most => QuantifierKind::Most,
                TokenType::Few => QuantifierKind::Few,
                TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                _ => QuantifierKind::Universal,
            };

            return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                kind,
                variable: var_name,
                body,
                island_id: self.current_island,
            }));
        }

        // Check for verb pattern: "Most dogs bark" or "Every farmer beats it" (no copula)
        if self.check_verb() {
            let verb = self.consume_verb();
            let mut args = vec![Term::Variable(var_name)];

            // Check for object (could be a donkey pronoun)
            if self.check_pronoun() {
                let token = self.peek().clone();
                if let TokenType::Pronoun { gender, .. } = token.kind {
                    self.advance();
                    // Try to resolve as donkey pronoun first
                    if let Some(donkey_var) = self.resolve_donkey_pronoun(gender) {
                        args.push(Term::Variable(donkey_var));
                    } else {
                        // Fall back to discourse context
                        let unknown = self.interner.intern("?");
                        let resolved = self.resolve_pronoun(gender, Number::Singular)
                            .unwrap_or(unknown);
                        args.push(Term::Constant(resolved));
                    }
                }
            } else if self.check_quantifier() || self.check_article() {
                // Quantified object: "Every woman loves a man" or "Some dog chased every cat"
                let obj_quantifier = if self.check_quantifier() {
                    Some(self.advance().kind.clone())
                } else {
                    // Article: "a/an" is existential, "the" is definite
                    let art = self.advance().kind.clone();
                    if let TokenType::Article(def) = art {
                        if def == Definiteness::Indefinite {
                            Some(TokenType::Some)
                        } else {
                            None // Definite articles handled differently
                        }
                    } else {
                        None
                    }
                };

                let object = self.parse_noun_phrase(false)?;

                if let Some(obj_q) = obj_quantifier {
                    // Create nested quantifier for object
                    let obj_var = self.next_var_name();
                    let obj_restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: object.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(obj_var)]),
                    });

                    let verb_with_obj = self.ctx.exprs.alloc(Expr::Predicate {
                        name: verb,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var_name), Term::Variable(obj_var)]),
                    });

                    let obj_kind = match obj_q {
                        TokenType::All => QuantifierKind::Universal,
                        TokenType::Some => QuantifierKind::Existential,
                        TokenType::No => QuantifierKind::Universal,
                        TokenType::Most => QuantifierKind::Most,
                        TokenType::Few => QuantifierKind::Few,
                        TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                        TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                        TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                        _ => QuantifierKind::Existential,
                    };

                    let obj_body = match obj_q {
                        TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::If,
                            right: verb_with_obj,
                        }),
                        TokenType::No => {
                            let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                                op: TokenType::Not,
                                operand: verb_with_obj,
                            });
                            self.ctx.exprs.alloc(Expr::BinaryOp {
                                left: obj_restriction,
                                op: TokenType::If,
                                right: neg,
                            })
                        }
                        _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::And,
                            right: verb_with_obj,
                        }),
                    };

                    let obj_quantified = self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: obj_kind,
                        variable: obj_var,
                        body: obj_body,
                        island_id: self.current_island,
                    });

                    // Build subject quantifier with object quantifier as body
                    let subj_kind = match quantifier_token {
                        TokenType::All | TokenType::No => QuantifierKind::Universal,
                        TokenType::Any => if self.is_negative_context() { QuantifierKind::Existential } else { QuantifierKind::Universal },
                        TokenType::Some => QuantifierKind::Existential,
                        TokenType::Most => QuantifierKind::Most,
                        TokenType::Few => QuantifierKind::Few,
                        TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                        TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                        TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                        _ => QuantifierKind::Universal,
                    };

                    let subj_body = match quantifier_token {
                        TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::If,
                            right: obj_quantified,
                        }),
                        TokenType::No => {
                            let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                                op: TokenType::Not,
                                operand: obj_quantified,
                            });
                            self.ctx.exprs.alloc(Expr::BinaryOp {
                                left: subject_pred,
                                op: TokenType::If,
                                right: neg,
                            })
                        }
                        _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::And,
                            right: obj_quantified,
                        }),
                    };

                    return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: subj_kind,
                        variable: var_name,
                        body: subj_body,
                        island_id: self.current_island,
                    }));
                } else {
                    // Definite article - treat as constant
                    args.push(Term::Constant(object.noun));
                }
            } else if self.check_content_word() {
                let object = self.parse_noun_phrase(false)?;
                args.push(Term::Constant(object.noun));
            }

            let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice(args),
            });

            let body = match quantifier_token {
                TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::If,
                    right: verb_pred,
                }),
                TokenType::Any => {
                    if self.is_negative_context() {
                        self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::And,
                            right: verb_pred,
                        })
                    } else {
                        self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: subject_pred,
                            op: TokenType::If,
                            right: verb_pred,
                        })
                    }
                }
                TokenType::Some | TokenType::Most | TokenType::Few
                | TokenType::Cardinal(_) | TokenType::AtLeast(_) | TokenType::AtMost(_) => {
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::And,
                        right: verb_pred,
                    })
                }
                TokenType::No => {
                    let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: verb_pred,
                    });
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::If,
                        right: neg,
                    })
                }
                _ => return Err(ParseError {
                    kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                    span: self.current_span(),
                }),
            };

            let kind = match quantifier_token {
                TokenType::All | TokenType::No => QuantifierKind::Universal,
                TokenType::Any => {
                    if self.is_negative_context() {
                        QuantifierKind::Existential
                    } else {
                        QuantifierKind::Universal
                    }
                }
                TokenType::Some => QuantifierKind::Existential,
                TokenType::Most => QuantifierKind::Most,
                TokenType::Few => QuantifierKind::Few,
                TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                _ => return Err(ParseError {
                    kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                    span: self.current_span(),
                }),
            };

            let mut result = self.ctx.exprs.alloc(Expr::Quantifier {
                kind,
                variable: var_name,
                body,
                island_id: self.current_island,
            });

            // Wrap with quantifiers for indefinites in restrictions
            // - Used by pronoun (donkey anaphor): Universal quantifier
            // - Not used by pronoun: Existential quantifier
            for (_noun, donkey_var, used) in self.donkey_bindings.iter().rev() {
                let kind = if *used {
                    QuantifierKind::Universal
                } else {
                    QuantifierKind::Existential
                };
                result = self.ctx.exprs.alloc(Expr::Quantifier {
                    kind,
                    variable: *donkey_var,
                    body: result,
                    island_id: self.current_island,
                });
            }
            self.donkey_bindings.clear();

            return Ok(result);
        }

        self.consume_copula()?;

        let negative = self.match_token(&[TokenType::Not]);
        let predicate_np = self.parse_noun_phrase(true)?;

        // Build the predicate: P(x)
        let predicate_expr = self.ctx.exprs.alloc(Expr::Predicate {
            name: predicate_np.noun,
            args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
        });

        // Apply negation if present
        let final_predicate = if negative {
            self.ctx.exprs.alloc(Expr::UnaryOp {
                op: TokenType::Not,
                operand: predicate_expr,
            })
        } else {
            predicate_expr
        };

        // Build the FOL structure based on quantifier type
        let body = match quantifier_token {
            TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                left: subject_pred,
                op: TokenType::If,
                right: final_predicate,
            }),
            TokenType::Any => {
                if self.is_negative_context() {
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::And,
                        right: final_predicate,
                    })
                } else {
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: subject_pred,
                        op: TokenType::If,
                        right: final_predicate,
                    })
                }
            }
            TokenType::Some | TokenType::Most | TokenType::Few
            | TokenType::Cardinal(_) | TokenType::AtLeast(_) | TokenType::AtMost(_) => {
                self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::And,
                    right: final_predicate,
                })
            }
            TokenType::No => {
                let neg_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: predicate_np.noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });
                let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                    op: TokenType::Not,
                    operand: neg_pred,
                });
                self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: subject_pred,
                    op: TokenType::If,
                    right: neg,
                })
            }
            _ => return Err(ParseError {
                kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                span: self.current_span(),
            }),
        };

        let kind = match quantifier_token {
            TokenType::All | TokenType::No => QuantifierKind::Universal,
            TokenType::Any => {
                if self.is_negative_context() {
                    QuantifierKind::Existential
                } else {
                    QuantifierKind::Universal
                }
            }
            TokenType::Some => QuantifierKind::Existential,
            TokenType::Most => QuantifierKind::Most,
            TokenType::Few => QuantifierKind::Few,
            TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
            TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
            TokenType::AtMost(n) => QuantifierKind::AtMost(n),
            _ => return Err(ParseError {
                kind: ParseErrorKind::UnknownQuantifier { found: quantifier_token.clone() },
                span: self.current_span(),
            }),
        };

        let mut result = self.ctx.exprs.alloc(Expr::Quantifier {
            kind,
            variable: var_name,
            body,
            island_id: self.current_island,
        });

        // Wrap with quantifiers for indefinites in restrictions
        // - Used by pronoun (donkey anaphor): Universal quantifier
        // - Not used by pronoun: Existential quantifier
        for (_noun, donkey_var, used) in self.donkey_bindings.iter().rev() {
            let donkey_kind = if *used {
                QuantifierKind::Universal
            } else {
                QuantifierKind::Existential
            };
            result = self.ctx.exprs.alloc(Expr::Quantifier {
                kind: donkey_kind,
                variable: *donkey_var,
                body: result,
                island_id: self.current_island,
            });
        }
        self.donkey_bindings.clear();

        Ok(result)
    }

    /// Parse a noun phrase with context-sensitive PP attachment.
    /// - `greedy: true` - Subject position: consume all PPs (they must belong to noun)
    /// - `greedy: false` - Object position: only consume PPs if pp_attach_to_noun flag is set
    fn parse_noun_phrase(&mut self, greedy: bool) -> ParseResult<NounPhrase<'a>> {
        let mut definiteness = None;
        let mut adjectives = Vec::new();
        let mut non_intersective_prefix: Option<Symbol> = None;

        if let TokenType::Article(def) = self.peek().kind {
            definiteness = Some(def);
            self.advance();
        }

        // Check for non-intersective adjectives first
        // "fake gun"  compound predicate "Fake-Gun", not "Fake(x)  Gun(x)"
        if self.check_non_intersective_adjective() {
            if let TokenType::NonIntersectiveAdjective(adj) = self.advance().kind {
                non_intersective_prefix = Some(adj);
            }
        }

        loop {
            if self.is_at_end() {
                break;
            }

            let is_adjective = matches!(self.peek().kind, TokenType::Adjective(_));
            if !is_adjective {
                break;
            }

            let next_is_content = if self.current + 1 < self.tokens.len() {
                matches!(
                    self.tokens[self.current + 1].kind,
                    TokenType::Noun(_)
                        | TokenType::Adjective(_)
                        | TokenType::ProperName(_)
                )
            } else {
                false
            };

            if next_is_content {
                if let TokenType::Adjective(adj) = self.advance().kind {
                    adjectives.push(adj);
                }
            } else {
                break;
            }
        }

        let base_noun = self.consume_content_word()?;

        // If we have a non-intersective adjective, create compound noun
        let noun = if let Some(prefix) = non_intersective_prefix {
            let prefix_str = self.interner.resolve(prefix);
            let base_str = self.interner.resolve(base_noun);
            let compound = format!("{}-{}", prefix_str, base_str);
            self.interner.intern(&compound)
        } else {
            base_noun
        };

        // Check for possessive: "John's dog"  Possessive token follows
        if self.check_possessive() {
            self.advance(); // consume Possessive

            // The noun we just parsed is the possessor
            let possessor = self.ctx.nps.alloc(NounPhrase {
                definiteness,
                adjectives: self.ctx.syms.alloc_slice(adjectives.clone()),
                noun,
                possessor: None,
                pps: &[],
            });

            // Parse the possessed noun
            let possessed_noun = self.consume_content_word()?;

            return Ok(NounPhrase {
                definiteness: None,
                adjectives: &[],
                noun: possessed_noun,
                possessor: Some(possessor),
                pps: &[],
            });
        }

        // Context-sensitive PP attachment:
        // - greedy=true (subject): always consume PPs
        // - greedy=false (object): only consume if pp_attach_to_noun flag is set
        let should_attach_pps = greedy || self.pp_attach_to_noun;

        let mut pps: Vec<&'a Expr<'a>> = Vec::new();
        if should_attach_pps {
            while self.check_preposition() && !self.check_of_preposition() {
                let prep_token = self.advance().clone();
                let prep_name = if let TokenType::Preposition(sym) = prep_token.kind {
                    sym
                } else {
                    break;
                };

                // Parse the object of the preposition (always greedy for nested NPs)
                if self.check_content_word() || matches!(self.peek().kind, TokenType::Article(_)) {
                    let pp_object = self.parse_noun_phrase(true)?;
                    let placeholder_var = self.interner.intern("_PP_SELF_");
                    let pp_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: prep_name,
                        args: self.ctx.terms.alloc_slice([
                            Term::Variable(placeholder_var),
                            Term::Constant(pp_object.noun),
                        ]),
                    });
                    pps.push(pp_pred);
                }
            }
        }
        let pps_slice = self.ctx.pps.alloc_slice(pps);

        // Check for "of" construction: "the dog of John"  possessor follows "of"
        if self.check_of_preposition() {
            self.advance(); // consume "of"

            // Parse the possessor (greedy for nested)
            let possessor_np = self.parse_noun_phrase(true)?;
            let possessor = self.ctx.nps.alloc(possessor_np);

            return Ok(NounPhrase {
                definiteness,
                adjectives: self.ctx.syms.alloc_slice(adjectives),
                noun,
                possessor: Some(possessor),
                pps: pps_slice,
            });
        }

        // Register noun with article for discourse tracking
        if definiteness.is_some() {
            let noun_str = self.interner.resolve(noun);
            let symbol = noun_str.chars().next().unwrap().to_uppercase().to_string();
            let number = if noun_str.ends_with('s') && !noun_str.ends_with("ss") {
                Number::Plural
            } else {
                Number::Singular
            };
            let noun_class = noun_str.to_string();
            self.register_entity(&symbol, &noun_class, Gender::Neuter, number);
        }

        Ok(NounPhrase {
            definiteness,
            adjectives: self.ctx.syms.alloc_slice(adjectives),
            noun,
            possessor: None,
            pps: pps_slice,
        })
    }

    fn check_possessive(&self) -> bool {
        matches!(self.peek().kind, TokenType::Possessive)
    }

    fn check_of_preposition(&self) -> bool {
        if let TokenType::Preposition(p) = self.peek().kind {
            p.is(self.interner, "of")
        } else {
            false
        }
    }

    fn noun_phrase_to_term(&self, np: &NounPhrase<'a>) -> Term<'a> {
        if let Some(possessor) = np.possessor {
            let possessor_term = self.noun_phrase_to_term(possessor);
            Term::Possessed {
                possessor: self.ctx.terms.alloc(possessor_term),
                possessed: np.noun,
            }
        } else {
            Term::Constant(np.noun)
        }
    }

    fn parse_restriction(&mut self, var_name: Symbol) -> ParseResult<&'a Expr<'a>> {
        let mut conditions: Vec<&'a Expr<'a>> = Vec::new();

        // Parse adjectives as predicates: "happy"  Happy(x)
        loop {
            if self.is_at_end() {
                break;
            }

            let is_adjective = matches!(self.peek().kind, TokenType::Adjective(_));
            if !is_adjective {
                break;
            }

            // Check if followed by content word (meaning this adjective modifies a noun)
            // Exclude Verb - if next is a verb, current word is likely the noun (subject)
            let next_is_content = if self.current + 1 < self.tokens.len() {
                matches!(
                    self.tokens[self.current + 1].kind,
                    TokenType::Noun(_)
                        | TokenType::Adjective(_)
                        | TokenType::ProperName(_)
                )
            } else {
                false
            };

            if next_is_content {
                if let TokenType::Adjective(adj) = self.advance().kind.clone() {
                    conditions.push(self.ctx.exprs.alloc(Expr::Predicate {
                        name: adj,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                    }));
                }
            } else {
                break;
            }
        }

        // Parse the head noun as predicate: "dogs"  Dog(x)
        let noun = self.consume_content_word()?;
        conditions.push(self.ctx.exprs.alloc(Expr::Predicate {
            name: noun,
            args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
        }));

        // Parse relative clause if present: "that bark" or "that the dog chased"
        if self.check(&TokenType::That) || self.check(&TokenType::Who) {
            self.advance();
            let clause_pred = self.parse_relative_clause(var_name)?;
            conditions.push(clause_pred);
        }

        // Combine all conditions with AND
        self.combine_with_and(conditions)
    }

    fn parse_verb_phrase_for_restriction(&mut self, var_name: Symbol) -> ParseResult<&'a Expr<'a>> {
        let var_term = Term::Variable(var_name);
        let verb = self.consume_verb();
        let mut args = vec![var_term];
        let mut extra_conditions: Vec<&'a Expr<'a>> = Vec::new();

        if self.check(&TokenType::Reflexive) {
            self.advance();
            args.push(Term::Variable(var_name));
        } else if (self.check_content_word() || self.check_article()) && !self.check_verb() {
            // Don't consume a verb as the object - it might be the main verb after the relative clause
            // Check for indefinite article (donkey anaphora trigger)
            // Use pattern match instead of check() to distinguish Indefinite from Definite
            if matches!(self.peek().kind, TokenType::Article(Definiteness::Indefinite)) {
                self.advance(); // consume "a"/"an"
                let noun = self.consume_content_word()?;
                let donkey_var = self.next_var_name();

                // Register this indefinite for later pronoun resolution
                self.donkey_bindings.push((noun, donkey_var, false));

                // Add type predicate: Donkey(y)
                extra_conditions.push(self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(donkey_var)]),
                }));

                args.push(Term::Variable(donkey_var));
            } else {
                let object = self.parse_noun_phrase(false)?;

                // Handle nested relative clause on object: "saw the woman who left"
                if self.check(&TokenType::That) || self.check(&TokenType::Who) {
                    self.advance();
                    let nested_var = self.next_var_name();
                    let nested_rel = self.parse_relative_clause(nested_var)?;

                    // Add type predicate for the nested object
                    extra_conditions.push(self.ctx.exprs.alloc(Expr::Predicate {
                        name: object.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(nested_var)]),
                    }));
                    extra_conditions.push(nested_rel);
                    args.push(Term::Variable(nested_var));
                } else {
                    args.push(Term::Constant(object.noun));
                }
            }
        }

        while self.check_preposition() {
            self.advance();
            if self.check(&TokenType::Reflexive) {
                self.advance();
                args.push(Term::Variable(var_name));
            } else if self.check_content_word() {
                let object = self.parse_noun_phrase(false)?;
                args.push(Term::Constant(object.noun));
            }
        }

        let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
            name: verb,
            args: self.ctx.terms.alloc_slice(args),
        });

        // Combine verb predicate with any extra conditions (type predicates for indefinites)
        if extra_conditions.is_empty() {
            Ok(verb_pred)
        } else {
            extra_conditions.push(verb_pred);
            self.combine_with_and(extra_conditions)
        }
    }

    fn parse_relative_clause(&mut self, gap_var: Symbol) -> ParseResult<&'a Expr<'a>> {
        // After "that" or "who", determine if subject-gap or object-gap
        // Subject-gap: "dogs that bark" - verb follows immediately
        // Object-gap: "cat that the dog chased" - NP follows, then verb (missing object)

        if self.check_verb() {
            // Subject-gap: the head noun is the subject
            return self.parse_verb_phrase_for_restriction(gap_var);
        }

        // Object-gap: parse subject NP, then verb, gap is the object
        if self.check_content_word() || self.check_article() {
            let rel_subject = self.parse_noun_phrase_for_relative()?;

            if self.check_verb() {
                let verb = self.consume_verb();
                // The gap_term is the object
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([
                        Term::Constant(rel_subject.noun),
                        Term::Variable(gap_var),
                    ]),
                }));
            }
        }

        // Fallback: treat as subject-gap if we have a verb
        if self.check_verb() {
            return self.parse_verb_phrase_for_restriction(gap_var);
        }

        let unknown = self.interner.intern("?");
        Ok(self.ctx.exprs.alloc(Expr::Atom(unknown)))
    }

    fn parse_noun_phrase_for_relative(&mut self) -> ParseResult<NounPhrase<'a>> {
        let mut definiteness = None;
        let mut adjectives = Vec::new();

        if let TokenType::Article(def) = self.peek().kind {
            definiteness = Some(def);
            self.advance();
        }

        loop {
            if self.is_at_end() {
                break;
            }

            let is_adjective = matches!(self.peek().kind, TokenType::Adjective(_));
            if !is_adjective {
                break;
            }

            let next_is_content = if self.current + 1 < self.tokens.len() {
                matches!(
                    self.tokens[self.current + 1].kind,
                    TokenType::Noun(_)
                        | TokenType::Adjective(_)
                        | TokenType::Verb { .. }
                        | TokenType::ProperName(_)
                )
            } else {
                false
            };

            if next_is_content {
                if let TokenType::Adjective(adj) = self.advance().kind.clone() {
                    adjectives.push(adj);
                }
            } else {
                break;
            }
        }

        // Check for nested relative clause
        let noun = self.consume_content_word_for_relative()?;

        // Handle nested "that" clause
        if self.check(&TokenType::That) || self.check(&TokenType::Who) {
            self.advance();
            let var_name = self.interner.intern(&format!("r{}", self.var_counter));
            self.var_counter += 1;
            let _nested_clause = self.parse_relative_clause(var_name)?;
        }

        Ok(NounPhrase {
            definiteness,
            adjectives: self.ctx.syms.alloc_slice(adjectives),
            noun,
            possessor: None,
            pps: &[],
        })
    }

    fn consume_content_word_for_relative(&mut self) -> ParseResult<Symbol> {
        let t = self.advance().clone();
        match t.kind {
            TokenType::Noun(s) | TokenType::Adjective(s) => Ok(s),
            TokenType::ProperName(s) => Ok(s),
            TokenType::Verb { lemma, .. } => Ok(lemma),
            other => Err(ParseError {
                kind: ParseErrorKind::ExpectedContentWord { found: other },
                span: self.current_span(),
            }),
        }
    }

    fn combine_with_and(&self, mut exprs: Vec<&'a Expr<'a>>) -> ParseResult<&'a Expr<'a>> {
        if exprs.is_empty() {
            return Err(ParseError {
                kind: ParseErrorKind::EmptyRestriction,
                span: self.current_span(),
            });
        }
        if exprs.len() == 1 {
            return Ok(exprs.remove(0));
        }
        let mut root = exprs.remove(0);
        for expr in exprs {
            root = self.ctx.exprs.alloc(Expr::BinaryOp {
                left: root,
                op: TokenType::And,
                right: expr,
            });
        }
        Ok(root)
    }

    fn parse_modal(&mut self) -> ParseResult<&'a Expr<'a>> {
        let vector = self.token_to_vector(&self.previous().kind.clone());

        if self.check(&TokenType::That) {
            self.advance();
        }

        let content = self.parse_sentence()?;

        Ok(self.ctx.exprs.alloc(Expr::Modal {
            vector,
            operand: content,
        }))
    }

    fn check_modal(&self) -> bool {
        matches!(
            self.peek().kind,
            TokenType::Must
                | TokenType::Shall
                | TokenType::Should
                | TokenType::Can
                | TokenType::May
                | TokenType::Cannot
        )
    }

    fn parse_aspect_chain(&mut self, subject_symbol: Symbol) -> ParseResult<&'a Expr<'a>> {
        let subject_term = Term::Constant(subject_symbol);

        let mut has_modal = false;
        let mut modal_vector = None;
        let mut has_perfect = false;
        let mut has_passive = false;
        let mut has_progressive = false;

        // Check for "would" modal
        if self.check(&TokenType::Would) {
            self.advance();
            has_modal = true;
            modal_vector = Some(ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.5,
            });
        }

        // Check for "have"/"has"/"had" (perfect aspect)
        if self.check_content_word() {
            let word = self.interner.resolve(self.peek().lexeme).to_lowercase();
            if word == "have" || word == "has" || word == "had" {
                self.advance();
                has_perfect = true;
            }
        }

        // Check for "been" (passive voice or just perfect of "be")
        if self.check_content_word() {
            let word = self.interner.resolve(self.peek().lexeme).to_lowercase();
            if word == "been" {
                self.advance();
                has_passive = true;
            }
        }

        // Check for "being" (progressive aspect)
        if self.check_content_word() {
            let word = self.interner.resolve(self.peek().lexeme).to_lowercase();
            if word == "being" {
                self.advance();
                has_progressive = true;
            }
        }

        // Now consume the main verb (might be tokenized as adjective like "close")
        let verb = if self.check_verb() {
            self.consume_verb()
        } else if self.check_content_word() {
            self.consume_content_word()?
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedContentWord { found: self.peek().kind.clone() },
                span: self.peek().span.clone(),
            });
        };

        // Build the predicate with subject
        let base_pred = self.ctx.exprs.alloc(Expr::Predicate {
            name: verb,
            args: self.ctx.terms.alloc_slice([subject_term]),
        });

        // Apply operators from inside out (verb first, then progressive, passive, perfect, modal)
        let mut result: &'a Expr<'a> = base_pred;

        if has_progressive {
            result = self.ctx.aspectual(AspectOperator::Progressive, result);
        }

        if has_passive {
            result = self.ctx.voice(VoiceOperator::Passive, result);
        }

        if has_perfect {
            result = self.ctx.aspectual(AspectOperator::Perfect, result);
        }

        if has_modal {
            if let Some(vector) = modal_vector {
                result = self.ctx.modal(vector, result);
            }
        }

        Ok(result)
    }

    fn token_to_vector(&self, token: &TokenType) -> ModalVector {
        match token {
            TokenType::Must => ModalVector {
                domain: ModalDomain::Alethic,
                force: 1.0,
            },
            TokenType::Cannot => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.0,
            },
            TokenType::Can => ModalVector {
                domain: ModalDomain::Alethic,
                force: 0.5,
            },
            TokenType::Shall => ModalVector {
                domain: ModalDomain::Deontic,
                force: 0.9,
            },
            TokenType::Should => ModalVector {
                domain: ModalDomain::Deontic,
                force: 0.6,
            },
            TokenType::May => ModalVector {
                domain: ModalDomain::Deontic,
                force: 0.5,
            },
            _ => panic!("Unknown modal token: {:?}", token),
        }
    }

    fn check_pronoun(&self) -> bool {
        matches!(self.peek().kind, TokenType::Pronoun { .. })
    }

    fn parse_atom(&mut self) -> ParseResult<&'a Expr<'a>> {
        // Handle Focus particles: "Only John loves Mary", "Even John ran"
        if self.check_focus() {
            return self.parse_focus();
        }

        // Handle mass noun measure: "Much water flows", "Little time remains"
        if self.check_measure() {
            return self.parse_measure();
        }

        if self.check_quantifier() {
            self.advance();
            return self.parse_quantified();
        }

        if self.match_token(&[TokenType::LParen]) {
            let expr = self.parse_sentence()?;
            self.consume(TokenType::RParen)?;
            return Ok(expr);
        }

        // Handle pronoun as subject
        if self.check_pronoun() {
            let token = self.advance().clone();
            if let TokenType::Pronoun { gender, number, .. } = token.kind {
                let token_text = self.interner.resolve(token.lexeme);

                // Handle deictic pronouns that don't need discourse resolution
                let resolved = if token_text.eq_ignore_ascii_case("i") {
                    self.interner.intern("Speaker")
                } else if token_text.eq_ignore_ascii_case("you") {
                    self.interner.intern("Addressee")
                } else {
                    // Try discourse resolution for anaphoric pronouns
                    let unknown = self.interner.intern("?");
                    self.resolve_pronoun(gender, number).unwrap_or(unknown)
                };

                // Check for performative: "I promise that..."
                if self.check_performative() {
                    if let TokenType::Performative(act) = self.advance().kind.clone() {
                        // Skip "that" if present
                        if self.check(&TokenType::That) {
                            self.advance();
                        }
                        let content = self.parse_sentence()?;
                        return Ok(self.ctx.exprs.alloc(Expr::SpeechAct {
                            performer: resolved,
                            act_type: act,
                            content,
                        }));
                    }
                }

                // Continue parsing verb phrase with resolved subject
                return self.parse_predicate_with_subject(resolved);
            }
        }

        let subject = self.parse_noun_phrase(true)?;

        // Handle plural subjects: "John and Mary verb"
        if self.check(&TokenType::And) {
            if let Some(result) = self.try_parse_plural_subject(&subject) {
                return Ok(result);
            }
        }

        // Handle scopal adverbs: "John almost died"
        if self.check_scopal_adverb() {
            return self.parse_scopal_adverb(&subject);
        }

        // Handle topicalization: "The cake, John ate." - first NP is object, not subject
        if self.check(&TokenType::Comma) {
            let saved_pos = self.current;
            self.advance(); // consume comma

            // Check if followed by another NP and then a verb (topicalization pattern)
            if self.check_content_word() || self.check_pronoun() {
                let topic_attempt = self.try_parse(|p| {
                    let real_subject = p.parse_noun_phrase(true)?;
                    if p.check_verb() {
                        let verb = p.consume_verb();
                        let predicate = p.ctx.exprs.alloc(Expr::Predicate {
                            name: verb,
                            args: p.ctx.terms.alloc_slice([
                                Term::Constant(real_subject.noun),
                                Term::Constant(subject.noun),
                            ]),
                        });
                        p.wrap_with_definiteness(subject.definiteness, subject.noun, predicate)
                    } else {
                        Err(ParseError {
                            kind: ParseErrorKind::ExpectedVerb { found: p.peek().kind.clone() },
                            span: p.current_span(),
                        })
                    }
                });

                if let Some(result) = topic_attempt {
                    return Ok(result);
                }
            }

            // Restore position if topicalization didn't match
            self.current = saved_pos;
        }

        // Handle relative clause after subject: "The cat that the dog chased ran."
        let mut relative_clause: Option<(Symbol, &'a Expr<'a>)> = None;
        if self.check(&TokenType::That) || self.check(&TokenType::Who) {
            self.advance();
            let var_name = self.next_var_name();
            let rel_pred = self.parse_relative_clause(var_name)?;
            relative_clause = Some((var_name, rel_pred));
        } else if matches!(self.peek().kind, TokenType::Article(_)) && self.is_contact_clause_pattern() {
            // Contact clause (reduced relative): "The cat the dog chased ran."
            // NP + NP + Verb pattern indicates embedded relative without explicit "that"
            let var_name = self.next_var_name();
            let rel_pred = self.parse_relative_clause(var_name)?;
            relative_clause = Some((var_name, rel_pred));
        }

        // Handle main verb after relative clause: "The cat that the dog chased ran."
        if let Some((var_name, rel_clause)) = relative_clause {
            if self.check_verb() {
                let (verb, verb_time, _) = self.consume_verb_with_metadata();
                let var_term = Term::Variable(var_name);

                let main_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([var_term]),
                });

                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: subject.noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                let inner = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: rel_clause,
                });

                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: inner,
                    op: TokenType::And,
                    right: main_pred,
                });

                let with_time = if verb_time == Time::Past {
                    self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body,
                    })
                } else {
                    body
                };

                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var_name,
                    body: with_time,
                    island_id: self.current_island,
                }));
            }

            // No main verb - just the relative clause: "The cat that runs" as a complete NP
            // Build: x(Cat(x)  Runs(x)  y(Cat(y)  y=x))
            if self.is_at_end() || self.check(&TokenType::Period) || self.check(&TokenType::Comma) {
                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: subject.noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: rel_clause,
                });

                // Add uniqueness for definite description
                let uniqueness_body = if subject.definiteness == Some(Definiteness::Definite) {
                    let y_var = self.next_var_name();
                    let type_pred_y = self.ctx.exprs.alloc(Expr::Predicate {
                        name: subject.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(y_var)]),
                    });
                    let identity = self.ctx.exprs.alloc(Expr::Identity {
                        left: self.ctx.terms.alloc(Term::Variable(y_var)),
                        right: self.ctx.terms.alloc(Term::Variable(var_name)),
                    });
                    let uniqueness_cond = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: type_pred_y,
                        op: TokenType::If,
                        right: identity,
                    });
                    let uniqueness = self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: QuantifierKind::Universal,
                        variable: y_var,
                        body: uniqueness_cond,
                        island_id: self.current_island,
                    });
                    self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: body,
                        op: TokenType::And,
                        right: uniqueness,
                    })
                } else {
                    body
                };

                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var_name,
                    body: uniqueness_body,
                    island_id: self.current_island,
                }));
            }

            // Re-store for copula handling below
            relative_clause = Some((var_name, rel_clause));
        }

        // Identity check: "Clark is equal to Superman"
        if self.check(&TokenType::Identity) {
            self.advance();
            let right = self.consume_content_word()?;
            return Ok(self.ctx.exprs.alloc(Expr::Identity {
                left: self.ctx.terms.alloc(Term::Constant(subject.noun)),
                right: self.ctx.terms.alloc(Term::Constant(right)),
            }));
        }

        if self.check_modal() {
            self.advance();
            let vector = self.token_to_vector(&self.previous().kind.clone());
            let verb = self.consume_content_word()?;
            let inner = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject.noun)]),
            });
            return Ok(self.ctx.exprs.alloc(Expr::Modal {
                vector,
                operand: inner,
            }));
        }

        if self.check(&TokenType::Is) || self.check(&TokenType::Are)
            || self.check(&TokenType::Was) || self.check(&TokenType::Were)
        {
            let copula_time = if self.check(&TokenType::Was) || self.check(&TokenType::Were) {
                Time::Past
            } else {
                Time::Present
            };
            self.advance();

            // Check for comparative: "is taller than"
            if self.check_comparative() {
                return self.parse_comparative(&subject, copula_time);
            }

            // Check for existential "is": "God is." - bare copula followed by period/EOF
            if self.check(&TokenType::Period) || self.is_at_end() {
                let var = self.next_var_name();
                let body = self.ctx.exprs.alloc(Expr::Identity {
                    left: self.ctx.terms.alloc(Term::Variable(var)),
                    right: self.ctx.terms.alloc(Term::Constant(subject.noun)),
                });
                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body,
                    island_id: self.current_island,
                }));
            }

            // Check for superlative: "is the tallest man"
            if self.check(&TokenType::Article(Definiteness::Definite)) {
                let saved_pos = self.current;
                self.advance();
                if self.check_superlative() {
                    return self.parse_superlative(&subject);
                }
                self.current = saved_pos;
            }

            if self.check_verb() {
                let (verb, _verb_time, verb_aspect) = self.consume_verb_with_metadata();

                // Collect any prepositional phrases before "by" (for ditransitives)
                // "given to Mary by John"  goal = Mary, then agent = John
                let mut goal_args: Vec<Term<'a>> = Vec::new();
                while self.check_to_preposition() {
                    self.advance(); // consume "to"
                    let goal = self.parse_noun_phrase(true)?;
                    goal_args.push(self.noun_phrase_to_term(&goal));
                }

                // Check for passive: "was loved by John" or "was given to Mary by John"
                if self.check_by_preposition() {
                    self.advance(); // consume "by"
                    let agent = self.parse_noun_phrase(true)?;

                    // Build args: agent, theme (subject), then any goals
                    let mut args = vec![
                        self.noun_phrase_to_term(&agent),
                        self.noun_phrase_to_term(&subject),
                    ];
                    args.extend(goal_args);

                    let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                        name: verb,
                        args: self.ctx.terms.alloc_slice(args),
                    });

                    let with_time = if copula_time == Time::Past {
                        self.ctx.exprs.alloc(Expr::Temporal {
                            operator: TemporalOperator::Past,
                            body: predicate,
                        })
                    } else {
                        predicate
                    };

                    return self.wrap_with_definiteness(subject.definiteness, subject.noun, with_time);
                }

                // Agentless passive: "The book was read"  x.Read(x, Book)
                if copula_time == Time::Past && verb_aspect == Aspect::Simple {
                    // Could be agentless passive - treat as existential
                    let var_name = self.next_var_name();
                    let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                        name: verb,
                        args: self.ctx.terms.alloc_slice([
                            Term::Variable(var_name),
                            Term::Constant(subject.noun),
                        ]),
                    });

                    let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: subject.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                    });

                    let temporal = self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body: predicate,
                    });

                    let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: type_pred,
                        op: TokenType::And,
                        right: temporal,
                    });

                    return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: QuantifierKind::Existential,
                        variable: var_name,
                        body,
                        island_id: self.current_island,
                    }));
                }

                let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject.noun)]),
                });

                let with_aspect = if verb_aspect == Aspect::Progressive {
                    self.ctx.exprs.alloc(Expr::Aspectual {
                        operator: AspectOperator::Progressive,
                        body: predicate,
                    })
                } else {
                    predicate
                };

                let with_time = if copula_time == Time::Past {
                    self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body: with_aspect,
                    })
                } else {
                    with_aspect
                };

                return self.wrap_with_definiteness(subject.definiteness, subject.noun, with_time);
            }

            // Handle relative clause with copula: "The book that John read is good."
            if let Some((var_name, rel_clause)) = relative_clause {
                let var_term = Term::Variable(var_name);
                let pred_word = self.consume_content_word()?;

                let main_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: pred_word,
                    args: self.ctx.terms.alloc_slice([var_term]),
                });

                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: subject.noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                let inner = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: rel_clause,
                });

                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: inner,
                    op: TokenType::And,
                    right: main_pred,
                });

                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var_name,
                    body,
                    island_id: self.current_island,
                }));
            }

            // Handle "The king is bald" - NP copula ADJ
            let predicate_name = self.consume_content_word()?;
            let predicate = self.ctx.exprs.alloc(Expr::Predicate {
                name: predicate_name,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject.noun)]),
            });
            return self.wrap_with_definiteness(subject.definiteness, subject.noun, predicate);
        }

        // Handle auxiliary: set pending_time, handle negation
        if self.check_auxiliary() {
            let aux_time = if let TokenType::Auxiliary(time) = self.advance().kind {
                time
            } else {
                Time::None
            };
            self.pending_time = Some(aux_time);

            // Handle negation: "John did not see dogs"
            if self.match_token(&[TokenType::Not]) {
                self.negative_depth += 1;

                if self.check_verb() {
                    let verb = self.consume_verb();
                    let subject_term = self.noun_phrase_to_term(&subject);
                    let mut roles: Vec<(ThematicRole, Term<'a>)> = vec![(ThematicRole::Agent, subject_term)];

                    // Add temporal modifier from pending_time
                    let effective_time = self.pending_time.take().unwrap_or(Time::None);
                    let mut modifiers: Vec<Symbol> = vec![];
                    match effective_time {
                        Time::Past => modifiers.push(self.interner.intern("Past")),
                        Time::Future => modifiers.push(self.interner.intern("Future")),
                        _ => {}
                    }

                    // Check for object
                    if self.check_content_word() || self.check_article() || self.check_quantifier() {
                        let object = self.parse_noun_phrase(false)?;
                        let object_term = self.noun_phrase_to_term(&object);
                        roles.push((ThematicRole::Theme, object_term));
                    }

                    let event_var = self.interner.intern("e");
                    let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                        event_var,
                        verb,
                        roles: self.ctx.roles.alloc_slice(roles),
                        modifiers: self.ctx.syms.alloc_slice(modifiers),
                    })));

                    self.negative_depth -= 1;
                    return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: neo_event,
                    }));
                }

                self.negative_depth -= 1;
            }
            // Non-negated auxiliary: pending_time is set, fall through to normal verb handling
        }

        // Check for presupposition triggers: "stopped", "started", "regrets"
        if self.check_presup_trigger() {
            let presup_kind = if let TokenType::PresupTrigger(kind) = self.advance().kind {
                kind
            } else {
                panic!("Expected presupposition trigger");
            };
            return self.parse_presupposition(&subject, presup_kind);
        }

        // Handle bare plurals: "Birds fly."  Gen x. Bird(x)  Fly(x)
        let noun_str = self.interner.resolve(subject.noun);
        let is_bare_plural = subject.definiteness.is_none()
            && subject.possessor.is_none()
            && Self::is_plural_noun(noun_str)
            && self.check_verb();

        if is_bare_plural {
            let var_name = self.next_var_name();
            let (verb, verb_time, verb_aspect) = self.consume_verb_with_metadata();

            let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                name: subject.noun,
                args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
            });

            let mut args = vec![Term::Variable(var_name)];
            if self.check_content_word() {
                let object = self.parse_noun_phrase(false)?;
                args.push(self.noun_phrase_to_term(&object));
            }

            let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice(args),
            });

            let effective_time = self.pending_time.take().unwrap_or(verb_time);
            let with_time = match effective_time {
                Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: verb_pred,
                }),
                Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Future,
                    body: verb_pred,
                }),
                _ => verb_pred,
            };

            let with_aspect = if verb_aspect == Aspect::Progressive {
                self.ctx.exprs.alloc(Expr::Aspectual {
                    operator: AspectOperator::Progressive,
                    body: with_time,
                })
            } else {
                with_time
            };

            let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                left: type_pred,
                op: TokenType::If,
                right: with_aspect,
            });

            return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                kind: QuantifierKind::Generic,
                variable: var_name,
                body,
                island_id: self.current_island,
            }));
        }

        // Handle do-support: "John does not exist" or "John does run"
        if self.check(&TokenType::Does) || self.check(&TokenType::Do) {
            self.advance(); // consume does/do
            let is_negated = self.match_token(&[TokenType::Not]);

            if self.check_verb() {
                let verb = self.consume_verb();
                let verb_lemma = self.interner.resolve(verb).to_lowercase();

                // Special handling for "exist" with negation
                if verb_lemma == "exist" && is_negated {
                    // "The King of France does not exist" -> x(KingOfFrance(x))
                    let var_name = self.next_var_name();
                    let restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: subject.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                    });
                    let exists = self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: QuantifierKind::Existential,
                        variable: var_name,
                        body: restriction,
                        island_id: self.current_island,
                    });
                    return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: exists,
                    }));
                }

                // Regular do-support: "John does run" or "John does not run"
                let subject_term = self.noun_phrase_to_term(&subject);
                let roles: Vec<(ThematicRole, Term<'a>)> = vec![(ThematicRole::Agent, subject_term)];
                let modifiers: Vec<Symbol> = vec![];
                let event_var = self.interner.intern("e");

                let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                    event_var,
                    verb,
                    roles: self.ctx.roles.alloc_slice(roles),
                    modifiers: self.ctx.syms.alloc_slice(modifiers),
                })));

                if is_negated {
                    return Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                        op: TokenType::Not,
                        operand: neo_event,
                    }));
                }
                return Ok(neo_event);
            }
        }

        // Garden path detection: "The horse raced past the barn fell."
        // If we have a definite NP + past verb + more content + another verb,
        // try reduced relative interpretation
        if subject.definiteness == Some(Definiteness::Definite) && self.check_verb() {
            let saved_pos = self.current;

            // Try parsing as reduced relative: first verb is modifier, look for main verb after
            if let Some(garden_path_result) = self.try_parse(|p| {
                let (modifier_verb, modifier_time, _) = p.consume_verb_with_metadata();

                // Collect any PP modifiers on the reduced relative
                let mut pp_mods: Vec<&'a Expr<'a>> = Vec::new();
                while p.check_preposition() {
                    let prep = if let TokenType::Preposition(prep) = p.advance().kind {
                        prep
                    } else {
                        break;
                    };
                    if p.check_article() || p.check_content_word() {
                        let pp_obj = p.parse_noun_phrase(false)?;
                        let pp_pred = p.ctx.exprs.alloc(Expr::Predicate {
                            name: prep,
                            args: p.ctx.terms.alloc_slice([Term::Variable(p.interner.intern("x")), Term::Constant(pp_obj.noun)]),
                        });
                        pp_mods.push(pp_pred);
                    }
                }

                // Now check if there's ANOTHER verb (the real main verb)
                if !p.check_verb() {
                    return Err(ParseError {
                        kind: ParseErrorKind::ExpectedVerb { found: p.peek().kind.clone() },
                        span: p.current_span(),
                    });
                }

                let (main_verb, main_time, _) = p.consume_verb_with_metadata();

                // Build: x((Horse(x)  y(Horse(y)  y=x))  Raced(x)  Past(x, Barn)  Fell(x))
                let var = p.interner.intern("x");

                // Type predicate
                let type_pred = p.ctx.exprs.alloc(Expr::Predicate {
                    name: subject.noun,
                    args: p.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Modifier verb predicate (reduced relative)
                let mod_pred = p.ctx.exprs.alloc(Expr::Predicate {
                    name: modifier_verb,
                    args: p.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Main verb predicate
                let main_pred = p.ctx.exprs.alloc(Expr::Predicate {
                    name: main_verb,
                    args: p.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Combine type + modifier
                let mut body = p.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: mod_pred,
                });

                // Add PP modifiers
                for pp in pp_mods {
                    body = p.ctx.exprs.alloc(Expr::BinaryOp {
                        left: body,
                        op: TokenType::And,
                        right: pp,
                    });
                }

                // Add main predicate
                body = p.ctx.exprs.alloc(Expr::BinaryOp {
                    left: body,
                    op: TokenType::And,
                    right: main_pred,
                });

                // Wrap with temporal if needed
                let with_time = match main_time {
                    Time::Past => p.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body,
                    }),
                    Time::Future => p.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Future,
                        body,
                    }),
                    _ => body,
                };

                // Wrap in existential quantifier for definite
                Ok(p.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body: with_time,
                    island_id: p.current_island,
                }))
            }) {
                return Ok(garden_path_result);
            }

            // Restore position if garden path didn't work
            self.current = saved_pos;
        }

        // Handle aspect chain: "The apple would have been being eaten"
        if self.check(&TokenType::Would) {
            return self.parse_aspect_chain(subject.noun);
        }

        // Handle "has/have/had" perfect aspect: "John has run"
        if self.check_content_word() {
            let word = self.interner.resolve(self.peek().lexeme).to_lowercase();
            if word == "has" || word == "have" || word == "had" {
                return self.parse_aspect_chain(subject.noun);
            }
        }

        if self.check_verb() {
            let (verb, verb_time, verb_aspect) = self.consume_verb_with_metadata();

            // Check for control verb + infinitive
            if self.is_control_verb(verb) {
                return self.parse_control_structure(&subject, verb, verb_time);
            }

            // If we have a relative clause, use variable binding
            if let Some((var_name, rel_clause)) = relative_clause {
                let main_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                let effective_time = self.pending_time.take().unwrap_or(verb_time);
                let with_time = match effective_time {
                    Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Past,
                        body: main_pred,
                    }),
                    Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                        operator: TemporalOperator::Future,
                        body: main_pred,
                    }),
                    _ => main_pred,
                };

                // Build: x(Type(x)  RelClause(x)  MainPred(x))
                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: subject.noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var_name)]),
                });

                let inner = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: rel_clause,
                });

                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: inner,
                    op: TokenType::And,
                    right: with_time,
                });

                return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var_name,
                    body,
                    island_id: self.current_island,
                }));
            }

            let subject_term = self.noun_phrase_to_term(&subject);
            let mut args = vec![subject_term];

            let unknown = self.interner.intern("?");
            let mut object_term: Option<Term<'a>> = None;
            let mut second_object_term: Option<Term<'a>> = None;
            if self.check(&TokenType::Reflexive) {
                self.advance();
                let term = self.noun_phrase_to_term(&subject);
                object_term = Some(term.clone());
                args.push(term);
            } else if self.check_pronoun() {
                let token = self.advance().clone();
                if let TokenType::Pronoun { gender, number, .. } = token.kind {
                    let resolved = self.resolve_pronoun(gender, number)
                        .unwrap_or(unknown);
                    let term = Term::Constant(resolved);
                    object_term = Some(term.clone());
                    args.push(term);
                }
            } else if self.check_quantifier() || self.check_article() {
                // Quantified object: "John loves every woman" or "John saw a dog"
                let obj_quantifier = if self.check_quantifier() {
                    Some(self.advance().kind.clone())
                } else {
                    let art = self.advance().kind.clone();
                    if let TokenType::Article(def) = art {
                        if def == Definiteness::Indefinite {
                            Some(TokenType::Some)
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                };

                let object_np = self.parse_noun_phrase(false)?;

                if let Some(obj_q) = obj_quantifier {
                    let obj_var = self.next_var_name();
                    let obj_restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: object_np.noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(obj_var)]),
                    });

                    let event_var = self.interner.intern("e");
                    let mut modifiers = self.collect_adverbs();
                    let effective_time = self.pending_time.take().unwrap_or(verb_time);
                    match effective_time {
                        Time::Past => modifiers.push(self.interner.intern("Past")),
                        Time::Future => modifiers.push(self.interner.intern("Future")),
                        _ => {}
                    }

                    let subject_term_for_event = self.noun_phrase_to_term(&subject);
                    let roles = vec![
                        (ThematicRole::Agent, subject_term_for_event),
                        (ThematicRole::Theme, Term::Variable(obj_var)),
                    ];

                    let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                        event_var,
                        verb,
                        roles: self.ctx.roles.alloc_slice(roles),
                        modifiers: self.ctx.syms.alloc_slice(modifiers),
                    })));

                    let obj_kind = match obj_q {
                        TokenType::All => QuantifierKind::Universal,
                        TokenType::Some => QuantifierKind::Existential,
                        TokenType::No => QuantifierKind::Universal,
                        TokenType::Most => QuantifierKind::Most,
                        TokenType::Few => QuantifierKind::Few,
                        TokenType::Cardinal(n) => QuantifierKind::Cardinal(n),
                        TokenType::AtLeast(n) => QuantifierKind::AtLeast(n),
                        TokenType::AtMost(n) => QuantifierKind::AtMost(n),
                        _ => QuantifierKind::Existential,
                    };

                    let obj_body = match obj_q {
                        TokenType::All => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::If,
                            right: neo_event,
                        }),
                        TokenType::No => {
                            let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                                op: TokenType::Not,
                                operand: neo_event,
                            });
                            self.ctx.exprs.alloc(Expr::BinaryOp {
                                left: obj_restriction,
                                op: TokenType::If,
                                right: neg,
                            })
                        }
                        _ => self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: obj_restriction,
                            op: TokenType::And,
                            right: neo_event,
                        }),
                    };

                    return Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: obj_kind,
                        variable: obj_var,
                        body: obj_body,
                        island_id: self.current_island,
                    }));
                } else {
                    let term = self.noun_phrase_to_term(&object_np);
                    object_term = Some(term.clone());
                    args.push(term);
                }
            } else if self.check_content_word() {
                let object = self.parse_noun_phrase(false)?;
                let term = self.noun_phrase_to_term(&object);
                object_term = Some(term.clone());
                args.push(term);

                // Check for ditransitive: "John gave Mary a book"
                let verb_str = self.interner.resolve(verb);
                if Lexer::is_ditransitive_verb(verb_str) && (self.check_content_word() || self.check_article()) {
                    let second_np = self.parse_noun_phrase(false)?;
                    let second_term = self.noun_phrase_to_term(&second_np);
                    second_object_term = Some(second_term.clone());
                    args.push(second_term);
                }
            }

            let mut pp_predicates: Vec<&'a Expr<'a>> = Vec::new();
            while self.check_preposition() {
                let prep_token = self.advance().clone();
                let prep_name = if let TokenType::Preposition(sym) = prep_token.kind {
                    sym
                } else {
                    continue;
                };

                let pp_obj_term = if self.check(&TokenType::Reflexive) {
                    self.advance();
                    self.noun_phrase_to_term(&subject)
                } else if self.check_pronoun() {
                    let token = self.advance().clone();
                    if let TokenType::Pronoun { gender, number, .. } = token.kind {
                        let resolved = self.resolve_pronoun(gender, number)
                            .unwrap_or(unknown);
                        Term::Constant(resolved)
                    } else {
                        continue;
                    }
                } else if self.check_content_word() {
                    let prep_obj = self.parse_noun_phrase(true)?;
                    self.noun_phrase_to_term(&prep_obj)
                } else {
                    continue;
                };

                if self.pp_attach_to_noun {
                    if let Some(ref obj) = object_term {
                        // NP-attachment: PP modifies the object noun
                        let pp_pred = self.ctx.exprs.alloc(Expr::Predicate {
                            name: prep_name,
                            args: self.ctx.terms.alloc_slice([obj.clone(), pp_obj_term]),
                        });
                        pp_predicates.push(pp_pred);
                    } else {
                        args.push(pp_obj_term);
                    }
                } else {
                    // VP-attachment: PP modifies the event (instrument/manner)
                    let event_sym = self.interner.intern("e");
                    let pp_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: prep_name,
                        args: self.ctx.terms.alloc_slice([Term::Variable(event_sym), pp_obj_term]),
                    });
                    pp_predicates.push(pp_pred);
                }
            }

            // Check for trailing relative clause on object NP: "the girl with the telescope that laughed"
            if self.check(&TokenType::That) || self.check(&TokenType::Who) {
                self.advance();
                let rel_var = self.next_var_name();
                let rel_pred = self.parse_relative_clause(rel_var)?;
                pp_predicates.push(rel_pred);
            }

            // Collect any trailing adverbs FIRST (before building NeoEvent)
            let mut modifiers = self.collect_adverbs();

            // Add temporal modifier as part of event semantics
            let effective_time = self.pending_time.take().unwrap_or(verb_time);
            match effective_time {
                Time::Past => modifiers.push(self.interner.intern("Past")),
                Time::Future => modifiers.push(self.interner.intern("Future")),
                _ => {}
            }

            // Add aspect modifier if applicable
            if verb_aspect == Aspect::Progressive {
                modifiers.push(self.interner.intern("Progressive"));
            } else if verb_aspect == Aspect::Perfect {
                modifiers.push(self.interner.intern("Perfect"));
            }

            // Build thematic roles for Neo-Davidsonian event semantics
            let mut roles: Vec<(ThematicRole, Term<'a>)> = Vec::new();
            roles.push((ThematicRole::Agent, subject_term));
            if let Some(second_obj) = second_object_term {
                // Ditransitive: first object is Recipient, second is Theme
                if let Some(first_obj) = object_term {
                    roles.push((ThematicRole::Recipient, first_obj));
                }
                roles.push((ThematicRole::Theme, second_obj));
            } else if let Some(obj) = object_term {
                // Normal transitive: object is Theme
                roles.push((ThematicRole::Theme, obj));
            }

            // Create event variable
            let event_var = self.interner.intern("e");

            // Create NeoEvent structure with all modifiers including time/aspect
            let neo_event = self.ctx.exprs.alloc(Expr::NeoEvent(Box::new(NeoEventData {
                event_var,
                verb,
                roles: self.ctx.roles.alloc_slice(roles),
                modifiers: self.ctx.syms.alloc_slice(modifiers),
            })));

            // Combine with PP predicates if any
            let with_pps = if pp_predicates.is_empty() {
                neo_event
            } else {
                let mut combined = neo_event;
                for pp in pp_predicates {
                    combined = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: combined,
                        op: TokenType::And,
                        right: pp,
                    });
                }
                combined
            };

            // NeoEvent now includes temporal/aspectual modifiers directly
            let with_adverbs = with_pps;

            // Check for temporal anchor adverb at end of sentence
            let with_temporal = if self.check_temporal_adverb() {
                let anchor = if let TokenType::TemporalAdverb(adv) = self.advance().kind.clone() {
                    adv
                } else {
                    panic!("Expected temporal adverb");
                };
                self.ctx.exprs.alloc(Expr::TemporalAnchor {
                    anchor,
                    body: with_adverbs,
                })
            } else {
                with_adverbs
            };

            return self.wrap_with_definiteness_full(&subject, with_temporal);
        }

        Ok(self.ctx.exprs.alloc(Expr::Atom(subject.noun)))
    }

    fn wrap_with_definiteness_full(
        &mut self,
        np: &NounPhrase<'a>,
        predicate: &'a Expr<'a>,
    ) -> ParseResult<&'a Expr<'a>> {
        self.wrap_with_definiteness_and_adjectives_and_pps(
            np.definiteness,
            np.noun,
            np.adjectives,
            np.pps,
            predicate,
        )
    }

    fn wrap_with_definiteness(
        &mut self,
        definiteness: Option<Definiteness>,
        noun: Symbol,
        predicate: &'a Expr<'a>,
    ) -> ParseResult<&'a Expr<'a>> {
        self.wrap_with_definiteness_and_adjectives_and_pps(definiteness, noun, &[], &[], predicate)
    }

    fn wrap_with_definiteness_and_adjectives(
        &mut self,
        definiteness: Option<Definiteness>,
        noun: Symbol,
        adjectives: &[Symbol],
        predicate: &'a Expr<'a>,
    ) -> ParseResult<&'a Expr<'a>> {
        self.wrap_with_definiteness_and_adjectives_and_pps(definiteness, noun, adjectives, &[], predicate)
    }

    fn substitute_pp_placeholder(&mut self, pp: &'a Expr<'a>, var: Symbol) -> &'a Expr<'a> {
        let placeholder = self.interner.intern("_PP_SELF_");
        match pp {
            Expr::Predicate { name, args } => {
                let new_args: Vec<Term<'a>> = args
                    .iter()
                    .map(|arg| match arg {
                        Term::Variable(v) if *v == placeholder => Term::Variable(var),
                        other => *other,
                    })
                    .collect();
                self.ctx.exprs.alloc(Expr::Predicate {
                    name: *name,
                    args: self.ctx.terms.alloc_slice(new_args),
                })
            }
            _ => pp,
        }
    }

    fn wrap_with_definiteness_and_adjectives_and_pps(
        &mut self,
        definiteness: Option<Definiteness>,
        noun: Symbol,
        adjectives: &[Symbol],
        pps: &[&'a Expr<'a>],
        predicate: &'a Expr<'a>,
    ) -> ParseResult<&'a Expr<'a>> {
        match definiteness {
            Some(Definiteness::Indefinite) => {
                let var = self.next_var_name();

                // Build type predicate from noun
                let mut restriction = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Build adjective predicates (for intersective adjectives)
                for adj in adjectives {
                    let adj_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: *adj,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                    });
                    restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: restriction,
                        op: TokenType::And,
                        right: adj_pred,
                    });
                }

                // Add PP predicates to restriction (substitute placeholder with var)
                for pp in pps {
                    let substituted_pp = self.substitute_pp_placeholder(pp, var);
                    restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: restriction,
                        op: TokenType::And,
                        right: substituted_pp,
                    });
                }

                let substituted = self.substitute_constant_with_var_sym(predicate, noun, var)?;
                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: restriction,
                    op: TokenType::And,
                    right: substituted,
                });
                Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body,
                    island_id: self.current_island,
                }))
            }
            Some(Definiteness::Definite) => {
                let noun_str = self.interner.resolve(noun);

                if Self::is_plural_noun(noun_str) {
                    // Plural definite: "The dogs"  x.Dog(x)
                    let singular = Self::singularize_noun(noun_str);
                    let singular_sym = self.interner.intern(&singular);
                    let sigma_term = Term::Sigma(singular_sym);

                    // Substitute noun constant with sigma term
                    let substituted = self.substitute_constant_with_sigma(predicate, noun, sigma_term)?;

                    // Check if the verb is collective
                    let verb_name = self.find_main_verb_name(predicate);
                    let is_collective = verb_name
                        .map(|v| Lexer::is_collective_verb(self.interner.resolve(v)))
                        .unwrap_or(false);

                    if is_collective {
                        Ok(substituted)
                    } else {
                        Ok(self.ctx.exprs.alloc(Expr::Distributive {
                            predicate: substituted,
                        }))
                    }
                } else {
                    // Singular definite: Russell expansion
                    let x = self.next_var_name();
                    let y = self.next_var_name();

                    let mut restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(x)]),
                    });

                    for adj in adjectives {
                        let adj_pred = self.ctx.exprs.alloc(Expr::Predicate {
                            name: *adj,
                            args: self.ctx.terms.alloc_slice([Term::Variable(x)]),
                        });
                        restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: restriction,
                            op: TokenType::And,
                            right: adj_pred,
                        });
                    }

                    // Add PP predicates to restriction
                    for pp in pps {
                        let substituted_pp = self.substitute_pp_placeholder(pp, x);
                        restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: restriction,
                            op: TokenType::And,
                            right: substituted_pp,
                        });
                    }

                    let mut y_restriction = self.ctx.exprs.alloc(Expr::Predicate {
                        name: noun,
                        args: self.ctx.terms.alloc_slice([Term::Variable(y)]),
                    });
                    for adj in adjectives {
                        let adj_pred = self.ctx.exprs.alloc(Expr::Predicate {
                            name: *adj,
                            args: self.ctx.terms.alloc_slice([Term::Variable(y)]),
                        });
                        y_restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: y_restriction,
                            op: TokenType::And,
                            right: adj_pred,
                        });
                    }

                    // Add PP predicates to y_restriction
                    for pp in pps {
                        let substituted_pp = self.substitute_pp_placeholder(pp, y);
                        y_restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                            left: y_restriction,
                            op: TokenType::And,
                            right: substituted_pp,
                        });
                    }

                    let identity = self.ctx.exprs.alloc(Expr::Identity {
                        left: self.ctx.terms.alloc(Term::Variable(y)),
                        right: self.ctx.terms.alloc(Term::Variable(x)),
                    });
                    let uniqueness_body = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: y_restriction,
                        op: TokenType::If,
                        right: identity,
                    });
                    let uniqueness = self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: QuantifierKind::Universal,
                        variable: y,
                        body: uniqueness_body,
                        island_id: self.current_island,
                    });

                    let main_pred = self.substitute_constant_with_var_sym(predicate, noun, x)?;

                    let inner = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: restriction,
                        op: TokenType::And,
                        right: uniqueness,
                    });
                    let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: inner,
                        op: TokenType::And,
                        right: main_pred,
                    });

                    Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                        kind: QuantifierKind::Existential,
                        variable: x,
                        body,
                        island_id: self.current_island,
                    }))
                }
            }
            Some(Definiteness::Proximal) | Some(Definiteness::Distal) => {
                let var = self.next_var_name();

                // Build type predicate from noun
                let mut restriction = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Add deictic predicate (Proximal or Distal)
                let deictic_name = if matches!(definiteness, Some(Definiteness::Proximal)) {
                    self.interner.intern("Proximal")
                } else {
                    self.interner.intern("Distal")
                };
                let deictic_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: deictic_name,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });
                restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: restriction,
                    op: TokenType::And,
                    right: deictic_pred,
                });

                // Build adjective predicates
                for adj in adjectives {
                    let adj_pred = self.ctx.exprs.alloc(Expr::Predicate {
                        name: *adj,
                        args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                    });
                    restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: restriction,
                        op: TokenType::And,
                        right: adj_pred,
                    });
                }

                // Add PP predicates to restriction
                for pp in pps {
                    let substituted_pp = self.substitute_pp_placeholder(pp, var);
                    restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                        left: restriction,
                        op: TokenType::And,
                        right: substituted_pp,
                    });
                }

                let substituted = self.substitute_constant_with_var_sym(predicate, noun, var)?;
                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: restriction,
                    op: TokenType::And,
                    right: substituted,
                });
                Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body,
                    island_id: self.current_island,
                }))
            }
            None => Ok(predicate),
        }
    }

    fn substitute_constant_with_var(&self, expr: &'a Expr<'a>, constant_name: Symbol, var_name: Symbol) -> ParseResult<&'a Expr<'a>> {
        match expr {
            Expr::Predicate { name, args } => {
                let new_args: Vec<Term<'a>> = args
                    .iter()
                    .map(|arg| match arg {
                        Term::Constant(c) if *c == constant_name => Term::Variable(var_name),
                        Term::Constant(c) => Term::Constant(*c),
                        Term::Variable(v) => Term::Variable(*v),
                        Term::Function(n, a) => Term::Function(*n, *a),
                        Term::Group(m) => Term::Group(*m),
                        Term::Possessed { possessor, possessed } => Term::Possessed {
                            possessor: *possessor,
                            possessed: *possessed,
                        },
                        Term::Sigma(p) => Term::Sigma(*p),
                    })
                    .collect();
                Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: *name,
                    args: self.ctx.terms.alloc_slice(new_args),
                }))
            }
            Expr::Temporal { operator, body } => Ok(self.ctx.exprs.alloc(Expr::Temporal {
                operator: *operator,
                body: self.substitute_constant_with_var(body, constant_name, var_name)?,
            })),
            Expr::Aspectual { operator, body } => Ok(self.ctx.exprs.alloc(Expr::Aspectual {
                operator: *operator,
                body: self.substitute_constant_with_var(body, constant_name, var_name)?,
            })),
            Expr::UnaryOp { op, operand } => Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                op: *op,
                operand: self.substitute_constant_with_var(operand, constant_name, var_name)?,
            })),
            Expr::BinaryOp { left, op, right } => Ok(self.ctx.exprs.alloc(Expr::BinaryOp {
                left: self.substitute_constant_with_var(left, constant_name, var_name)?,
                op: *op,
                right: self.substitute_constant_with_var(right, constant_name, var_name)?,
            })),
            Expr::Event { predicate, adverbs } => Ok(self.ctx.exprs.alloc(Expr::Event {
                predicate: self.substitute_constant_with_var(predicate, constant_name, var_name)?,
                adverbs: *adverbs,
            })),
            Expr::TemporalAnchor { anchor, body } => Ok(self.ctx.exprs.alloc(Expr::TemporalAnchor {
                anchor: *anchor,
                body: self.substitute_constant_with_var(body, constant_name, var_name)?,
            })),
            _ => Ok(expr),
        }
    }

    fn substitute_constant_with_var_sym(&self, expr: &'a Expr<'a>, constant_name: Symbol, var_name: Symbol) -> ParseResult<&'a Expr<'a>> {
        self.substitute_constant_with_var(expr, constant_name, var_name)
    }

    fn substitute_constant_with_sigma(&self, expr: &'a Expr<'a>, constant_name: Symbol, sigma_term: Term<'a>) -> ParseResult<&'a Expr<'a>> {
        match expr {
            Expr::Predicate { name, args } => {
                let new_args: Vec<Term<'a>> = args
                    .iter()
                    .map(|arg| match arg {
                        Term::Constant(c) if *c == constant_name => sigma_term.clone(),
                        Term::Constant(c) => Term::Constant(*c),
                        Term::Variable(v) => Term::Variable(*v),
                        Term::Function(n, a) => Term::Function(*n, *a),
                        Term::Group(m) => Term::Group(*m),
                        Term::Possessed { possessor, possessed } => Term::Possessed {
                            possessor: *possessor,
                            possessed: *possessed,
                        },
                        Term::Sigma(p) => Term::Sigma(*p),
                    })
                    .collect();
                Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: *name,
                    args: self.ctx.terms.alloc_slice(new_args),
                }))
            }
            Expr::Temporal { operator, body } => Ok(self.ctx.exprs.alloc(Expr::Temporal {
                operator: *operator,
                body: self.substitute_constant_with_sigma(body, constant_name, sigma_term)?,
            })),
            Expr::Aspectual { operator, body } => Ok(self.ctx.exprs.alloc(Expr::Aspectual {
                operator: *operator,
                body: self.substitute_constant_with_sigma(body, constant_name, sigma_term)?,
            })),
            Expr::UnaryOp { op, operand } => Ok(self.ctx.exprs.alloc(Expr::UnaryOp {
                op: *op,
                operand: self.substitute_constant_with_sigma(operand, constant_name, sigma_term)?,
            })),
            Expr::BinaryOp { left, op, right } => Ok(self.ctx.exprs.alloc(Expr::BinaryOp {
                left: self.substitute_constant_with_sigma(left, constant_name, sigma_term.clone())?,
                op: *op,
                right: self.substitute_constant_with_sigma(right, constant_name, sigma_term)?,
            })),
            Expr::Event { predicate, adverbs } => Ok(self.ctx.exprs.alloc(Expr::Event {
                predicate: self.substitute_constant_with_sigma(predicate, constant_name, sigma_term)?,
                adverbs: *adverbs,
            })),
            Expr::TemporalAnchor { anchor, body } => Ok(self.ctx.exprs.alloc(Expr::TemporalAnchor {
                anchor: *anchor,
                body: self.substitute_constant_with_sigma(body, constant_name, sigma_term)?,
            })),
            _ => Ok(expr),
        }
    }

    fn find_main_verb_name(&self, expr: &Expr<'a>) -> Option<Symbol> {
        match expr {
            Expr::Predicate { name, .. } => Some(*name),
            Expr::Temporal { body, .. } => self.find_main_verb_name(body),
            Expr::Aspectual { body, .. } => self.find_main_verb_name(body),
            Expr::Event { predicate, .. } => self.find_main_verb_name(predicate),
            Expr::TemporalAnchor { body, .. } => self.find_main_verb_name(body),
            Expr::UnaryOp { operand, .. } => self.find_main_verb_name(operand),
            Expr::BinaryOp { left, .. } => self.find_main_verb_name(left),
            _ => None,
        }
    }

    fn check_preposition(&self) -> bool {
        matches!(self.peek().kind, TokenType::Preposition(_))
    }

    fn check_by_preposition(&self) -> bool {
        if let TokenType::Preposition(p) = self.peek().kind {
            p.is(self.interner, "by")
        } else {
            false
        }
    }

    fn check_to_preposition(&self) -> bool {
        if let TokenType::Preposition(p) = self.peek().kind {
            p.is(self.interner, "to")
        } else {
            false
        }
    }

    fn check_content_word(&self) -> bool {
        matches!(
            self.peek().kind,
            TokenType::Noun(_)
                | TokenType::Adjective(_)
                | TokenType::NonIntersectiveAdjective(_)
                | TokenType::Verb { .. }
                | TokenType::ProperName(_)
                | TokenType::Article(_)
        )
    }

    fn check_verb(&self) -> bool {
        matches!(self.peek().kind, TokenType::Verb { .. })
    }

    fn check_adverb(&self) -> bool {
        matches!(self.peek().kind, TokenType::Adverb(_))
    }

    fn check_performative(&self) -> bool {
        matches!(self.peek().kind, TokenType::Performative(_))
    }

    fn collect_adverbs(&mut self) -> Vec<Symbol> {
        let mut adverbs = Vec::new();
        while self.check_adverb() {
            if let TokenType::Adverb(adv) = self.advance().kind.clone() {
                adverbs.push(adv);
            }
            // Skip "and" between adverbs
            if self.check(&TokenType::And) {
                self.advance();
            }
        }
        adverbs
    }

    fn check_auxiliary(&self) -> bool {
        matches!(self.peek().kind, TokenType::Auxiliary(_))
    }

    fn check_to(&self) -> bool {
        matches!(self.peek().kind, TokenType::To)
    }

    fn is_control_verb(&self, verb: Symbol) -> bool {
        let lemma = self.interner.resolve(verb);
        Lexer::is_subject_control_verb(lemma)
            || Lexer::is_object_control_verb(lemma)
            || Lexer::is_raising_verb(lemma)
    }

    fn consume_verb(&mut self) -> Symbol {
        let t = self.advance().clone();
        match t.kind {
            TokenType::Verb { lemma, .. } => lemma,
            _ => panic!("Expected verb, got {:?}", t.kind),
        }
    }

    fn consume_verb_with_metadata(&mut self) -> (Symbol, Time, Aspect) {
        let t = self.advance().clone();
        match t.kind {
            TokenType::Verb { lemma, time, aspect } => (lemma, time, aspect),
            _ => panic!("Expected verb, got {:?}", t.kind),
        }
    }

    fn match_token(&mut self, types: &[TokenType]) -> bool {
        for t in types {
            if self.check(t) {
                self.advance();
                return true;
            }
        }
        false
    }

    fn check_quantifier(&self) -> bool {
        matches!(
            self.peek().kind,
            TokenType::All
                | TokenType::No
                | TokenType::Some
                | TokenType::Any
                | TokenType::Most
                | TokenType::Few
                | TokenType::Cardinal(_)
                | TokenType::AtLeast(_)
                | TokenType::AtMost(_)
        )
    }

    fn check(&self, kind: &TokenType) -> bool {
        if self.is_at_end() {
            return false;
        }
        std::mem::discriminant(&self.peek().kind) == std::mem::discriminant(kind)
    }

    fn check_any(&self, kinds: &[TokenType]) -> bool {
        if self.is_at_end() {
            return false;
        }
        let current = std::mem::discriminant(&self.peek().kind);
        kinds.iter().any(|k| std::mem::discriminant(k) == current)
    }

    fn check_article(&self) -> bool {
        matches!(self.peek().kind, TokenType::Article(_))
    }

    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }

    fn is_at_end(&self) -> bool {
        self.peek().kind == TokenType::EOF
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    fn previous(&self) -> &Token {
        &self.tokens[self.current - 1]
    }

    fn current_span(&self) -> crate::token::Span {
        self.peek().span
    }

    fn consume(&mut self, kind: TokenType) -> ParseResult<&Token> {
        if self.check(&kind) {
            Ok(self.advance())
        } else {
            Err(ParseError {
                kind: ParseErrorKind::UnexpectedToken {
                    expected: kind,
                    found: self.peek().kind,
                },
                span: self.current_span(),
            })
        }
    }

    fn consume_content_word(&mut self) -> ParseResult<Symbol> {
        let t = self.advance().clone();
        match t.kind {
            TokenType::Noun(s) | TokenType::Adjective(s) | TokenType::NonIntersectiveAdjective(s) => Ok(s),
            TokenType::ProperName(s) => {
                let s_str = self.interner.resolve(s);
                let gender = Self::infer_gender(s_str);
                let symbol_str = s_str.chars().next().unwrap().to_string();
                let noun_class = s_str.to_string();
                self.register_entity(&symbol_str, &noun_class, gender, Number::Singular);
                Ok(s)
            }
            TokenType::Verb { lemma, .. } => Ok(lemma),
            other => Err(ParseError {
                kind: ParseErrorKind::ExpectedContentWord { found: other },
                span: self.current_span(),
            }),
        }
    }

    fn consume_copula(&mut self) -> ParseResult<()> {
        if self.match_token(&[TokenType::Is, TokenType::Are, TokenType::Was, TokenType::Were]) {
            Ok(())
        } else {
            Err(ParseError {
                kind: ParseErrorKind::ExpectedCopula,
                span: self.current_span(),
            })
        }
    }

    fn check_comparative(&self) -> bool {
        matches!(self.peek().kind, TokenType::Comparative(_))
    }

    fn is_contact_clause_pattern(&self) -> bool {
        // Detect "The cat [the dog chased] ran" pattern
        // After Article, look for: Noun/ProperName + Verb (the embedded subject + verb)
        let mut pos = self.current;

        // Skip the article we're at
        if pos < self.tokens.len() && matches!(self.tokens[pos].kind, TokenType::Article(_)) {
            pos += 1;
        } else {
            return false;
        }

        // Skip adjectives
        while pos < self.tokens.len() && matches!(self.tokens[pos].kind, TokenType::Adjective(_)) {
            pos += 1;
        }

        // Must have noun/proper name (embedded subject)
        if pos < self.tokens.len() && matches!(self.tokens[pos].kind, TokenType::Noun(_) | TokenType::ProperName(_) | TokenType::Adjective(_)) {
            pos += 1;
        } else {
            return false;
        }

        // Must have verb after (embedded verb)
        pos < self.tokens.len() && matches!(self.tokens[pos].kind, TokenType::Verb { .. })
    }

    fn check_superlative(&self) -> bool {
        matches!(self.peek().kind, TokenType::Superlative(_))
    }

    fn check_scopal_adverb(&self) -> bool {
        matches!(self.peek().kind, TokenType::ScopalAdverb(_))
    }

    fn check_temporal_adverb(&self) -> bool {
        matches!(self.peek().kind, TokenType::TemporalAdverb(_))
    }

    fn check_non_intersective_adjective(&self) -> bool {
        matches!(self.peek().kind, TokenType::NonIntersectiveAdjective(_))
    }

    fn check_focus(&self) -> bool {
        matches!(self.peek().kind, TokenType::Focus(_))
    }

    fn check_presup_trigger(&self) -> bool {
        matches!(self.peek().kind, TokenType::PresupTrigger(_))
    }

    fn parse_focus(&mut self) -> ParseResult<&'a Expr<'a>> {
        let kind = if let TokenType::Focus(k) = self.advance().kind {
            k
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedFocusParticle,
                span: self.current_span(),
            });
        };

        // Check if focused element is a quantified expression: "Only every student passed"
        if self.check_quantifier() {
            self.advance();
            let quantified = self.parse_quantified()?;
            let focus_var = self.interner.intern("focus");
            let focused = self.ctx.terms.alloc(Term::Variable(focus_var));
            return Ok(self.ctx.exprs.alloc(Expr::Focus {
                kind,
                focused,
                scope: quantified,
            }));
        }

        // Parse the focused element as a regular noun phrase
        let focused_np = self.parse_noun_phrase(true)?;
        let focused = self.ctx.terms.alloc(Term::Constant(focused_np.noun));

        // Parse the rest of the sentence as scope
        let scope = self.parse_predicate_for_subject(&focused_np)?;

        Ok(self.ctx.exprs.alloc(Expr::Focus {
            kind,
            focused,
            scope,
        }))
    }

    fn check_measure(&self) -> bool {
        matches!(self.peek().kind, TokenType::Measure(_))
    }

    fn parse_measure(&mut self) -> ParseResult<&'a Expr<'a>> {
        let kind = if let TokenType::Measure(k) = self.advance().kind {
            k
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::UnexpectedToken {
                    expected: TokenType::Measure(MeasureKind::Much),
                    found: self.peek().kind.clone(),
                },
                span: self.current_span(),
            });
        };

        // Parse the mass noun: "much water", "little time"
        let np = self.parse_noun_phrase(true)?;
        let var = self.next_var_name();

        // Create noun predicate: Water(x)
        let noun_pred = self.ctx.exprs.alloc(Expr::Predicate {
            name: np.noun,
            args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
        });

        // Create measure predicate: Measure(x, Much) or Measure(x, Little)
        let measure_sym = self.interner.intern("Measure");
        let kind_sym = self.interner.intern(match kind {
            MeasureKind::Much => "Much",
            MeasureKind::Little => "Little",
        });
        let measure_pred = self.ctx.exprs.alloc(Expr::Predicate {
            name: measure_sym,
            args: self.ctx.terms.alloc_slice([Term::Variable(var), Term::Constant(kind_sym)]),
        });

        // Parse the verb phrase
        let (verb, verb_time, _) = self.consume_verb_with_metadata();
        let verb_pred = self.ctx.exprs.alloc(Expr::Predicate {
            name: verb,
            args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
        });

        // Combine: Water(x)  Measure(x, Much)  Flow(x)
        let combined = self.ctx.exprs.alloc(Expr::BinaryOp {
            left: noun_pred,
            op: TokenType::And,
            right: self.ctx.exprs.alloc(Expr::BinaryOp {
                left: measure_pred,
                op: TokenType::And,
                right: verb_pred,
            }),
        });

        // Wrap with temporal if needed
        let with_time = match verb_time {
            Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Past,
                body: combined,
            }),
            Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Future,
                body: combined,
            }),
            _ => combined,
        };

        // Wrap with existential quantifier
        Ok(self.ctx.exprs.alloc(Expr::Quantifier {
            kind: QuantifierKind::Existential,
            variable: var,
            body: with_time,
            island_id: self.current_island,
        }))
    }

    fn parse_presupposition(&mut self, subject: &NounPhrase<'a>, presup_kind: PresupKind) -> ParseResult<&'a Expr<'a>> {
        let subject_noun = subject.noun;

        // Parse the complement (gerund like "smoking", "running")
        let unknown = self.interner.intern("?");
        let complement = if self.check_verb() {
            let verb = self.consume_verb();
            self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject_noun)]),
            })
        } else {
            self.ctx.exprs.alloc(Expr::Atom(unknown))
        };

        // Build presupposition based on trigger type
        let (assertion, presupposition) = match presup_kind {
            PresupKind::Stop => {
                // "stopped smoking"  Assert: Smoke(J), Presup: P(Smoke(J))
                let neg = self.ctx.exprs.alloc(Expr::UnaryOp {
                    op: TokenType::Not,
                    operand: complement,
                });
                let past = self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: complement,
                });
                (neg, past)
            }
            PresupKind::Start => {
                // "started running"  Assert: Run(J), Presup: P(Run(J))
                let past = self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: complement,
                });
                let neg_past = self.ctx.exprs.alloc(Expr::UnaryOp {
                    op: TokenType::Not,
                    operand: past,
                });
                (complement, neg_past)
            }
            PresupKind::Regret => {
                // "regrets leaving"  Assert: Regret(J, Leave), Presup: P(Leave(J))
                let regret_sym = self.interner.intern("Regret");
                let regret = self.ctx.exprs.alloc(Expr::Predicate {
                    name: regret_sym,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_noun)]),
                });
                let past = self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: complement,
                });
                (regret, past)
            }
            PresupKind::Continue | PresupKind::Realize | PresupKind::Know => {
                // Factive presuppositions
                let verb_name = match presup_kind {
                    PresupKind::Continue => self.interner.intern("Continue"),
                    PresupKind::Realize => self.interner.intern("Realize"),
                    PresupKind::Know => self.interner.intern("Know"),
                    _ => unknown,
                };
                let main = self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb_name,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_noun)]),
                });
                (main, complement)
            }
        };

        Ok(self.ctx.exprs.alloc(Expr::Presupposition {
            assertion,
            presupposition,
        }))
    }

    fn parse_predicate_for_subject(&mut self, subject: &NounPhrase<'a>) -> ParseResult<&'a Expr<'a>> {
        if self.check_verb() {
            let verb = self.consume_verb();
            let mut args = vec![Term::Constant(subject.noun)];

            // Check for object
            if self.check_content_word() || self.check_article() {
                let object = self.parse_noun_phrase(false)?;
                args.push(Term::Constant(object.noun));
            }

            Ok(self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice(args),
            }))
        } else {
            Ok(self.ctx.exprs.alloc(Expr::Atom(subject.noun)))
        }
    }

    fn parse_scopal_adverb(&mut self, subject: &NounPhrase<'a>) -> ParseResult<&'a Expr<'a>> {
        let operator = if let TokenType::ScopalAdverb(adv) = self.advance().kind.clone() {
            adv
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedScopalAdverb,
                span: self.current_span(),
            });
        };

        // Parse the verb phrase
        if !self.check_verb() {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedVerb { found: self.peek().kind.clone() },
                span: self.current_span(),
            });
        }

        let (verb, verb_time, _verb_aspect) = self.consume_verb_with_metadata();

        let predicate = self.ctx.exprs.alloc(Expr::Predicate {
            name: verb,
            args: self.ctx.terms.alloc_slice([Term::Constant(subject.noun)]),
        });

        // Apply temporal wrapping first
        let with_time = match verb_time {
            Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Past,
                body: predicate,
            }),
            Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Future,
                body: predicate,
            }),
            _ => predicate,
        };

        // Wrap in scopal operator
        Ok(self.ctx.exprs.alloc(Expr::Scopal {
            operator,
            body: with_time,
        }))
    }

    fn try_parse_plural_subject(&mut self, first_subject: &NounPhrase<'a>) -> Option<&'a Expr<'a>> {
        let saved_pos = self.current;

        // Consume "and"
        self.advance();

        // Check if followed by a proper name or noun (second subject)
        if !self.check_content_word() {
            self.current = saved_pos;
            return None;
        }

        let second_subject = self.parse_noun_phrase(true).ok()?;

        // Check if followed by a verb
        if !self.check_verb() {
            self.current = saved_pos;
            return None;
        }

        // We have "A and B verb" pattern
        let (verb, verb_time, _verb_aspect) = self.consume_verb_with_metadata();

        // Check for reciprocal: "John and Mary love each other"
        if self.check(&TokenType::Reciprocal) {
            self.advance();
            // Expand to bidirectional: Love(J, M)  Love(M, J)
            let pred1 = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([
                    Term::Constant(first_subject.noun),
                    Term::Constant(second_subject.noun),
                ]),
            });
            let pred2 = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([
                    Term::Constant(second_subject.noun),
                    Term::Constant(first_subject.noun),
                ]),
            });
            let expr = self.ctx.exprs.alloc(Expr::BinaryOp {
                left: pred1,
                op: TokenType::And,
                right: pred2,
            });

            let with_time = match verb_time {
                Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: expr,
                }),
                Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Future,
                    body: expr,
                }),
                _ => expr,
            };
            return Some(with_time);
        }

        // Register the coordinated subjects as a plural entity for pronoun resolution
        let first_sym = self.interner.resolve(first_subject.noun);
        let second_sym = self.interner.resolve(second_subject.noun);
        let group_name = format!("{}{}", first_sym, second_sym);
        self.register_entity(&group_name, "group", Gender::Unknown, Number::Plural);

        let is_collective = Lexer::is_collective_verb(self.interner.resolve(verb));

        let expr = if is_collective {
            // Collective: Meet(J  M)
            let group_members = self.ctx.terms.alloc_slice([
                Term::Constant(first_subject.noun),
                Term::Constant(second_subject.noun),
            ]);
            self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Group(group_members)]),
            })
        } else {
            // Distributive: Run(J)  Run(M)
            let pred1 = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(first_subject.noun)]),
            });
            let pred2 = self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(second_subject.noun)]),
            });
            self.ctx.exprs.alloc(Expr::BinaryOp {
                left: pred1,
                op: TokenType::And,
                right: pred2,
            })
        };

        // Apply temporal wrapping
        let with_time = match verb_time {
            Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Past,
                body: expr,
            }),
            Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Future,
                body: expr,
            }),
            _ => expr,
        };

        Some(with_time)
    }

    fn parse_superlative(&mut self, subject: &NounPhrase<'a>) -> ParseResult<&'a Expr<'a>> {
        let adj = if let TokenType::Superlative(adj) = self.advance().kind.clone() {
            adj
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedSuperlativeAdjective,
                span: self.current_span(),
            });
        };

        // Parse the domain noun
        let domain = self.consume_content_word()?;

        Ok(self.ctx.exprs.alloc(Expr::Superlative {
            adjective: adj,
            subject: self.ctx.terms.alloc(Term::Constant(subject.noun)),
            domain,
        }))
    }

    fn parse_control_structure(&mut self, subject: &NounPhrase<'a>, verb: Symbol, verb_time: Time) -> ParseResult<&'a Expr<'a>> {
        let subject_sym = subject.noun;
        let verb_str = self.interner.resolve(verb);

        // Check for RAISING verbs first: "John seems to sleep"  Seem(Sleep(J))
        // Raising: subject is NOT an argument of the main verb
        if Lexer::is_raising_verb(verb_str) {
            // Consume "to"
            if !self.check_to() {
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_sym)]),
                }));
            }
            self.advance(); // consume "to"

            // Parse the infinitive verb
            if !self.check_verb() {
                return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                    name: verb,
                    args: self.ctx.terms.alloc_slice([Term::Constant(subject_sym)]),
                }));
            }

            let inf_verb = self.consume_verb();

            // Build the embedded proposition with subject
            let embedded = self.ctx.exprs.alloc(Expr::Predicate {
                name: inf_verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject_sym)]),
            });

            // Raising: wrap the proposition - Seem(Sleep(J))
            // Subject is NOT an argument of the raising verb
            let result = self.ctx.exprs.alloc(Expr::Scopal {
                operator: verb,
                body: embedded,
            });

            return Ok(match verb_time {
                Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Past,
                    body: result,
                }),
                Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                    operator: TemporalOperator::Future,
                    body: result,
                }),
                _ => result,
            });
        }

        // CONTROL verbs: "John wants to run"  Want(J, Run(J))
        // Check if this is object control (verb + object + to + infinitive)
        // or subject control (verb + to + infinitive)
        let is_object_control = Lexer::is_object_control_verb(self.interner.resolve(verb));
        let (object_term, pro_controller_sym) = if self.check_to() {
            // Subject control: "John wants to run"
            (None, subject_sym)
        } else if self.check_content_word() {
            // Might be object control: "John persuaded Mary to leave"
            let object_np = self.parse_noun_phrase(false)?;
            let obj_sym = object_np.noun;

            // Determine PRO binding based on verb type
            // Promise is SUBJECT control even with object
            let controller = if is_object_control {
                obj_sym
            } else {
                subject_sym
            };
            (Some(self.ctx.terms.alloc(Term::Constant(obj_sym))), controller)
        } else {
            // Fallback to subject control
            (None, subject_sym)
        };

        // Consume "to"
        if !self.check_to() {
            // Not a control structure after all, fall back
            return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: match object_term {
                    Some(obj) => self.ctx.terms.alloc_slice([Term::Constant(subject_sym), Term::Constant(match obj { Term::Constant(s) => *s, _ => subject_sym })]),
                    None => self.ctx.terms.alloc_slice([Term::Constant(subject_sym)]),
                },
            }));
        }
        self.advance(); // consume "to"

        // Parse the infinitive verb
        if !self.check_verb() {
            return Ok(self.ctx.exprs.alloc(Expr::Predicate {
                name: verb,
                args: self.ctx.terms.alloc_slice([Term::Constant(subject_sym)]),
            }));
        }

        let inf_verb = self.consume_verb();

        // Build the infinitive predicate with PRO bound to controller
        let infinitive = self.ctx.exprs.alloc(Expr::Predicate {
            name: inf_verb,
            args: self.ctx.terms.alloc_slice([Term::Constant(pro_controller_sym)]),
        });

        // Build the Control expression
        let control = self.ctx.exprs.alloc(Expr::Control {
            verb,
            subject: self.ctx.terms.alloc(Term::Constant(subject_sym)),
            object: object_term,
            infinitive,
        });

        // Apply temporal wrapping if needed
        Ok(match verb_time {
            Time::Past => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Past,
                body: control,
            }),
            Time::Future => self.ctx.exprs.alloc(Expr::Temporal {
                operator: TemporalOperator::Future,
                body: control,
            }),
            _ => control,
        })
    }

    fn parse_comparative(&mut self, subject: &NounPhrase<'a>, _copula_time: Time) -> ParseResult<&'a Expr<'a>> {
        let adj = if let TokenType::Comparative(adj) = self.advance().kind.clone() {
            adj
        } else {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedComparativeAdjective,
                span: self.current_span(),
            });
        };

        // Consume "than"
        if !self.check(&TokenType::Than) {
            return Err(ParseError {
                kind: ParseErrorKind::ExpectedThan,
                span: self.current_span(),
            });
        }
        self.advance();

        // Parse the object of comparison
        let object = self.parse_noun_phrase(false)?;

        let result = self.ctx.exprs.alloc(Expr::Comparative {
            adjective: adj,
            subject: self.ctx.terms.alloc(Term::Constant(subject.noun)),
            object: self.ctx.terms.alloc(Term::Constant(object.noun)),
        });

        // Apply Russell expansion if subject was definite
        let result = self.wrap_with_definiteness(subject.definiteness, subject.noun, result)?;

        // Apply Russell expansion if object was definite
        self.wrap_with_definiteness_for_object(object.definiteness, object.noun, result)
    }

    fn wrap_with_definiteness_for_object(
        &mut self,
        definiteness: Option<Definiteness>,
        noun: Symbol,
        predicate: &'a Expr<'a>,
    ) -> ParseResult<&'a Expr<'a>> {
        match definiteness {
            Some(Definiteness::Indefinite) => {
                let var = self.next_var_name();
                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });
                let substituted = self.substitute_constant_with_var(predicate, noun, var)?;
                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: substituted,
                });
                Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body,
                    island_id: self.current_island,
                }))
            }
            Some(Definiteness::Definite) => {
                let x = self.next_var_name();
                let y = self.next_var_name();

                let type_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(x)]),
                });

                let identity = self.ctx.exprs.alloc(Expr::Identity {
                    left: self.ctx.terms.alloc(Term::Variable(y)),
                    right: self.ctx.terms.alloc(Term::Variable(x)),
                });
                let inner_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(y)]),
                });
                let uniqueness_body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: inner_pred,
                    op: TokenType::If,
                    right: identity,
                });
                let uniqueness = self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Universal,
                    variable: y,
                    body: uniqueness_body,
                    island_id: self.current_island,
                });

                let main_pred = self.substitute_constant_with_var(predicate, noun, x)?;

                let type_and_unique = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_pred,
                    op: TokenType::And,
                    right: uniqueness,
                });
                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: type_and_unique,
                    op: TokenType::And,
                    right: main_pred,
                });

                Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: x,
                    body,
                    island_id: self.current_island,
                }))
            }
            Some(Definiteness::Proximal) | Some(Definiteness::Distal) => {
                let var = self.next_var_name();

                // Build type predicate from noun
                let mut restriction = self.ctx.exprs.alloc(Expr::Predicate {
                    name: noun,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });

                // Add deictic predicate (Proximal or Distal)
                let deictic_name = if matches!(definiteness, Some(Definiteness::Proximal)) {
                    self.interner.intern("Proximal")
                } else {
                    self.interner.intern("Distal")
                };
                let deictic_pred = self.ctx.exprs.alloc(Expr::Predicate {
                    name: deictic_name,
                    args: self.ctx.terms.alloc_slice([Term::Variable(var)]),
                });
                restriction = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: restriction,
                    op: TokenType::And,
                    right: deictic_pred,
                });

                let substituted = self.substitute_constant_with_var(predicate, noun, var)?;
                let body = self.ctx.exprs.alloc(Expr::BinaryOp {
                    left: restriction,
                    op: TokenType::And,
                    right: substituted,
                });
                Ok(self.ctx.exprs.alloc(Expr::Quantifier {
                    kind: QuantifierKind::Existential,
                    variable: var,
                    body,
                    island_id: self.current_island,
                }))
            }
            None => Ok(predicate),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::arena::Arena;

    #[test]
    fn guard_restores_all_fields_on_drop() {
        let mut interner = Interner::new();
        let expr_arena: Arena<Expr> = Arena::new();
        let term_arena: Arena<Term> = Arena::new();
        let np_arena: Arena<NounPhrase> = Arena::new();
        let sym_arena: Arena<Symbol> = Arena::new();
        let role_arena: Arena<(ThematicRole, Term)> = Arena::new();
        let pp_arena: Arena<&Expr> = Arena::new();

        let ctx = AstContext::new(
            &expr_arena, &term_arena, &np_arena, &sym_arena, &role_arena, &pp_arena,
        );

        let mut lexer = Lexer::new("a b c d e", &mut interner);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens, &mut interner, ctx);

        // Record initial state
        let initial_pos = parser.current;
        let initial_var_counter = parser.var_counter;
        let initial_bindings_len = parser.donkey_bindings.len();
        let initial_island = parser.current_island;
        let initial_time = parser.pending_time;

        // Use guard, mutate ALL 5 fields, then let it drop without commit
        {
            let mut guard = parser.guard();
            guard.current = 3;
            guard.var_counter = 99;
            guard.donkey_bindings.push((Symbol::EMPTY, Symbol::EMPTY, false));
            guard.current_island = 42;
            guard.pending_time = Some(Time::Past);
            // guard drops here without commit
        }

        // ALL fields should be restored
        assert_eq!(parser.current, initial_pos, "position not restored");
        assert_eq!(parser.var_counter, initial_var_counter, "var_counter not restored");
        assert_eq!(parser.donkey_bindings.len(), initial_bindings_len, "bindings not restored");
        assert_eq!(parser.current_island, initial_island, "island not restored");
        assert_eq!(parser.pending_time, initial_time, "time not restored");
    }

    #[test]
    fn guard_preserves_state_on_commit() {
        let mut interner = Interner::new();
        let expr_arena: Arena<Expr> = Arena::new();
        let term_arena: Arena<Term> = Arena::new();
        let np_arena: Arena<NounPhrase> = Arena::new();
        let sym_arena: Arena<Symbol> = Arena::new();
        let role_arena: Arena<(ThematicRole, Term)> = Arena::new();
        let pp_arena: Arena<&Expr> = Arena::new();

        let ctx = AstContext::new(
            &expr_arena, &term_arena, &np_arena, &sym_arena, &role_arena, &pp_arena,
        );

        let mut lexer = Lexer::new("a b c", &mut interner);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens, &mut interner, ctx);

        // Use guard, mutate, and COMMIT
        {
            let mut guard = parser.guard();
            guard.current = 2;
            guard.var_counter = 50;
            guard.commit();
        }

        // State should be PRESERVED (not restored)
        assert_eq!(parser.current, 2, "position should be preserved after commit");
        assert_eq!(parser.var_counter, 50, "var_counter should be preserved after commit");
    }

    #[test]
    fn check_any_matches_wh_words() {
        let mut interner = Interner::new();
        let expr_arena: Arena<Expr> = Arena::new();
        let term_arena: Arena<Term> = Arena::new();
        let np_arena: Arena<NounPhrase> = Arena::new();
        let sym_arena: Arena<Symbol> = Arena::new();
        let role_arena: Arena<(ThematicRole, Term)> = Arena::new();
        let pp_arena: Arena<&Expr> = Arena::new();

        let ctx = AstContext::new(
            &expr_arena, &term_arena, &np_arena, &sym_arena, &role_arena, &pp_arena,
        );

        let mut lexer = Lexer::new("who what where", &mut interner);
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens, &mut interner, ctx);

        assert!(parser.check_any(TokenType::WH_WORDS));
        parser.current = 1;
        assert!(parser.check_any(TokenType::WH_WORDS));
        parser.current = 2;
        assert!(parser.check_any(TokenType::WH_WORDS));
    }

    #[test]
    fn check_any_rejects_non_matching() {
        let mut interner = Interner::new();
        let expr_arena: Arena<Expr> = Arena::new();
        let term_arena: Arena<Term> = Arena::new();
        let np_arena: Arena<NounPhrase> = Arena::new();
        let sym_arena: Arena<Symbol> = Arena::new();
        let role_arena: Arena<(ThematicRole, Term)> = Arena::new();
        let pp_arena: Arena<&Expr> = Arena::new();

        let ctx = AstContext::new(
            &expr_arena, &term_arena, &np_arena, &sym_arena, &role_arena, &pp_arena,
        );

        let mut lexer = Lexer::new("if then", &mut interner);
        let tokens = lexer.tokenize();
        let parser = Parser::new(tokens, &mut interner, ctx);

        assert!(!parser.check_any(TokenType::WH_WORDS));
        assert!(!parser.check_any(TokenType::MODALS));
    }
}

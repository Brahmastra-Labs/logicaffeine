## To native args () -> Seq of Text
## To native parseInt (s: Text) -> Int

## To siftDown (arr: Seq of Int, start: Int, end: Int) -> Seq of Int:
    Let mutable result be arr.
    Let mutable root be start.
    While 2 * root + 1 is at most end:
        Let child be 2 * root + 1.
        Let mutable swapIdx be root.
        If item (swapIdx + 1) of result is less than item (child + 1) of result:
            Set swapIdx to child.
        If child + 1 is at most end:
            If item (swapIdx + 1) of result is less than item (child + 2) of result:
                Set swapIdx to child + 1.
        If swapIdx equals root:
            Return result.
        Let tmp be item (root + 1) of result.
        Set item (root + 1) of result to item (swapIdx + 1) of result.
        Set item (swapIdx + 1) of result to tmp.
        Set root to swapIdx.
    Return result.

## Main
Let arguments be args().
Let n be parseInt(item 2 of arguments).
Let mutable arr be a new Seq of Int.
Let mutable seed be 42.
Let mutable i be 0.
While i is less than n:
    Set seed to (seed * 1103515245 + 12345) % 2147483648.
    Push (seed / 65536) % 32768 to arr.
    Set i to i + 1.
Let mutable start be (n - 2) / 2.
While start is at least 0:
    Set arr to siftDown(arr, start, n - 1).
    Set start to start - 1.
Let mutable end be n - 1.
While end is greater than 0:
    Let tmp be item 1 of arr.
    Set item 1 of arr to item (end + 1) of arr.
    Set item (end + 1) of arr to tmp.
    Set end to end - 1.
    Set arr to siftDown(arr, 0, end).
Let mutable checksum be 0.
Set i to 1.
While i is at most n:
    Set checksum to (checksum + item i of arr) % 1000000007.
    Set i to i + 1.
Show "" + item 1 of arr + " " + item n of arr + " " + checksum.

{
  "schema_version": 1,
  "metadata": {
    "date": "2026-02-28T06:23:05Z",
    "commit": "9502dbb",
    "logos_version": "0.9.0",
    "cpu": "Apple M1 Max",
    "os": "macOS 15.2 arm64",
    "warmup": 3,
    "runs": 10,
    "versions": {
      "c": "Apple clang version 16.0.0 (clang-1600.0.26.6)",
      "cpp": "Apple clang version 16.0.0 (clang-1600.0.26.6)",
      "rust": "rustc 1.88.0 (6b00bc388 2025-06-23)",
      "zig": "0.15.2",
      "go": "go version go1.21.4 darwin/arm64",
      "java": "openjdk 21.0.8 2025-07-15",
      "node": "v22.8.0",
      "python": "Python 3.10.12",
      "ruby": "ruby 2.6.10p210 (2022-04-12 revision 67958) [universal.arm64e-darwin24]",
      "nim": "Nim Compiler Version 2.2.6 [MacOSX: arm64]"
    }
  },
  "languages": [
    {
      "id": "c",
      "label": "C",
      "color": "#555555",
      "tier": "systems"
    },
    {
      "id": "cpp",
      "label": "C++",
      "color": "#f34b7d",
      "tier": "systems"
    },
    {
      "id": "rust",
      "label": "Rust",
      "color": "#dea584",
      "tier": "systems"
    },
    {
      "id": "zig",
      "label": "Zig",
      "color": "#f7a41d",
      "tier": "systems"
    },
    {
      "id": "logos_release",
      "label": "LOGOS",
      "color": "#00d4ff",
      "tier": "systems"
    },
    {
      "id": "go",
      "label": "Go",
      "color": "#00ADD8",
      "tier": "managed"
    },
    {
      "id": "java",
      "label": "Java",
      "color": "#b07219",
      "tier": "managed"
    },
    {
      "id": "js",
      "label": "JavaScript",
      "color": "#f7df1e",
      "tier": "managed"
    },
    {
      "id": "python",
      "label": "Python",
      "color": "#3776ab",
      "tier": "interpreted"
    },
    {
      "id": "ruby",
      "label": "Ruby",
      "color": "#cc342d",
      "tier": "interpreted"
    },
    {
      "id": "nim",
      "label": "Nim",
      "color": "#ffe953",
      "tier": "transpiled"
    }
  ],
  "benchmarks": [
    {
      "id": "fib",
      "name": "Recursive Fibonacci",
      "description": "Naive recursive fibonacci. Measures function call overhead and recursion depth.",
      "reference_size": "25",
      "sizes": [
        "10",
        "15",
        "20",
        "25",
        "30",
        "35",
        "40"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To fib (n: Int) -> Int:\n    If n is less than 2:\n        Return n.\n    Return fib(n - 1) + fib(n - 2).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow fib(n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn fib(n: i64) -> i64 {\n    use std::cell::RefCell;\n    thread_local! {\n        static __MEMO_FIB: RefCell<FxHashMap<i64, i64>> = RefCell::new(FxHashMap::default());\n    }\n    if let Some(__v) = __MEMO_FIB.with(|c| c.borrow().get(&n).copied()) {\n        return __v;\n    }\n    let __memo_result = (|| -> i64 {\n        if (n < 2) {\n            return n;\n        }\n        return (fib((n - 1)) + fib((n - 2)));\n    })();\n    __MEMO_FIB.with(|c| c.borrow_mut().insert(n, __memo_result));\n    __memo_result\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&fib(n));\n}",
      "scaling": {
        "25": {
          "c": {
            "mean_ms": 0.40326337199999884000,
            "median_ms": 0.44151683999999825000,
            "stddev_ms": 0.337471433442381000,
            "min_ms": 0,
            "max_ms": 1.0568503399999984000,
            "cv": 0.83685119173774594819,
            "runs": 10,
            "user_ms": 0.6342200000000003000,
            "system_ms": 0.37934000000000004000
          },
          "cpp": {
            "mean_ms": 0.37781910599999876000,
            "median_ms": 0.3434543399999986000,
            "stddev_ms": 0.2898815444492394000,
            "min_ms": 0,
            "max_ms": 0.781099339999999000,
            "cv": 0.76724956426433434890,
            "runs": 10,
            "user_ms": 0.6253200000000002000,
            "system_ms": 0.37894000000000014000
          },
          "rust": {
            "mean_ms": 0.6499401059999988000,
            "median_ms": 0.7603293399999988000,
            "stddev_ms": 0.4006050300528449000,
            "min_ms": 0,
            "max_ms": 1.2333923399999985000,
            "cv": 0.61637222623225168327,
            "runs": 10,
            "user_ms": 0.8707200000000004000,
            "system_ms": 0.39694000000000003000
          },
          "zig": {
            "mean_ms": 0.45424173999999854000,
            "median_ms": 0.43078683999999865000,
            "stddev_ms": 0.2310312576274763000,
            "min_ms": 0.2093493399999988000,
            "max_ms": 0.8103503399999983000,
            "cv": 0.50860860480914202769,
            "runs": 10,
            "user_ms": 0.6809200000000003000,
            "system_ms": 0.35844000000000007000
          },
          "go": {
            "mean_ms": 1.1940583399999987000,
            "median_ms": 1.1590583399999988000,
            "stddev_ms": 0.3219799435900041000,
            "min_ms": 0.6781413399999988000,
            "max_ms": 1.7222253399999986000,
            "cv": 0.26965176893283493212,
            "runs": 10,
            "user_ms": 1.11172000,
            "system_ms": 0.70664000
          },
          "java": {
            "mean_ms": 50.538512439999995000,
            "median_ms": 48.611787340000004000,
            "stddev_ms": 6.259277788930135000,
            "min_ms": 46.97260034000,
            "max_ms": 68.10372434000,
            "cv": 0.12385164277166317836,
            "runs": 10,
            "user_ms": 20.49352000,
            "system_ms": 27.231839999999997000
          },
          "js": {
            "mean_ms": 45.75980834000,
            "median_ms": 45.51964134000,
            "stddev_ms": 1.2929302987930596000,
            "min_ms": 43.74135034000,
            "max_ms": 48.03505834000,
            "cv": 0.02825471403172095541,
            "runs": 10,
            "user_ms": 36.15612000,
            "system_ms": 5.380040000000001000
          },
          "python": {
            "mean_ms": 188.03847534000,
            "median_ms": 172.51580884000,
            "stddev_ms": 26.551593323099917000,
            "min_ms": 161.19493334000,
            "max_ms": 225.30226734000,
            "cv": 0.14120298133183064448,
            "runs": 10,
            "user_ms": 37.95522000,
            "system_ms": 12.546839999999998000
          },
          "ruby": {
            "mean_ms": 68.60872914000002000,
            "median_ms": 67.02141234000,
            "stddev_ms": 6.432732356598379000,
            "min_ms": 64.12168334000001000,
            "max_ms": 86.55280834000001000,
            "cv": 0.09375967806475502841,
            "runs": 10,
            "user_ms": 45.625419999999986000,
            "system_ms": 16.45154000
          },
          "nim": {
            "mean_ms": 1.2364585399999985000,
            "median_ms": 1.3026213399999985000,
            "stddev_ms": 0.27966973794531295000,
            "min_ms": 0.7560993399999983000,
            "max_ms": 1.6494753399999987000,
            "cv": 0.22618610240284586434,
            "runs": 10,
            "user_ms": 1.0114200000000003000,
            "system_ms": 0.6655400000000001000
          },
          "logos_release": {
            "mean_ms": 4.006571139999999000,
            "median_ms": 1.9237673399999985000,
            "stddev_ms": 6.200086783452664000,
            "min_ms": 1.685225339999999000,
            "max_ms": 21.60622534000,
            "cv": 1.54747951972036257104,
            "runs": 10,
            "user_ms": 1.6364200000000002000,
            "system_ms": 1.03954000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "ackermann",
      "name": "Ackermann Function",
      "description": "Ackermann(3, m). Measures extreme recursion depth and stack frame overhead.",
      "reference_size": "8",
      "sizes": [
        "3",
        "4",
        "6",
        "8",
        "10",
        "11",
        "12"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To ackermann (m: Int) and (n: Int) -> Int:\n    If m equals 0:\n        Return n + 1.\n    If n equals 0:\n        Return ackermann(m - 1, 1).\n    Return ackermann(m - 1, ackermann(m, n - 1)).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow ackermann(3, n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn ackermann(mut m: i64, mut n: i64) -> i64 {\n    loop {\n        if (m == 0) {\n            return (n + 1);\n        }\n        if (n == 0) {\n            {\n                let __tce_0 = (m - 1);\n                let __tce_1 = 1;\n                m = __tce_0;\n                n = __tce_1;\n                continue;\n            }\n        }\n        {\n            let __tce_0 = (m - 1);\n            let __tce_1 = ackermann(m, (n - 1));\n            m = __tce_0;\n            n = __tce_1;\n            continue;\n        }\n    }\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&ackermann(3, n));\n}",
      "scaling": {
        "8": {
          "c": {
            "mean_ms": 9.70770598000,
            "median_ms": 9.67423528000,
            "stddev_ms": 0.36233265856731124000,
            "min_ms": 9.17594328000,
            "max_ms": 10.19777728000,
            "cv": 0.03732423080321920091,
            "runs": 10,
            "user_ms": 8.744120000000001000,
            "system_ms": 0.50932000
          },
          "cpp": {
            "mean_ms": 10.69004748000,
            "median_ms": 10.41140178000,
            "stddev_ms": 0.5661610384094305000,
            "min_ms": 9.99681828000,
            "max_ms": 11.71319328000,
            "cv": 0.05296150830654968241,
            "runs": 10,
            "user_ms": 9.033620000000001000,
            "system_ms": 0.8173199999999999000
          },
          "rust": {
            "mean_ms": 13.291360180000003000,
            "median_ms": 10.73373528000,
            "stddev_ms": 8.233882951333437000,
            "min_ms": 10.276277280000001000,
            "max_ms": 36.69556828000,
            "cv": 0.61949137182538041351,
            "runs": 10,
            "user_ms": 9.39272000,
            "system_ms": 0.8254199999999998000
          },
          "zig": {
            "mean_ms": 10.333834879999998000,
            "median_ms": 10.46154728000,
            "stddev_ms": 0.4776252471374974000,
            "min_ms": 9.52931828000,
            "max_ms": 11.17719328000,
            "cv": 0.04621955476198759355,
            "runs": 10,
            "user_ms": 9.14212000,
            "system_ms": 0.6709199999999999000
          },
          "go": {
            "mean_ms": 12.973576479999999000,
            "median_ms": 12.975921780000002000,
            "stddev_ms": 0.5125320594184653000,
            "min_ms": 12.12406828000,
            "max_ms": 13.789818280000001000,
            "cv": 0.03950584175524630194,
            "runs": 10,
            "user_ms": 10.82912000,
            "system_ms": 1.53372000
          },
          "java": {
            "mean_ms": 61.706543280000005000,
            "median_ms": 57.75058928000,
            "stddev_ms": 13.577419451924363000,
            "min_ms": 54.972443280000005000,
            "max_ms": 99.85415128000001000,
            "cv": 0.22003208622974354203,
            "runs": 10,
            "user_ms": 26.98532000,
            "system_ms": 28.467719999999995000
          },
          "js": {
            "mean_ms": 70.51787238000,
            "median_ms": 64.96390128000001000,
            "stddev_ms": 14.27763171936003000,
            "min_ms": 62.23286028000001000,
            "max_ms": 107.48648428000,
            "cv": 0.20246827134009498883,
            "runs": 10,
            "user_ms": 53.06312000,
            "system_ms": 5.702219999999999000
          },
          "python": {
            "mean_ms": 407.7020891800001000,
            "median_ms": 394.19888078000004000,
            "stddev_ms": 28.6691004271076000,
            "min_ms": 381.89719328000005000,
            "max_ms": 468.87777728000,
            "cv": 0.07031874789940116874,
            "runs": 10,
            "user_ms": 261.50022000,
            "system_ms": 13.69802000
          },
          "ruby": {
            "mean_ms": 177.31067248000001000,
            "median_ms": 170.55558878000004000,
            "stddev_ms": 20.58223354387838000,
            "min_ms": 162.96831828000002000,
            "max_ms": 230.77611028000003000,
            "cv": 0.11608006024679636835,
            "runs": 10,
            "user_ms": 144.30511999999998000,
            "system_ms": 18.93752000
          },
          "nim": {
            "mean_ms": 11.82979768000,
            "median_ms": 11.75671378000,
            "stddev_ms": 0.2415290914206587000,
            "min_ms": 11.48752728000,
            "max_ms": 12.17827728000,
            "cv": 0.02041700948351795480,
            "runs": 10,
            "user_ms": 10.60942000,
            "system_ms": 0.66762000
          },
          "logos_release": {
            "mean_ms": 11.64134718000,
            "median_ms": 11.614901280000001000,
            "stddev_ms": 0.3663672919120767000,
            "min_ms": 10.91523428000,
            "max_ms": 12.06715128000,
            "cv": 0.03147121086994990729,
            "runs": 10,
            "user_ms": 10.078420000000001000,
            "system_ms": 0.9063199999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "nqueens",
      "name": "N-Queens",
      "description": "N-Queens backtracking. Measures recursive constraint solving.",
      "reference_size": "10",
      "sizes": [
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To solve (row: Int, cols: Int, diag1: Int, diag2: Int, n: Int) -> Int:\n    If row equals n:\n        Return 1.\n    Let all be (1 shifted left by n) - 1.\n    Let mutable available be all and not (cols or diag1 or diag2).\n    Let mutable count be 0.\n    While available is not 0:\n        Let bit be available and (0 - available).\n        Set available to available xor bit.\n        Set count to count + solve(row + 1, cols or bit, (diag1 or bit) shifted left by 1, (diag2 or bit) shifted right by 1, n).\n    Return count.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow solve(0, 0, 0, 0, n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn solve(row: i64, cols: i64, diag1: i64, diag2: i64, n: i64) -> i64 {\n    if (row == n) {\n        return 1;\n    }\n    let all = ((1 << n) - 1);\n    let mut available = (all & !(((cols | diag1) | diag2)));\n    let mut count = 0;\n    while (available != 0) {\n        let bit = (available & (0 - available));\n        available = (available ^ bit);\n        count = (count + solve((row + 1), (cols | bit), ((diag1 | bit) << 1), ((diag2 | bit) >> 1), n));\n    }\n    return count;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&solve(0, 0, 0, 0, n));\n}",
      "scaling": {
        "10": {
          "c": {
            "mean_ms": 2.5025439800000007000,
            "median_ms": 2.4320104800000008000,
            "stddev_ms": 0.6143406884840944000,
            "min_ms": 1.7989899800000008000,
            "max_ms": 3.8031149800000007000,
            "cv": 0.24548647032532640172,
            "runs": 10,
            "user_ms": 0.7924399999999999000,
            "system_ms": 0.8776800000000001000
          },
          "cpp": {
            "mean_ms": 1.96889838000,
            "median_ms": 1.7942189800000006000,
            "stddev_ms": 0.4787325825682737000,
            "min_ms": 1.5431149800000008000,
            "max_ms": 3.0564899800000008000,
            "cv": 0.24314743078221929361,
            "runs": 10,
            "user_ms": 0.7808399999999999000,
            "system_ms": 0.7383800000000001000
          },
          "rust": {
            "mean_ms": 1.7433564800000006000,
            "median_ms": 1.6805104800000008000,
            "stddev_ms": 0.25710091280327607000,
            "min_ms": 1.3747399800000007000,
            "max_ms": 2.1909479800000004000,
            "cv": 0.14747466496540970296,
            "runs": 10,
            "user_ms": 0.9455399999999999000,
            "system_ms": 0.4935800000000001000
          },
          "zig": {
            "mean_ms": 2.333339780000001000,
            "median_ms": 2.261927480000001000,
            "stddev_ms": 0.7220864461205922000,
            "min_ms": 1.2884899800000003000,
            "max_ms": 3.309989980000001000,
            "cv": 0.30946476475903217598,
            "runs": 10,
            "user_ms": 0.8627400000000001000,
            "system_ms": 0.80338000
          },
          "go": {
            "mean_ms": 7.08446488000,
            "median_ms": 2.3544689800000006000,
            "stddev_ms": 14.820946679519328000,
            "min_ms": 1.9840729800000008000,
            "max_ms": 49.249239980000005000,
            "cv": 2.09203474511674451267,
            "runs": 10,
            "user_ms": 1.2361399999999997000,
            "system_ms": 0.98788000
          },
          "java": {
            "mean_ms": 60.336364980000015000,
            "median_ms": 62.91428148000,
            "stddev_ms": 7.303992981664894000,
            "min_ms": 46.25365698000,
            "max_ms": 68.31965698000,
            "cv": 0.12105457436963568606,
            "runs": 10,
            "user_ms": 21.137839999999998000,
            "system_ms": 27.489880000000005000
          },
          "js": {
            "mean_ms": 46.71177318000,
            "median_ms": 46.26030248000,
            "stddev_ms": 1.3989747240470084000,
            "min_ms": 45.14190598000,
            "max_ms": 49.260447980000004000,
            "cv": 0.02994908197246492110,
            "runs": 10,
            "user_ms": 36.45294000,
            "system_ms": 5.24288000
          },
          "python": {
            "mean_ms": 210.97829818000005000,
            "median_ms": 206.24313548000003000,
            "stddev_ms": 38.0842250283409000,
            "min_ms": 169.96140598000004000,
            "max_ms": 270.08273998000,
            "cv": 0.18051252359542988031,
            "runs": 10,
            "user_ms": 37.83093999999999000,
            "system_ms": 15.116380000000002000
          },
          "ruby": {
            "mean_ms": 91.61370258000001000,
            "median_ms": 84.89709448000,
            "stddev_ms": 22.77662390588061000,
            "min_ms": 70.76107298000,
            "max_ms": 141.86036498000001000,
            "cv": 0.24861590858628745876,
            "runs": 10,
            "user_ms": 51.34464000,
            "system_ms": 21.43438000
          },
          "nim": {
            "mean_ms": 2.0588858800000007000,
            "median_ms": 2.0547399800000007000,
            "stddev_ms": 0.3996311380831776000,
            "min_ms": 1.4904069800000005000,
            "max_ms": 2.9316569800000012000,
            "cv": 0.19410067452751556299,
            "runs": 10,
            "user_ms": 0.89544000,
            "system_ms": 0.7541800000000001000
          },
          "logos_release": {
            "mean_ms": 7.715560680000002000,
            "median_ms": 4.092385480000002000,
            "stddev_ms": 10.844666485128817000,
            "min_ms": 3.409864980000001000,
            "max_ms": 38.49515698000,
            "cv": 1.40555779870152148021,
            "runs": 10,
            "user_ms": 2.0750399999999994000,
            "system_ms": 1.33538000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "bubble_sort",
      "name": "Bubble Sort",
      "description": "O(n^2) bubble sort. Measures nested loops, indexed array mutation, and swap patterns.",
      "reference_size": "1000",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000",
        "10000",
        "30000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 4294967296.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n - 1:\n    Let mutable j be 1.\n    While j is at most n - 1 - i:\n        Let a be item j of arr.\n        Let b be item (j + 1) of arr.\n        If a is greater than b:\n            Set item j of arr to b.\n            Set item (j + 1) of arr to a.\n        Set j to j + 1.\n    Set i to i + 1.\nShow item 1 of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 4294967296);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = 0;\n    for i in 0..(n - 1) {\n        unsafe { std::hint::assert_unchecked((((n - 1) - i) as usize) <= arr.len()); }\n        for j in 1..(((n - 1) - i) + 1) {\n            if arr[(j - 1) as usize] > arr[(j) as usize] {\n                let __swap_tmp = arr[(j - 1) as usize];\n                arr[(j - 1) as usize] = arr[(j) as usize];\n                arr[(j) as usize] = __swap_tmp;\n            }\n        }\n    }\n    show(&arr[0]);\n}",
      "scaling": {
        "1000": {
          "c": {
            "mean_ms": 0.6452684399999998000,
            "median_ms": 0.28867309999999974000,
            "stddev_ms": 0.7107859329370478000,
            "min_ms": 0,
            "max_ms": 2.2201736000,
            "cv": 1.10153525087488862822,
            "runs": 10,
            "user_ms": 0.8032000000000001000,
            "system_ms": 0.4360199999999999000
          },
          "cpp": {
            "mean_ms": 0.7879730999999996000,
            "median_ms": 0.9084855999999994000,
            "stddev_ms": 0.3350209297499187000,
            "min_ms": 0.07504859999999964000,
            "max_ms": 1.1038396000,
            "cv": 0.42516797813265309446,
            "runs": 10,
            "user_ms": 0.8550999999999999000,
            "system_ms": 0.47921999999999993000
          },
          "rust": {
            "mean_ms": 1.0652732999999997000,
            "median_ms": 0.9983811000,
            "stddev_ms": 0.5045809464562427000,
            "min_ms": 0.33729859999999997000,
            "max_ms": 2.1862565999999995000,
            "cv": 0.47366337488815578321,
            "runs": 10,
            "user_ms": 1.3186000,
            "system_ms": 0.4759199999999999000
          },
          "zig": {
            "mean_ms": 1.1509441999999997000,
            "median_ms": 0.7979445999999994000,
            "stddev_ms": 1.0665703325607326000,
            "min_ms": 0.11604859999999988000,
            "max_ms": 3.3940896000000005000,
            "cv": 0.92669160899436556351,
            "runs": 10,
            "user_ms": 0.9162000,
            "system_ms": 0.7331200000000001000
          },
          "go": {
            "mean_ms": 1.1743189999999998000,
            "median_ms": 1.1571520999999999000,
            "stddev_ms": 0.16313655946285536000,
            "min_ms": 0.9394645999999994000,
            "max_ms": 1.3919225999999996000,
            "cv": 0.13892013964080917347,
            "runs": 10,
            "user_ms": 1.3853000,
            "system_ms": 0.65062000
          },
          "java": {
            "mean_ms": 90.9049272000,
            "median_ms": 86.2936941000,
            "stddev_ms": 28.578068083809076000,
            "min_ms": 61.142047600000006000,
            "max_ms": 152.6886726000,
            "cv": 0.31437314746355218466,
            "runs": 10,
            "user_ms": 27.101800000000002000,
            "system_ms": 41.75632000
          },
          "js": {
            "mean_ms": 59.2783357000,
            "median_ms": 51.01121460000001000,
            "stddev_ms": 14.2684176214512000,
            "min_ms": 48.679506600000005000,
            "max_ms": 85.0488406000,
            "cv": 0.24070206177281728238,
            "runs": 10,
            "user_ms": 40.698899999999996000,
            "system_ms": 6.445119999999999000
          },
          "python": {
            "mean_ms": 249.28011090000002000,
            "median_ms": 246.58396460000004000,
            "stddev_ms": 32.39357196860049000,
            "min_ms": 213.6828406000,
            "max_ms": 309.42146460000003000,
            "cv": 0.12994848185700356811,
            "runs": 10,
            "user_ms": 93.9486000,
            "system_ms": 14.78132000
          },
          "ruby": {
            "mean_ms": 112.56132340000002000,
            "median_ms": 107.9362981000,
            "stddev_ms": 14.056402109728236000,
            "min_ms": 101.50642260000001000,
            "max_ms": 149.6591736000,
            "cv": 0.12487772607094484021,
            "runs": 10,
            "user_ms": 84.9793000,
            "system_ms": 17.59932000
          },
          "nim": {
            "mean_ms": 1.1385933399999998000,
            "median_ms": 0.5592980999999998000,
            "stddev_ms": 1.4999268832228414000,
            "min_ms": 0,
            "max_ms": 5.0401726000,
            "cv": 1.31735083152940422387,
            "runs": 10,
            "user_ms": 1.0704999999999998000,
            "system_ms": 0.43472000
          },
          "logos_release": {
            "mean_ms": 2.6760729999999997000,
            "median_ms": 2.1112146000,
            "stddev_ms": 1.5562358212263473000,
            "min_ms": 1.4800475999999993000,
            "max_ms": 6.399422599999999000,
            "cv": 0.58153713341390443177,
            "runs": 10,
            "user_ms": 2.1201999999999996000,
            "system_ms": 0.77382000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "mergesort",
      "name": "Merge Sort",
      "description": "Top-down merge sort. Measures allocation-heavy divide-and-conquer.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To mergeSort (arr: Seq of Int) -> Seq of Int:\n    Let n be length of arr.\n    If n is less than 2:\n        Return arr.\n    Let mid be n / 2.\n    Let mutable left be a new Seq of Int.\n    Let mutable right be a new Seq of Int.\n    Let mutable i be 1.\n    While i is at most mid:\n        Push item i of arr to left.\n        Set i to i + 1.\n    While i is at most n:\n        Push item i of arr to right.\n        Set i to i + 1.\n    Set left to mergeSort(left).\n    Set right to mergeSort(right).\n    Let mutable result be a new Seq of Int.\n    Let mutable li be 1.\n    Let mutable ri be 1.\n    While li is at most length of left:\n        If ri is greater than length of right:\n            Push item li of left to result.\n            Set li to li + 1.\n        Otherwise:\n            If item li of left is at most item ri of right:\n                Push item li of left to result.\n                Set li to li + 1.\n            Otherwise:\n                Push item ri of right to result.\n                Set ri to ri + 1.\n    While ri is at most length of right:\n        Push item ri of right to result.\n        Set ri to ri + 1.\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet arr to mergeSort(arr).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn mergeSort(arr: &[i64]) -> Vec<i64> {\n    let n = (arr.len() as i64);\n    if (n < 2) {\n        return arr.to_vec();\n    }\n    let mid = (n / 2);\n    let mut left: Vec<i64> = arr[..mid as usize].to_vec();\n    let mut right = Seq::<i64>::default();\n    let mut i = mid + 1;\n    if i <= n {\n        right.extend_from_slice(&arr[(i - 1) as usize..n as usize]);\n    }\n    left = mergeSort(&left);\n    right = mergeSort(&right);\n    let mut result: Vec<i64> = Vec::with_capacity((left.len() + right.len()) as usize);\n    let mut li = 1;\n    let mut ri = 1;\n    let left_len = (left.len() as i64);\n    let right_len = (right.len() as i64);\n    unsafe { std::hint::assert_unchecked((left_len as usize) <= left.len()); }\n    while (li <= left_len) {\n        if (ri > right_len) {\n            result.extend_from_slice(&left[(li - 1) as usize..]);\n            break;\n        } else {\n            if (left[(li - 1) as usize] <= right[(ri - 1) as usize]) {\n                result.push(left[(li - 1) as usize]);\n                li = (li + 1);\n            } else {\n                result.push(right[(ri - 1) as usize]);\n                ri = (ri + 1);\n            }\n        }\n    }\n    if ri <= (right.len() as i64) {\n        result.extend_from_slice(&right[(ri - 1) as usize..(right.len() as i64) as usize]);\n    }\n    return result;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    arr = mergeSort(&arr);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.8518233999999995000,
            "median_ms": 1.8727228999999997000,
            "stddev_ms": 0.21952023645630778000,
            "min_ms": 1.4848278999999996000,
            "max_ms": 2.161702899999999000,
            "cv": 0.11854274897720151893,
            "runs": 10,
            "user_ms": 1.09388000,
            "system_ms": 0.5707599999999999000
          },
          "cpp": {
            "mean_ms": 13.0595816000,
            "median_ms": 5.958848399999999000,
            "stddev_ms": 12.900649547268316000,
            "min_ms": 1.7774528999999991000,
            "max_ms": 30.744743900000003000,
            "cv": 0.98783023395392054520,
            "runs": 10,
            "user_ms": 1.2266800000000002000,
            "system_ms": 0.8087600000000001000
          },
          "rust": {
            "mean_ms": 2.2053944999999996000,
            "median_ms": 2.2093068999999993000,
            "stddev_ms": 0.18818736187770118000,
            "min_ms": 1.7964948999999995000,
            "max_ms": 2.4927858999999994000,
            "cv": 0.08533047573923904051,
            "runs": 10,
            "user_ms": 1.4319800000000002000,
            "system_ms": 0.6245599999999999000
          },
          "zig": {
            "mean_ms": 28.197381900000002000,
            "median_ms": 24.5186404000,
            "stddev_ms": 9.777988559778688000,
            "min_ms": 23.1209109000,
            "max_ms": 55.1631609000,
            "cv": 0.34676937718741495310,
            "runs": 10,
            "user_ms": 4.67598000,
            "system_ms": 20.040459999999996000
          },
          "go": {
            "mean_ms": 2.8410942999999994000,
            "median_ms": 2.8800773999999993000,
            "stddev_ms": 0.32348183953188675000,
            "min_ms": 2.2904528999999996000,
            "max_ms": 3.3282448999999996000,
            "cv": 0.11385818469027473615,
            "runs": 10,
            "user_ms": 1.58748000,
            "system_ms": 1.1023599999999997000
          },
          "java": {
            "mean_ms": 82.12373170000001000,
            "median_ms": 78.3974104000,
            "stddev_ms": 15.189758862375882000,
            "min_ms": 71.5226189000,
            "max_ms": 124.11270290000001000,
            "cv": 0.18496186848722901069,
            "runs": 10,
            "user_ms": 50.26308000,
            "system_ms": 32.21626000
          },
          "js": {
            "mean_ms": 55.59770270000001000,
            "median_ms": 50.4763689000,
            "stddev_ms": 14.195200976364834000,
            "min_ms": 47.3143279000,
            "max_ms": 94.19549490000001000,
            "cv": 0.25531991947510506485,
            "runs": 10,
            "user_ms": 41.05247999999999000,
            "system_ms": 6.3504600000000005000
          },
          "python": {
            "mean_ms": 190.1435067000,
            "median_ms": 181.0330149000,
            "stddev_ms": 28.13843396163947000,
            "min_ms": 159.69949390000002000,
            "max_ms": 252.73420290000004000,
            "cv": 0.14798524782671145509,
            "runs": 10,
            "user_ms": 34.029279999999995000,
            "system_ms": 13.885459999999999000
          },
          "ruby": {
            "mean_ms": 73.4018402000,
            "median_ms": 69.72157740000001000,
            "stddev_ms": 14.359838907891553000,
            "min_ms": 65.9702029000,
            "max_ms": 113.87753590000001000,
            "cv": 0.19563322756983895071,
            "runs": 10,
            "user_ms": 46.183579999999995000,
            "system_ms": 17.26436000
          },
          "nim": {
            "mean_ms": 1.8293942999999997000,
            "median_ms": 1.7953693999999995000,
            "stddev_ms": 0.20957527316678686000,
            "min_ms": 1.524952899999999000,
            "max_ms": 2.097994899999999000,
            "cv": 0.11455992465199377431,
            "runs": 10,
            "user_ms": 1.0979800000000001000,
            "system_ms": 0.6008599999999999000
          },
          "logos_release": {
            "mean_ms": 4.2165651000,
            "median_ms": 4.2382444000,
            "stddev_ms": 0.22279541908256924000,
            "min_ms": 3.7957858999999997000,
            "max_ms": 4.4655779000,
            "cv": 0.05283813099021505442,
            "runs": 10,
            "user_ms": 2.8244800000000003000,
            "system_ms": 1.0486599999999997000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "quicksort",
      "name": "Quicksort",
      "description": "Lomuto-partition quicksort. Measures in-place swap-heavy recursion.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To qs (arr: Seq of Int, lo: Int, hi: Int) -> Seq of Int:\n    If lo is at least hi:\n        Return arr.\n    Let pivot be item hi of arr.\n    Let mutable result be arr.\n    Let mutable i be lo.\n    Let mutable j be lo.\n    While j is less than hi:\n        If item j of result is at most pivot:\n            Let tmp be item i of result.\n            Set item i of result to item j of result.\n            Set item j of result to tmp.\n            Set i to i + 1.\n        Set j to j + 1.\n    Let tmp be item i of result.\n    Set item i of result to item hi of result.\n    Set item hi of result to tmp.\n    Set result to qs(result, lo, i - 1).\n    Set result to qs(result, i + 1, hi).\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet arr to qs(arr, 1, n).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn qs(arr: &mut [i64], lo: i64, hi: i64) {\n    if (lo >= hi) {\n        return;\n    }\n    let pivot = arr[(hi - 1) as usize];\n    let mut result = arr;\n    let mut i = lo;\n    unsafe { std::hint::assert_unchecked((hi as usize) <= result.len()); }\n    for j in lo..hi {\n        if (result[(j - 1) as usize] <= pivot) {\n            let tmp = result[(i - 1) as usize];\n            result[(i - 1) as usize] = result[(j - 1) as usize];\n            result[(j - 1) as usize] = tmp;\n            i = (i + 1);\n        }\n    }\n    let __swap_tmp = result[(i - 1) as usize];\n    result[(i - 1) as usize] = result[(hi - 1) as usize];\n    result[(hi - 1) as usize] = __swap_tmp;\n    qs(result, lo, (i - 1));\n    qs(result, (i + 1), hi);\n    return;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    qs(&mut arr, 1, n);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.9281416999999996000,
            "median_ms": 2.025087999999999000,
            "stddev_ms": 0.3637207727780109000,
            "min_ms": 1.303524999999999000,
            "max_ms": 2.322232999999999000,
            "cv": 0.18863798899116749326,
            "runs": 10,
            "user_ms": 0.7170800000000001000,
            "system_ms": 0.6897200000000001000
          },
          "cpp": {
            "mean_ms": 1.8825622999999992000,
            "median_ms": 1.8241914999999995000,
            "stddev_ms": 0.25304256880745934000,
            "min_ms": 1.587482999999999000,
            "max_ms": 2.403607999999999000,
            "cv": 0.13441391491132030399,
            "runs": 10,
            "user_ms": 0.7668800000000001000,
            "system_ms": 0.6590200000000001000
          },
          "rust": {
            "mean_ms": 3.1033707999999997000,
            "median_ms": 2.9682124999999993000,
            "stddev_ms": 1.0269258976244263000,
            "min_ms": 1.9093999999999995000,
            "max_ms": 5.313275000,
            "cv": 0.33090660568966699025,
            "runs": 10,
            "user_ms": 1.10858000,
            "system_ms": 0.93822000
          },
          "zig": {
            "mean_ms": 3.035674899999999000,
            "median_ms": 3.0265249999999995000,
            "stddev_ms": 0.578629545555982000,
            "min_ms": 2.3216499999999998000,
            "max_ms": 3.8907329999999995000,
            "cv": 0.19060985270721255118,
            "runs": 10,
            "user_ms": 0.9724800000000002000,
            "system_ms": 1.1357200000000002000
          },
          "go": {
            "mean_ms": 2.9093000999999992000,
            "median_ms": 2.984316499999999000,
            "stddev_ms": 0.36916342432419627000,
            "min_ms": 2.4206079999999994000,
            "max_ms": 3.618816999999999000,
            "cv": 0.12689080247314341051,
            "runs": 10,
            "user_ms": 1.2638800000000002000,
            "system_ms": 1.08672000
          },
          "java": {
            "mean_ms": 72.6811084000,
            "median_ms": 66.916275000,
            "stddev_ms": 13.765209181579665000,
            "min_ms": 63.454108000,
            "max_ms": 109.331608000,
            "cv": 0.18939184451925151157,
            "runs": 10,
            "user_ms": 41.19508000,
            "system_ms": 33.32052000
          },
          "js": {
            "mean_ms": 51.21801260000001000,
            "median_ms": 49.74115000,
            "stddev_ms": 3.8231840174067313000,
            "min_ms": 48.5299000,
            "max_ms": 61.539358000,
            "cv": 0.07464530198125513666,
            "runs": 10,
            "user_ms": 43.20557999999999000,
            "system_ms": 6.20792000
          },
          "python": {
            "mean_ms": 167.31995410000003000,
            "median_ms": 164.953962000,
            "stddev_ms": 14.766690349859668000,
            "min_ms": 151.72831700000003000,
            "max_ms": 205.15494200000003000,
            "cv": 0.08825420990155331002,
            "runs": 10,
            "user_ms": 29.343980000000002000,
            "system_ms": 13.257920000000001000
          },
          "ruby": {
            "mean_ms": 70.8268084000,
            "median_ms": 69.3663165000,
            "stddev_ms": 5.960629248791143000,
            "min_ms": 64.389317000,
            "max_ms": 86.4379000,
            "cv": 0.08415781232337927851,
            "runs": 10,
            "user_ms": 45.33967999999999000,
            "system_ms": 17.98672000
          },
          "nim": {
            "mean_ms": 2.5803291999999998000,
            "median_ms": 1.8746704999999995000,
            "stddev_ms": 2.0965339304705225000,
            "min_ms": 1.532524999999999000,
            "max_ms": 8.507692000,
            "cv": 0.81250637727562927338,
            "runs": 10,
            "user_ms": 0.8559800000000001000,
            "system_ms": 0.6450200000000002000
          },
          "logos_release": {
            "mean_ms": 3.0463248999999994000,
            "median_ms": 3.1054829999999996000,
            "stddev_ms": 0.3426473801885841000,
            "min_ms": 2.540857999999999000,
            "max_ms": 3.5605249999999993000,
            "cv": 0.11247893492535355223,
            "runs": 10,
            "user_ms": 1.7292799999999997000,
            "system_ms": 0.8511200000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "counting_sort",
      "name": "Counting Sort",
      "description": "Non-comparison O(n+k) sort. Measures pure array indexing throughput.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "40000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 1000 to arr.\n    Set i to i + 1.\nLet mutable counts be a new Seq of Int.\nSet i to 0.\nWhile i is less than 1000:\n    Push 0 to counts.\n    Set i to i + 1.\nSet i to 1.\nWhile i is at most n:\n    Let v be item i of arr.\n    Set item (v + 1) of counts to (item (v + 1) of counts) + 1.\n    Set i to i + 1.\nLet mutable sorted be a new Seq of Int.\nLet mutable v be 0.\nWhile v is less than 1000:\n    Let mutable c be 0.\n    While c is less than item (v + 1) of counts:\n        Push v to sorted.\n        Set c to c + 1.\n    Set v to v + 1.\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of sorted) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of sorted + \" \" + item n of sorted + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 1000));\n    }\n    let mut i = (0_i64).max(n);\n    let mut counts: Vec<i64> = vec![0; 1000 as usize];\n    i = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        let mut v = arr[i as usize];\n        counts[(v) as usize] = (counts[v as usize] + 1);\n    }\n    i = (1_i64).max(n + 1);\n    let mut sorted = Seq::<i64>::default();\n    for v in 0..1000 {\n        let mut c = 0;\n        while (c < counts[v as usize]) {\n            sorted.push(v);\n            c = (c + 1);\n        }\n    }\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= sorted.len()); }\n    for i in 0..n {\n        checksum = ((checksum + sorted[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", sorted[0], \" \", sorted[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 2.577849119999999000,
            "median_ms": 2.6129410199999996000,
            "stddev_ms": 0.5919827402933393000,
            "min_ms": 1.3597530199999995000,
            "max_ms": 3.4673370199999995000,
            "cv": 0.22964212129425927365,
            "runs": 10,
            "user_ms": 0.88238000,
            "system_ms": 0.8415800000000001000
          },
          "cpp": {
            "mean_ms": 3.2457243199999998000,
            "median_ms": 3.0623580199999993000,
            "stddev_ms": 1.2532929343310897000,
            "min_ms": 1.7434620199999998000,
            "max_ms": 6.054628019999999000,
            "cv": 0.38613659410577722054,
            "runs": 10,
            "user_ms": 0.9827800000000002000,
            "system_ms": 1.1487799999999999000
          },
          "rust": {
            "mean_ms": 3.0753784199999993000,
            "median_ms": 2.9767535199999996000,
            "stddev_ms": 0.5686341857855931000,
            "min_ms": 2.19925402000,
            "max_ms": 3.98937802000,
            "cv": 0.18489893214038785816,
            "runs": 10,
            "user_ms": 1.17998000,
            "system_ms": 0.9514799999999999000
          },
          "zig": {
            "mean_ms": 2.6661494199999992000,
            "median_ms": 2.7525870199999994000,
            "stddev_ms": 0.616203401205082000,
            "min_ms": 1.5309200199999993000,
            "max_ms": 3.61271202000,
            "cv": 0.23112110543492426800,
            "runs": 10,
            "user_ms": 1.0102800000000001000,
            "system_ms": 0.8301800000000001000
          },
          "go": {
            "mean_ms": 3.3980325199999993000,
            "median_ms": 3.10552402000,
            "stddev_ms": 0.7197639247583965000,
            "min_ms": 2.6773780199999997000,
            "max_ms": 4.506212019999999000,
            "cv": 0.21181784474458079885,
            "runs": 10,
            "user_ms": 1.5145800000000002000,
            "system_ms": 1.2509799999999998000
          },
          "java": {
            "mean_ms": 152.23617841999998000,
            "median_ms": 103.84835752000,
            "stddev_ms": 156.51012340175377000,
            "min_ms": 64.00037802000,
            "max_ms": 587.88108702000,
            "cv": 1.02807443687900866160,
            "runs": 10,
            "user_ms": 44.53007999999999000,
            "system_ms": 37.20358000
          },
          "js": {
            "mean_ms": 53.65453672000,
            "median_ms": 51.77360752000,
            "stddev_ms": 4.2239978867029656000,
            "min_ms": 49.45983702000,
            "max_ms": 60.55483702000,
            "cv": 0.07872582907101029946,
            "runs": 10,
            "user_ms": 43.208579999999996000,
            "system_ms": 5.858779999999999000
          },
          "python": {
            "mean_ms": 174.10955332000,
            "median_ms": 168.91469102000,
            "stddev_ms": 16.48095190606232000,
            "min_ms": 160.42996201999998000,
            "max_ms": 215.11629502000,
            "cv": 0.09465851581257919225,
            "runs": 10,
            "user_ms": 40.13748000,
            "system_ms": 12.371579999999998000
          },
          "ruby": {
            "mean_ms": 69.15147002000,
            "median_ms": 68.23194102000,
            "stddev_ms": 4.388739558058708000,
            "min_ms": 65.71683702000,
            "max_ms": 81.22212802000,
            "cv": 0.06346560032331049496,
            "runs": 10,
            "user_ms": 47.11518000,
            "system_ms": 15.88408000
          },
          "nim": {
            "mean_ms": 2.2235409199999993000,
            "median_ms": 2.2807740199999997000,
            "stddev_ms": 0.30242527508073065000,
            "min_ms": 1.5507950199999993000,
            "max_ms": 2.5866700199999996000,
            "cv": 0.13601066315466357381,
            "runs": 10,
            "user_ms": 1.1197800000000001000,
            "system_ms": 0.63228000
          },
          "logos_release": {
            "mean_ms": 7.32917832000,
            "median_ms": 3.5864820199999997000,
            "stddev_ms": 6.892184916662722000,
            "min_ms": 3.0065870199999993000,
            "max_ms": 21.508129020000002000,
            "cv": 0.94037620804711461843,
            "runs": 10,
            "user_ms": 2.2233799999999996000,
            "system_ms": 1.37158000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "heap_sort",
      "name": "Heap Sort",
      "description": "Heap sort with sift-down. Measures logarithmic array jumps.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "2500000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To siftDown (arr: Seq of Int, start: Int, end: Int) -> Seq of Int:\n    Let mutable result be arr.\n    Let mutable root be start.\n    While 2 * root + 1 is at most end:\n        Let child be 2 * root + 1.\n        Let mutable swapIdx be root.\n        If item (swapIdx + 1) of result is less than item (child + 1) of result:\n            Set swapIdx to child.\n        If child + 1 is at most end:\n            If item (swapIdx + 1) of result is less than item (child + 2) of result:\n                Set swapIdx to child + 1.\n        If swapIdx equals root:\n            Return result.\n        Let tmp be item (root + 1) of result.\n        Set item (root + 1) of result to item (swapIdx + 1) of result.\n        Set item (swapIdx + 1) of result to tmp.\n        Set root to swapIdx.\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nLet mutable start be (n - 2) / 2.\nWhile start is at least 0:\n    Set arr to siftDown(arr, start, n - 1).\n    Set start to start - 1.\nLet mutable end be n - 1.\nWhile end is greater than 0:\n    Let tmp be item 1 of arr.\n    Set item 1 of arr to item (end + 1) of arr.\n    Set item (end + 1) of arr to tmp.\n    Set end to end - 1.\n    Set arr to siftDown(arr, 0, end).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn siftDown(arr: &mut [i64], start: i64, end: i64) {\n    let mut result = arr;\n    let mut root = start;\n    while (((2 * root) + 1) <= end) {\n        let child = ((2 * root) + 1);\n        let mut swapIdx = root;\n        if (result[swapIdx as usize] < result[child as usize]) {\n            swapIdx = child;\n        }\n        if ((child + 1) <= end) {\n            if (result[swapIdx as usize] < result[(child + 1) as usize]) {\n                swapIdx = (child + 1);\n            }\n        }\n        if (swapIdx == root) {\n            return;\n        }\n        let __swap_tmp = result[(root) as usize];\n        result[(root) as usize] = result[(swapIdx) as usize];\n        result[(swapIdx) as usize] = __swap_tmp;\n        root = swapIdx;\n    }\n    return;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    let mut start = ((n - 2) / 2);\n    while (start >= 0) {\n        siftDown(&mut arr, start, (n - 1));\n        start = (start - 1);\n    }\n    let mut end = (n - 1);\n    while (end > 0) {\n        let __swap_tmp = arr[0];\n        arr[0] = arr[(end) as usize];\n        arr[(end) as usize] = __swap_tmp;\n        end = (end - 1);\n        siftDown(&mut arr, 0, end);\n    }\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 6.30659074000,
            "median_ms": 1.6803115399999999000,
            "stddev_ms": 13.006538722696375000,
            "min_ms": 1.42702004000,
            "max_ms": 43.00347804000,
            "cv": 2.06237240672705757342,
            "runs": 10,
            "user_ms": 0.7393999999999998000,
            "system_ms": 0.6615999999999995000
          },
          "cpp": {
            "mean_ms": 1.58991574000,
            "median_ms": 1.55099854000,
            "stddev_ms": 0.2314802761528267000,
            "min_ms": 1.2776450399999998000,
            "max_ms": 1.99589504000,
            "cv": 0.14559279484384920926,
            "runs": 10,
            "user_ms": 0.6869999999999998000,
            "system_ms": 0.5502999999999996000
          },
          "rust": {
            "mean_ms": 1.8862324400000002000,
            "median_ms": 1.88445754000,
            "stddev_ms": 0.15712866296142307000,
            "min_ms": 1.5365620399999998000,
            "max_ms": 2.10210304000,
            "cv": 0.08330291624155454210,
            "runs": 10,
            "user_ms": 0.9802999999999995000,
            "system_ms": 0.5760999999999995000
          },
          "zig": {
            "mean_ms": 1.51681174000,
            "median_ms": 1.4965410400000004000,
            "stddev_ms": 0.1536287887264841000,
            "min_ms": 1.2983530400000002000,
            "max_ms": 1.8470610400000004000,
            "cv": 0.10128401875797987955,
            "runs": 10,
            "user_ms": 0.7136999999999996000,
            "system_ms": 0.5281999999999995000
          },
          "go": {
            "mean_ms": 2.5370949400000003000,
            "median_ms": 2.50577004000,
            "stddev_ms": 0.1851331018552448000,
            "min_ms": 2.27897804000,
            "max_ms": 2.80939504000,
            "cv": 0.07297050612352913293,
            "runs": 10,
            "user_ms": 1.2444999999999997000,
            "system_ms": 0.9218999999999995000
          },
          "java": {
            "mean_ms": 72.48819104000001000,
            "median_ms": 67.61212454000,
            "stddev_ms": 17.656495090221637000,
            "min_ms": 61.38743704000,
            "max_ms": 119.77185304000,
            "cv": 0.24357753776030268231,
            "runs": 10,
            "user_ms": 38.8567000,
            "system_ms": 28.75169999999999000
          },
          "js": {
            "mean_ms": 72.42464073999999000,
            "median_ms": 50.597145040000006000,
            "stddev_ms": 49.16787948571242000,
            "min_ms": 47.918687040000005000,
            "max_ms": 204.67897804000001000,
            "cv": 0.67888330523063395162,
            "runs": 10,
            "user_ms": 44.7069000,
            "system_ms": 7.091000
          },
          "python": {
            "mean_ms": 186.29625754000,
            "median_ms": 173.33974904000,
            "stddev_ms": 31.254139295566905000,
            "min_ms": 163.86281204000,
            "max_ms": 264.61422904000004000,
            "cv": 0.16776579255144872299,
            "runs": 10,
            "user_ms": 37.1677000,
            "system_ms": 13.153999999999999000
          },
          "ruby": {
            "mean_ms": 76.97319913999999000,
            "median_ms": 71.48731204000,
            "stddev_ms": 13.10260051211856000,
            "min_ms": 70.28264504000,
            "max_ms": 112.36081104000001000,
            "cv": 0.17022289132464608774,
            "runs": 10,
            "user_ms": 50.19000,
            "system_ms": 16.9901000
          },
          "nim": {
            "mean_ms": 2.10024934000,
            "median_ms": 2.08406204000,
            "stddev_ms": 0.19703149212699198000,
            "min_ms": 1.8992700400000005000,
            "max_ms": 2.4618120400000006000,
            "cv": 0.09381338128500113229,
            "runs": 10,
            "user_ms": 0.9396999999999997000,
            "system_ms": 0.6837999999999995000
          },
          "logos_release": {
            "mean_ms": 4.44466184000,
            "median_ms": 4.20420754000,
            "stddev_ms": 0.8867526362257341000,
            "min_ms": 3.4379780400000002000,
            "max_ms": 6.528478040000001000,
            "cv": 0.19950958433898181554,
            "runs": 10,
            "user_ms": 2.0872000,
            "system_ms": 1.4815999999999996000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "nbody",
      "name": "N-Body Simulation",
      "description": "5-body gravitational simulation. Measures FP struct arrays and sqrt.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "4000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet pi be 3.141592653589793.\nLet solarMass be 4.0 * pi * pi.\nLet daysPerYear be 365.24.\n\nLet mutable bx be a new Seq of Float.\nLet mutable posY be a new Seq of Float.\nLet mutable bz be a new Seq of Float.\nLet mutable bvx be a new Seq of Float.\nLet mutable bvy be a new Seq of Float.\nLet mutable bvz be a new Seq of Float.\nLet mutable bm be a new Seq of Float.\n\nPush 0.0 to bx. Push 0.0 to posY. Push 0.0 to bz.\nPush 0.0 to bvx. Push 0.0 to bvy. Push 0.0 to bvz.\nPush solarMass to bm.\n\nPush 4.841431442464721 to bx. Push 0.0 - 1.1603200440274284 to posY. Push 0.0 - 0.10362204447112311 to bz.\nPush 0.001660076642744037 * daysPerYear to bvx. Push 0.007699011184197404 * daysPerYear to bvy. Push 0.0 - 0.0000690460016972063 * daysPerYear to bvz.\nPush 0.0009547919384243266 * solarMass to bm.\n\nPush 8.34336671824458 to bx. Push 4.124798564124305 to posY. Push 0.0 - 0.4035234171143214 to bz.\nPush 0.0 - 0.002767425107268624 * daysPerYear to bvx. Push 0.004998528012349172 * daysPerYear to bvy. Push 0.00002304172975737639 * daysPerYear to bvz.\nPush 0.0002858859806661308 * solarMass to bm.\n\nPush 12.894369562139131 to bx. Push 0.0 - 15.111151401698631 to posY. Push 0.0 - 0.22330757889265573 to bz.\nPush 0.002964601375647616 * daysPerYear to bvx. Push 0.0023784717395948095 * daysPerYear to bvy. Push 0.0 - 0.000029658956854023756 * daysPerYear to bvz.\nPush 0.00004366244043351563 * solarMass to bm.\n\nPush 15.379697114850917 to bx. Push 0.0 - 25.919314609987964 to posY. Push 0.17925877295037118 to bz.\nPush 0.0026806777249038932 * daysPerYear to bvx. Push 0.001628241700382423 * daysPerYear to bvy. Push 0.0 - 0.00009515922545197159 * daysPerYear to bvz.\nPush 0.00005151389020466114 * solarMass to bm.\n\nLet mutable px be 0.0.\nLet mutable py be 0.0.\nLet mutable pz be 0.0.\nLet mutable i be 1.\nWhile i is at most 5:\n    Set px to px + item i of bvx * item i of bm.\n    Set py to py + item i of bvy * item i of bm.\n    Set pz to pz + item i of bvz * item i of bm.\n    Set i to i + 1.\nSet item 1 of bvx to 0.0 - px / solarMass.\nSet item 1 of bvy to 0.0 - py / solarMass.\nSet item 1 of bvz to 0.0 - pz / solarMass.\n\nLet mutable e be 0.0.\nSet i to 1.\nWhile i is at most 5:\n    Set e to e + 0.5 * item i of bm * (item i of bvx * item i of bvx + item i of bvy * item i of bvy + item i of bvz * item i of bvz).\n    Let mutable j be i + 1.\n    While j is at most 5:\n        Let dx be item i of bx - item j of bx.\n        Let dy be item i of posY - item j of posY.\n        Let dz be item i of bz - item j of bz.\n        Set e to e - item i of bm * item j of bm / sqrt(dx * dx + dy * dy + dz * dz).\n        Set j to j + 1.\n    Set i to i + 1.\nShow \"{e:.9}\".\n\nLet dt be 0.01.\nLet mutable step be 0.\nWhile step is less than n:\n    Set i to 1.\n    While i is at most 5:\n        Let mutable j be i + 1.\n        While j is at most 5:\n            Let dx be item i of bx - item j of bx.\n            Let dy be item i of posY - item j of posY.\n            Let dz be item i of bz - item j of bz.\n            Let dist be sqrt(dx * dx + dy * dy + dz * dz).\n            Let mag be dt / (dist * dist * dist).\n            Set item i of bvx to item i of bvx - dx * item j of bm * mag.\n            Set item i of bvy to item i of bvy - dy * item j of bm * mag.\n            Set item i of bvz to item i of bvz - dz * item j of bm * mag.\n            Set item j of bvx to item j of bvx + dx * item i of bm * mag.\n            Set item j of bvy to item j of bvy + dy * item i of bm * mag.\n            Set item j of bvz to item j of bvz + dz * item i of bm * mag.\n            Set j to j + 1.\n        Set i to i + 1.\n    Set i to 1.\n    While i is at most 5:\n        Set item i of bx to item i of bx + dt * item i of bvx.\n        Set item i of posY to item i of posY + dt * item i of bvy.\n        Set item i of bz to item i of bz + dt * item i of bvz.\n        Set i to i + 1.\n    Set step to step + 1.\n\nSet e to 0.0.\nSet i to 1.\nWhile i is at most 5:\n    Set e to e + 0.5 * item i of bm * (item i of bvx * item i of bvx + item i of bvy * item i of bvy + item i of bvz * item i of bvz).\n    Let mutable j be i + 1.\n    While j is at most 5:\n        Let dx be item i of bx - item j of bx.\n        Let dy be item i of posY - item j of posY.\n        Let dz be item i of bz - item j of bz.\n        Set e to e - item i of bm * item j of bm / sqrt(dx * dx + dy * dy + dz * dz).\n        Set j to j + 1.\n    Set i to i + 1.\nShow \"{e:.9}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let pi = 3.141592653589793f64;\n    let solarMass = ((4f64 * pi) * pi);\n    let daysPerYear = 365.24f64;\n    let mut bx = Seq::<f64>::default();\n    let mut posY = Seq::<f64>::default();\n    let mut bz = Seq::<f64>::default();\n    let mut bvx = Seq::<f64>::default();\n    let mut bvy = Seq::<f64>::default();\n    let mut bvz = Seq::<f64>::default();\n    let mut bm = Seq::<f64>::default();\n    bx.push(0f64);\n    posY.push(0f64);\n    bz.push(0f64);\n    bvx.push(0f64);\n    bvy.push(0f64);\n    bvz.push(0f64);\n    bm.push(solarMass);\n    bx.push(4.841431442464721f64);\n    posY.push((0f64 - 1.1603200440274284f64));\n    bz.push((0f64 - 0.10362204447112311f64));\n    bvx.push((0.001660076642744037f64 * daysPerYear));\n    bvy.push((0.007699011184197404f64 * daysPerYear));\n    bvz.push((0f64 - (0.0000690460016972063f64 * daysPerYear)));\n    bm.push((0.0009547919384243266f64 * solarMass));\n    bx.push(8.34336671824458f64);\n    posY.push(4.124798564124305f64);\n    bz.push((0f64 - 0.4035234171143214f64));\n    bvx.push((0f64 - (0.002767425107268624f64 * daysPerYear)));\n    bvy.push((0.004998528012349172f64 * daysPerYear));\n    bvz.push((0.00002304172975737639f64 * daysPerYear));\n    bm.push((0.0002858859806661308f64 * solarMass));\n    bx.push(12.894369562139131f64);\n    posY.push((0f64 - 15.111151401698631f64));\n    bz.push((0f64 - 0.22330757889265573f64));\n    bvx.push((0.002964601375647616f64 * daysPerYear));\n    bvy.push((0.0023784717395948095f64 * daysPerYear));\n    bvz.push((0f64 - (0.000029658956854023756f64 * daysPerYear)));\n    bm.push((0.00004366244043351563f64 * solarMass));\n    bx.push(15.379697114850917f64);\n    posY.push((0f64 - 25.919314609987964f64));\n    bz.push(0.17925877295037118f64);\n    bvx.push((0.0026806777249038932f64 * daysPerYear));\n    bvy.push((0.001628241700382423f64 * daysPerYear));\n    bvz.push((0f64 - (0.00009515922545197159f64 * daysPerYear)));\n    bm.push((0.00005151389020466114f64 * solarMass));\n    let mut px = 0f64;\n    let mut py = 0f64;\n    let mut pz = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 0..5 {\n        px = (px + (bvx[i as usize] * bm[i as usize]));\n        py = (py + (bvy[i as usize] * bm[i as usize]));\n        pz = (pz + (bvz[i as usize] * bm[i as usize]));\n    }\n    let mut i = 6;\n    bvx[0] = (0f64 - (px / solarMass));\n    bvy[0] = (0f64 - (py / solarMass));\n    bvz[0] = (0f64 - (pz / solarMass));\n    let mut e = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 1..6 {\n        e = (e + ((0.5f64 * bm[(i - 1) as usize]) * (((bvx[(i - 1) as usize] * bvx[(i - 1) as usize]) + (bvy[(i - 1) as usize] * bvy[(i - 1) as usize])) + (bvz[(i - 1) as usize] * bvz[(i - 1) as usize]))));\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n        for j in (i + 1)..6 {\n            let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n            let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n            let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n            e = (e - ((bm[(i - 1) as usize] * bm[(j - 1) as usize]) / (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt()));\n        }\n    }\n    i = 6;\n    println!(\"{:.9}\", e as f64);\n    let dt = 0.01f64;\n    for step in 0..n {\n        for i in 1..6 {\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n            for j in (i + 1)..6 {\n                let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n                let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n                let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n                let dist = (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt();\n                let mag = (dt / ((dist * dist) * dist));\n                bvx[(i - 1) as usize] = (bvx[(i - 1) as usize] - ((dx * bm[(j - 1) as usize]) * mag));\n                bvy[(i - 1) as usize] = (bvy[(i - 1) as usize] - ((dy * bm[(j - 1) as usize]) * mag));\n                bvz[(i - 1) as usize] = (bvz[(i - 1) as usize] - ((dz * bm[(j - 1) as usize]) * mag));\n                bvx[(j - 1) as usize] = (bvx[(j - 1) as usize] + ((dx * bm[(i - 1) as usize]) * mag));\n                bvy[(j - 1) as usize] = (bvy[(j - 1) as usize] + ((dy * bm[(i - 1) as usize]) * mag));\n                bvz[(j - 1) as usize] = (bvz[(j - 1) as usize] + ((dz * bm[(i - 1) as usize]) * mag));\n            }\n        }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n        for i in 0..5 {\n            bx[i as usize] = (bx[i as usize] + (dt * bvx[i as usize]));\n            posY[i as usize] = (posY[i as usize] + (dt * bvy[i as usize]));\n            bz[i as usize] = (bz[i as usize] + (dt * bvz[i as usize]));\n        }\n    }\n    e = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 1..6 {\n        e = (e + ((0.5f64 * bm[(i - 1) as usize]) * (((bvx[(i - 1) as usize] * bvx[(i - 1) as usize]) + (bvy[(i - 1) as usize] * bvy[(i - 1) as usize])) + (bvz[(i - 1) as usize] * bvz[(i - 1) as usize]))));\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n        for j in (i + 1)..6 {\n            let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n            let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n            let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n            e = (e - ((bm[(i - 1) as usize] * bm[(j - 1) as usize]) / (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt()));\n        }\n    }\n    println!(\"{:.9}\", e as f64);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 0.7807223599999992000,
            "median_ms": 0.746676459999999000,
            "stddev_ms": 0.15995322432177898000,
            "min_ms": 0.5272599599999992000,
            "max_ms": 1.004592959999999000,
            "cv": 0.20487849780782395409,
            "runs": 10,
            "user_ms": 0.7313399999999999000,
            "system_ms": 0.5579399999999998000
          },
          "cpp": {
            "mean_ms": 0.7404642599999989000,
            "median_ms": 0.7158434599999989000,
            "stddev_ms": 0.19666296033629056000,
            "min_ms": 0.45880195999999877000,
            "max_ms": 1.0891769599999995000,
            "cv": 0.26559412919712134675,
            "runs": 10,
            "user_ms": 0.7431399999999998000,
            "system_ms": 0.5432399999999997000
          },
          "rust": {
            "mean_ms": 0.8549808599999991000,
            "median_ms": 0.8162184599999991000,
            "stddev_ms": 0.2738293528302496000,
            "min_ms": 0.41596895999999883000,
            "max_ms": 1.448218959999999000,
            "cv": 0.32027541859855188834,
            "runs": 10,
            "user_ms": 0.8906399999999998000,
            "system_ms": 0.5050399999999998000
          },
          "zig": {
            "mean_ms": 0.518755759999999000,
            "median_ms": 0.496926459999999000,
            "stddev_ms": 0.30283119056508486000,
            "min_ms": 0.10184395999999867000,
            "max_ms": 1.073384959999999000,
            "cv": 0.58376448786821267057,
            "runs": 10,
            "user_ms": 0.61314000,
            "system_ms": 0.4087399999999998000
          },
          "go": {
            "mean_ms": 1.435330759999999000,
            "median_ms": 1.4669889599999994000,
            "stddev_ms": 0.21357613590255523000,
            "min_ms": 1.0107599599999987000,
            "max_ms": 1.8075099599999993000,
            "cv": 0.14879924673428957852,
            "runs": 10,
            "user_ms": 1.15114000,
            "system_ms": 0.8113399999999998000
          },
          "java": {
            "mean_ms": 75.13061416000,
            "median_ms": 76.10261446000,
            "stddev_ms": 9.011412976440968000,
            "min_ms": 62.94475996000,
            "max_ms": 95.00955096000001000,
            "cv": 0.11994328912645438701,
            "runs": 10,
            "user_ms": 47.01614000,
            "system_ms": 29.26304000
          },
          "js": {
            "mean_ms": 51.87904746000001000,
            "median_ms": 50.08284346000,
            "stddev_ms": 4.5503894237258966000,
            "min_ms": 47.68034296000,
            "max_ms": 59.34321796000,
            "cv": 0.08771150679345753205,
            "runs": 10,
            "user_ms": 40.23694000,
            "system_ms": 6.106939999999999000
          },
          "python": {
            "mean_ms": 207.25666396000003000,
            "median_ms": 200.13234296000001000,
            "stddev_ms": 18.468436349228616000,
            "min_ms": 188.92250996000,
            "max_ms": 242.19892596000003000,
            "cv": 0.08910901100286441823,
            "runs": 10,
            "user_ms": 62.95744000,
            "system_ms": 13.643739999999998000
          },
          "ruby": {
            "mean_ms": 101.44464336000,
            "median_ms": 99.02650996000001000,
            "stddev_ms": 10.450313463371533000,
            "min_ms": 92.31492596000,
            "max_ms": 121.50105196000001000,
            "cv": 0.10301493619812093940,
            "runs": 10,
            "user_ms": 73.62134000,
            "system_ms": 18.47954000
          },
          "nim": {
            "mean_ms": 4.97368496000,
            "median_ms": 2.5444679599999995000,
            "stddev_ms": 5.874613402636146000,
            "min_ms": 0.5011769599999995000,
            "max_ms": 15.918717960000002000,
            "cv": 1.18113902466314352165,
            "runs": 10,
            "user_ms": 1.00344000,
            "system_ms": 0.9301399999999998000
          },
          "logos_release": {
            "mean_ms": 2.601847459999999000,
            "median_ms": 2.6004059599999993000,
            "stddev_ms": 0.2629032059376184000,
            "min_ms": 2.0825509599999995000,
            "max_ms": 3.0064689599999996000,
            "cv": 0.10104481910619714079,
            "runs": 10,
            "user_ms": 1.94014000,
            "system_ms": 0.9748399999999997000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "mandelbrot",
      "name": "Mandelbrot Set",
      "description": "Mandelbrot set escape iteration. Measures FP branching and convergence.",
      "reference_size": "200",
      "sizes": [
        "100",
        "200",
        "500",
        "1000",
        "2000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable count be 0.\nLet mutable y be 0.\nWhile y is less than n:\n    Let mutable x be 0.\n    While x is less than n:\n        Let cr be 2.0 * x / n - 1.5.\n        Let ci be 2.0 * y / n - 1.0.\n        Let mutable zr be 0.0.\n        Let mutable zi be 0.0.\n        Let mutable isInside be 1.\n        Let mutable iter be 0.\n        While iter is less than 50:\n            Let zr2 be zr * zr - zi * zi + cr.\n            Let zi2 be 2.0 * zr * zi + ci.\n            Set zr to zr2.\n            Set zi to zi2.\n            If zr * zr + zi * zi is greater than 4.0:\n                Set isInside to 0.\n                Set iter to 50.\n            Set iter to iter + 1.\n        If isInside equals 1:\n            Set count to count + 1.\n        Set x to x + 1.\n    Set y to y + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut count = 0;\n    for y in 0..n {\n        for x in 0..n {\n            let cr = (((2f64 * ((x) as f64)) / ((n) as f64)) - 1.5f64);\n            let ci = (((2f64 * ((y) as f64)) / ((n) as f64)) - 1f64);\n            let mut zr = 0f64;\n            let mut zi = 0f64;\n            let mut isInside = 1;\n            let mut iter = 0;\n            while (iter < 50) {\n                let zr2 = (((zr * zr) - (zi * zi)) + cr);\n                let zi2 = (((2f64 * zr) * zi) + ci);\n                zr = zr2;\n                zi = zi2;\n                if (((zr * zr) + (zi * zi)) > 4f64) {\n                    isInside = 0;\n                    break;\n                }\n                iter = (iter + 1);\n            }\n            if (isInside == 1) {\n                count = (count + 1);\n            }\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "200": {
          "c": {
            "mean_ms": 4.123975959999999000,
            "median_ms": 3.961538159999999000,
            "stddev_ms": 0.37358706010597075000,
            "min_ms": 3.6780181599999993000,
            "max_ms": 4.948518159999999000,
            "cv": 0.09058904894925014077,
            "runs": 10,
            "user_ms": 2.98606000,
            "system_ms": 0.6405799999999998000
          },
          "cpp": {
            "mean_ms": 4.128100859999999000,
            "median_ms": 4.071330159999999000,
            "stddev_ms": 0.17122564556945822000,
            "min_ms": 3.857851159999999000,
            "max_ms": 4.377726159999999000,
            "cv": 0.04147806736714719259,
            "runs": 10,
            "user_ms": 3.0013599999999994000,
            "system_ms": 0.6445799999999996000
          },
          "rust": {
            "mean_ms": 5.052471759999999000,
            "median_ms": 5.045392659999999000,
            "stddev_ms": 0.22922349316730647000,
            "min_ms": 4.7280171599999995000,
            "max_ms": 5.508768159999999000,
            "cv": 0.04536858473550508580,
            "runs": 10,
            "user_ms": 3.925059999999999000,
            "system_ms": 0.6801799999999996000
          },
          "zig": {
            "mean_ms": 4.737896559999999000,
            "median_ms": 4.703350159999999000,
            "stddev_ms": 0.27020335965104343000,
            "min_ms": 4.329851159999999000,
            "max_ms": 5.394268159999999000,
            "cv": 0.05703023614577256347,
            "runs": 10,
            "user_ms": 3.71296000,
            "system_ms": 0.5967799999999997000
          },
          "go": {
            "mean_ms": 5.614967459999999000,
            "median_ms": 5.64910066000,
            "stddev_ms": 0.2106244894477423000,
            "min_ms": 5.26510116000,
            "max_ms": 5.902142159999999000,
            "cv": 0.03751125735780173826,
            "runs": 10,
            "user_ms": 4.146459999999999000,
            "system_ms": 1.1108799999999996000
          },
          "java": {
            "mean_ms": 59.55168416000001000,
            "median_ms": 57.551288160000005000,
            "stddev_ms": 4.94324184548343000,
            "min_ms": 54.98435116000001000,
            "max_ms": 71.88468416000,
            "cv": 0.08300759105657221382,
            "runs": 10,
            "user_ms": 28.569260000000003000,
            "system_ms": 28.99178000
          },
          "js": {
            "mean_ms": 50.34149256000,
            "median_ms": 50.412871660000004000,
            "stddev_ms": 0.9183415500056116000,
            "min_ms": 48.99960116000,
            "max_ms": 51.677309160000004000,
            "cv": 0.01824223922068018239,
            "runs": 10,
            "user_ms": 40.73835999999999000,
            "system_ms": 5.41058000
          },
          "python": {
            "mean_ms": 397.48217166000005000,
            "median_ms": 395.67612166000,
            "stddev_ms": 19.361166150975585000,
            "min_ms": 375.83422616000,
            "max_ms": 433.66985116000,
            "cv": 0.04870952090786305674,
            "runs": 10,
            "user_ms": 260.56946000,
            "system_ms": 13.31358000
          },
          "ruby": {
            "mean_ms": 214.91393406000,
            "median_ms": 211.11572566000003000,
            "stddev_ms": 11.706166575828065000,
            "min_ms": 208.21193416000003000,
            "max_ms": 247.51630916000003000,
            "cv": 0.05446909074104017636,
            "runs": 10,
            "user_ms": 188.24046000,
            "system_ms": 17.777380000000002000
          },
          "nim": {
            "mean_ms": 3.830234259999999000,
            "median_ms": 3.8099551599999988000,
            "stddev_ms": 0.216531048471345000,
            "min_ms": 3.5106001599999994000,
            "max_ms": 4.174893159999999000,
            "cv": 0.05653206403917055886,
            "runs": 10,
            "user_ms": 2.73626000,
            "system_ms": 0.6203799999999997000
          },
          "logos_release": {
            "mean_ms": 6.035746459999999000,
            "median_ms": 6.027350659999999000,
            "stddev_ms": 0.23965806775953365000,
            "min_ms": 5.6684751599999994000,
            "max_ms": 6.4139761599999985000,
            "cv": 0.03970645045278023320,
            "runs": 10,
            "user_ms": 4.41736000,
            "system_ms": 0.9600799999999997000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "spectral_norm",
      "name": "Spectral Norm",
      "description": "Spectral norm power method. Measures FP dot products and array throughput.",
      "reference_size": "500",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To aVal (i: Int, j: Int) -> Float:\n    Return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1).\n\n## To mulAv (n: Int, v: Seq of Float, out: Seq of Float) -> Seq of Float:\n    Let mutable result be out.\n    Let mutable i be 0.\n    While i is less than n:\n        Let mutable sum be 0.0.\n        Let mutable j be 0.\n        While j is less than n:\n            Set sum to sum + aVal(i, j) * item (j + 1) of v.\n            Set j to j + 1.\n        Set item (i + 1) of result to sum.\n        Set i to i + 1.\n    Return result.\n\n## To mulAtv (n: Int, v: Seq of Float, out: Seq of Float) -> Seq of Float:\n    Let mutable result be out.\n    Let mutable i be 0.\n    While i is less than n:\n        Let mutable sum be 0.0.\n        Let mutable j be 0.\n        While j is less than n:\n            Set sum to sum + aVal(j, i) * item (j + 1) of v.\n            Set j to j + 1.\n        Set item (i + 1) of result to sum.\n        Set i to i + 1.\n    Return result.\n\n## To mulAtav (n: Int, v: Seq of Float, result: Seq of Float, tmp: Seq of Float) -> Seq of Float:\n    Let t be mulAv(n, v, tmp).\n    Return mulAtv(n, t, result).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable u be a new Seq of Float.\nLet mutable v be a new Seq of Float.\nLet mutable tmp be a new Seq of Float.\nLet mutable i be 0.\nWhile i is less than n:\n    Push 1.0 to u.\n    Push 0.0 to v.\n    Push 0.0 to tmp.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than 10:\n    Set v to mulAtav(n, u, v, tmp).\n    Set u to mulAtav(n, v, u, tmp).\n    Set i to i + 1.\nLet mutable vbv be 0.0.\nLet mutable vv be 0.0.\nSet i to 1.\nWhile i is at most n:\n    Set vbv to vbv + item i of u * item i of v.\n    Set vv to vv + item i of v * item i of v.\n    Set i to i + 1.\nLet result be sqrt(vbv / vv).\nShow \"{result:.9}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn aVal(i: i64, j: i64) -> f64 {\n    return (1f64 / (((((((i + j) * ((i + j) + 1)) / 2) + i) + 1)) as f64));\n}\n\n#[inline]\nfn mulAv(n: i64, v: &[f64], out: Vec<f64>) -> Vec<f64> {\n    let mut result = out;\n    for i in 0..n {\n        let mut sum = 0f64;\n        unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n        for j in 0..n {\n            sum = (sum + (((aVal(i, j) * v[j as usize])) as f64));\n        }\n        result[(i) as usize] = sum;\n    }\n    return result;\n}\n\n#[inline]\nfn mulAtv(n: i64, v: &[f64], out: Vec<f64>) -> Vec<f64> {\n    let mut result = out;\n    for i in 0..n {\n        let mut sum = 0f64;\n        unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n        for j in 0..n {\n            sum = (sum + (((aVal(j, i) * v[j as usize])) as f64));\n        }\n        result[(i) as usize] = sum;\n    }\n    return result;\n}\n\n#[inline]\nfn mulAtav(n: i64, v: &[f64], result: Vec<f64>, tmp: Vec<f64>) -> Vec<f64> {\n    let t = mulAv(n, v, tmp.clone());\n    return mulAtv(n, &t, result.clone());\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut u: Vec<f64> = Vec::with_capacity(n as usize);\n    let mut v: Vec<f64> = Vec::with_capacity(n as usize);\n    let mut tmp: Vec<f64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        u.push(1f64);\n        v.push(0f64);\n        tmp.push(0f64);\n    }\n    let mut i = 0;\n    for i in 0..10 {\n        v = mulAtav(n, &u, v, tmp.clone());\n        u = mulAtav(n, &v, u, tmp.clone());\n    }\n    i = 10;\n    let mut vbv = 0f64;\n    let mut vv = 0f64;\n    unsafe { std::hint::assert_unchecked((n as usize) <= u.len()); }\n    unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n    for i in 0..n {\n        vbv = (vbv + (u[i as usize] * v[i as usize]));\n        vv = (vv + (v[i as usize] * v[i as usize]));\n    }\n    let result = (((vbv / vv)) as f64).sqrt();\n    println!(\"{:.9}\", result as f64);\n}",
      "scaling": {
        "500": {
          "c": {
            "mean_ms": 11.2370325000,
            "median_ms": 11.278707500000002000,
            "stddev_ms": 0.34998059370937524000,
            "min_ms": 10.741561000000002000,
            "max_ms": 11.810354000000002000,
            "cv": 0.03114528624077355298,
            "runs": 10,
            "user_ms": 9.845320000000001000,
            "system_ms": 0.7485599999999995000
          },
          "cpp": {
            "mean_ms": 11.600736700000005000,
            "median_ms": 11.745665500000002000,
            "stddev_ms": 0.268028170834108000,
            "min_ms": 11.205311000000003000,
            "max_ms": 11.882229000000003000,
            "cv": 0.02310440946686669342,
            "runs": 10,
            "user_ms": 10.005420000000001000,
            "system_ms": 0.8643599999999995000
          },
          "rust": {
            "mean_ms": 15.4040408000,
            "median_ms": 11.484562000000002000,
            "stddev_ms": 12.560946329730732000,
            "min_ms": 10.996228000000002000,
            "max_ms": 51.14577000,
            "cv": 0.81543190470715528097,
            "runs": 10,
            "user_ms": 9.95362000,
            "system_ms": 0.9172599999999994000
          },
          "zig": {
            "mean_ms": 10.783074100000001000,
            "median_ms": 10.798811500000002000,
            "stddev_ms": 0.20752861874581154000,
            "min_ms": 10.371479000000003000,
            "max_ms": 11.182561000000002000,
            "cv": 0.01924577507501423186,
            "runs": 10,
            "user_ms": 9.54822000,
            "system_ms": 0.6840599999999996000
          },
          "go": {
            "mean_ms": 38.80859069999999000,
            "median_ms": 38.679895000000006000,
            "stddev_ms": 0.7287122268509093000,
            "min_ms": 37.955478000,
            "max_ms": 40.330436000000004000,
            "cv": 0.01877708552943947763,
            "runs": 10,
            "user_ms": 36.58592000,
            "system_ms": 1.4950599999999992000
          },
          "java": {
            "mean_ms": 103.12742430000002000,
            "median_ms": 98.9225615000,
            "stddev_ms": 14.864828191247015000,
            "min_ms": 95.91010300000001000,
            "max_ms": 145.10822800000003000,
            "cv": 0.14414040001624487500,
            "runs": 10,
            "user_ms": 78.32211999999998000,
            "system_ms": 30.502059999999998000
          },
          "js": {
            "mean_ms": 84.08742820000001000,
            "median_ms": 82.33335350000001000,
            "stddev_ms": 4.497365057110043000,
            "min_ms": 80.769562000,
            "max_ms": 96.17210300000001000,
            "cv": 0.05348439301072645322,
            "runs": 10,
            "user_ms": 75.19112000,
            "system_ms": 5.92546000
          },
          "python": {
            "mean_ms": 2167.5883158000,
            "median_ms": 2125.8782069999995000,
            "stddev_ms": 147.38739285866698000,
            "min_ms": 2088.231728000,
            "max_ms": 2582.14977000,
            "cv": 0.06799602663676019986,
            "runs": 10,
            "user_ms": 1952.42242000,
            "system_ms": 20.253159999999996000
          },
          "ruby": {
            "mean_ms": 1538.3488366000002000,
            "median_ms": 1540.5513325000,
            "stddev_ms": 27.993864181088086000,
            "min_ms": 1505.831812000,
            "max_ms": 1583.655437000,
            "cv": 0.01819734478621835515,
            "runs": 10,
            "user_ms": 1487.8732199999998000,
            "system_ms": 19.254859999999995000
          },
          "nim": {
            "mean_ms": 37.5780911000,
            "median_ms": 37.598770000000004000,
            "stddev_ms": 0.6398333983041469000,
            "min_ms": 36.521437000000004000,
            "max_ms": 38.322354000,
            "cv": 0.01702676691589975149,
            "runs": 10,
            "user_ms": 35.76881999999999000,
            "system_ms": 0.8284599999999996000
          },
          "logos_release": {
            "mean_ms": 12.431503300000004000,
            "median_ms": 12.389144500000003000,
            "stddev_ms": 0.20326660913142793000,
            "min_ms": 12.175770000000002000,
            "max_ms": 12.83477000,
            "cv": 0.01635092749655046663,
            "runs": 10,
            "user_ms": 10.834020000000001000,
            "system_ms": 0.9410599999999994000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "pi_leibniz",
      "name": "Pi (Leibniz Series)",
      "description": "Leibniz series for pi. Measures pure FP loop overhead.",
      "reference_size": "1000000",
      "sizes": [
        "100000",
        "1000000",
        "5000000",
        "10000000",
        "50000000",
        "100000000",
        "200000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.0.\nLet mutable sign be 1.0.\nLet mutable k be 0.\nWhile k is less than n:\n    Set sum to sum + sign / (2.0 * k + 1.0).\n    Set sign to 0.0 - sign.\n    Set k to k + 1.\nLet result be sum * 4.0.\nShow \"{result:.15}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0f64;\n    let mut sign = 1f64;\n    for k in 0..n {\n        sum = (sum + (sign / ((2f64 * ((k) as f64)) + 1f64)));\n        sign = (0f64 - sign);\n    }\n    let result = (sum * 4f64);\n    println!(\"{:.15}\", result as f64);\n}",
      "scaling": {
        "1000000": {
          "c": {
            "mean_ms": 1.6235168999999988000,
            "median_ms": 1.6390209999999988000,
            "stddev_ms": 0.22234993069244121000,
            "min_ms": 1.3245214999999984000,
            "max_ms": 1.984937499999999000,
            "cv": 0.13695572290774513917,
            "runs": 10,
            "user_ms": 1.4379000000000002000,
            "system_ms": 0.58742000
          },
          "cpp": {
            "mean_ms": 1.5207456999999987000,
            "median_ms": 1.4804789999999985000,
            "stddev_ms": 0.3214735842000086000,
            "min_ms": 0.9709374999999987000,
            "max_ms": 2.053437499999999000,
            "cv": 0.21139207179741417306,
            "runs": 10,
            "user_ms": 1.4194000000000001000,
            "system_ms": 0.50362000
          },
          "rust": {
            "mean_ms": 1.7722334999999989000,
            "median_ms": 1.697853999999999000,
            "stddev_ms": 0.167542522958601000,
            "min_ms": 1.6089374999999984000,
            "max_ms": 2.0589794999999987000,
            "cv": 0.09453749912672404849,
            "runs": 10,
            "user_ms": 1.6675000,
            "system_ms": 0.49672000
          },
          "zig": {
            "mean_ms": 1.6106832999999987000,
            "median_ms": 1.5797919999999987000,
            "stddev_ms": 0.3197998076497928000,
            "min_ms": 1.1207284999999985000,
            "max_ms": 2.258520499999999000,
            "cv": 0.19854915466609299178,
            "runs": 10,
            "user_ms": 1.4959999999999997000,
            "system_ms": 0.5519199999999998000
          },
          "go": {
            "mean_ms": 2.820745899999999000,
            "median_ms": 2.6356044999999986000,
            "stddev_ms": 0.542835391623403000,
            "min_ms": 2.144021499999999000,
            "max_ms": 3.9719794999999985000,
            "cv": 0.19244391762597375128,
            "runs": 10,
            "user_ms": 2.0132000,
            "system_ms": 1.1564199999999998000
          },
          "java": {
            "mean_ms": 81.9958249000,
            "median_ms": 79.599771000,
            "stddev_ms": 13.456389484810108000,
            "min_ms": 64.8855625000,
            "max_ms": 110.6736045000,
            "cv": 0.16411066662505285680,
            "runs": 10,
            "user_ms": 48.07890000000001000,
            "system_ms": 29.549719999999995000
          },
          "js": {
            "mean_ms": 50.0472958000,
            "median_ms": 48.272604000000004000,
            "stddev_ms": 4.23318470703798000,
            "min_ms": 46.697062500000004000,
            "max_ms": 58.6248955000,
            "cv": 0.08458368507970374695,
            "runs": 10,
            "user_ms": 38.024199999999994000,
            "system_ms": 5.33342000
          },
          "python": {
            "mean_ms": 262.3851624000,
            "median_ms": 260.633729000,
            "stddev_ms": 13.104382503415711000,
            "min_ms": 246.55672950000004000,
            "max_ms": 291.1034375000,
            "cv": 0.04994330618222378187,
            "runs": 10,
            "user_ms": 129.029000,
            "system_ms": 12.162419999999998000
          },
          "ruby": {
            "mean_ms": 150.51517900000003000,
            "median_ms": 148.21843700000004000,
            "stddev_ms": 9.623429588219892000,
            "min_ms": 144.73589550000002000,
            "max_ms": 176.99152050000003000,
            "cv": 0.06393660527899242694,
            "runs": 10,
            "user_ms": 128.97469999999997000,
            "system_ms": 15.28192000
          },
          "nim": {
            "mean_ms": 1.7440583999999988000,
            "median_ms": 1.6542084999999988000,
            "stddev_ms": 0.28017394916113173000,
            "min_ms": 1.3648964999999989000,
            "max_ms": 2.2391044999999984000,
            "cv": 0.16064482081628225452,
            "runs": 10,
            "user_ms": 1.5093000000000003000,
            "system_ms": 0.5640199999999999000
          },
          "logos_release": {
            "mean_ms": 3.088237399999999000,
            "median_ms": 3.066957999999999000,
            "stddev_ms": 0.26396022843116606000,
            "min_ms": 2.738478499999999000,
            "max_ms": 3.5573544999999993000,
            "cv": 0.08547277758865498665,
            "runs": 10,
            "user_ms": 2.5088000000000007000,
            "system_ms": 0.8823199999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "gcd",
      "name": "GCD Sum",
      "description": "GCD sum via Euclidean algorithm. Measures modulo-heavy tight loops.",
      "reference_size": "1000",
      "sizes": [
        "500",
        "1000",
        "2000",
        "3000",
        "5000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To gcd (a: Int, b: Int) -> Int:\n    Let mutable x be a.\n    Let mutable y be b.\n    While y is greater than 0:\n        Let temp be y.\n        Set y to x % y.\n        Set x to temp.\n    Return x.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Let mutable j be i.\n    While j is at most n:\n        Set sum to sum + gcd(i, j).\n        Set j to j + 1.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn gcd(a: i64, b: i64) -> i64 {\n    let mut x = a;\n    let mut y = b;\n    while (y > 0) {\n        let temp = y;\n        y = (x % y);\n        x = temp;\n    }\n    return x;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0;\n    for i in 1..(n + 1) {\n        for j in i..(n + 1) {\n            sum = (sum + gcd(i, j));\n        }\n    }\n    show(&sum);\n}",
      "scaling": {
        "1000": {
          "c": {
            "mean_ms": 8.035278259999999000,
            "median_ms": 8.05494476000,
            "stddev_ms": 0.19925946811534705000,
            "min_ms": 7.687173760000001000,
            "max_ms": 8.34159076000,
            "cv": 0.02479807937794391638,
            "runs": 10,
            "user_ms": 8.11818000,
            "system_ms": 0.5816200000000001000
          },
          "cpp": {
            "mean_ms": 8.47728656000,
            "median_ms": 8.45071526000,
            "stddev_ms": 0.2466834718188922000,
            "min_ms": 8.08738176000,
            "max_ms": 8.88554976000,
            "cv": 0.02909934329492480905,
            "runs": 10,
            "user_ms": 8.297279999999999000,
            "system_ms": 0.6825200000000003000
          },
          "rust": {
            "mean_ms": 8.387490760000001000,
            "median_ms": 8.47592426000,
            "stddev_ms": 0.2799263104314736000,
            "min_ms": 7.82779876000,
            "max_ms": 8.69325776000,
            "cv": 0.03337426155703729998,
            "runs": 10,
            "user_ms": 8.41548000,
            "system_ms": 0.5764200000000002000
          },
          "zig": {
            "mean_ms": 11.212795059999999000,
            "median_ms": 10.25509076000,
            "stddev_ms": 2.513166016215538000,
            "min_ms": 9.596715760000001000,
            "max_ms": 17.44113276000,
            "cv": 0.22413376885669559576,
            "runs": 10,
            "user_ms": 10.11628000,
            "system_ms": 0.5495200000000002000
          },
          "go": {
            "mean_ms": 8.83505736000,
            "median_ms": 8.85221626000,
            "stddev_ms": 0.24157561953153415000,
            "min_ms": 8.51900676000,
            "max_ms": 9.250298760000001000,
            "cv": 0.02734284676240451142,
            "runs": 10,
            "user_ms": 8.62728000,
            "system_ms": 0.9314200000000002000
          },
          "java": {
            "mean_ms": 58.81354886000001000,
            "median_ms": 58.194090760000004000,
            "stddev_ms": 1.930869271875028000,
            "min_ms": 57.03421576000001000,
            "max_ms": 63.87275676000,
            "cv": 0.03283034792665336998,
            "runs": 10,
            "user_ms": 31.40558000,
            "system_ms": 27.06202000
          },
          "js": {
            "mean_ms": 57.59284916000,
            "median_ms": 56.838320260000005000,
            "stddev_ms": 2.9451969490038865000,
            "min_ms": 55.46846576000,
            "max_ms": 65.68467375999999000,
            "cv": 0.05113824011070832912,
            "runs": 10,
            "user_ms": 48.78568000,
            "system_ms": 5.11662000
          },
          "python": {
            "mean_ms": 310.61247006000003000,
            "median_ms": 304.77617426000003000,
            "stddev_ms": 19.894154239705083000,
            "min_ms": 287.67175776000004000,
            "max_ms": 351.83171576000005000,
            "cv": 0.06404815053259835977,
            "runs": 10,
            "user_ms": 162.82988000,
            "system_ms": 13.98462000
          },
          "ruby": {
            "mean_ms": 184.12855346000,
            "median_ms": 180.02040326000002000,
            "stddev_ms": 12.671523106188002000,
            "min_ms": 176.28175776000002000,
            "max_ms": 219.36567476000002000,
            "cv": 0.06881889238835929754,
            "runs": 10,
            "user_ms": 158.18538000,
            "system_ms": 16.93162000
          },
          "nim": {
            "mean_ms": 8.73771576000,
            "median_ms": 8.67675776000,
            "stddev_ms": 0.6214999763243048000,
            "min_ms": 7.89021576000,
            "max_ms": 10.265048760000001000,
            "cv": 0.07112842685607168343,
            "runs": 10,
            "user_ms": 8.43058000,
            "system_ms": 0.7806200000000003000
          },
          "logos_release": {
            "mean_ms": 10.23831146000,
            "median_ms": 10.16250726000,
            "stddev_ms": 0.32960419386390984000,
            "min_ms": 9.59446576000,
            "max_ms": 10.61196576000,
            "cv": 0.03219321810550876130,
            "runs": 10,
            "user_ms": 9.491379999999999000,
            "system_ms": 1.1425200000000002000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "collatz",
      "name": "Collatz Conjecture",
      "description": "Collatz step counting. Measures unpredictable branching.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable total be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Let mutable k be i.\n    While k is not 1:\n        If k % 2 equals 0:\n            Set k to k / 2.\n        Otherwise:\n            Set k to 3 * k + 1.\n        Set total to total + 1.\n    Set i to i + 1.\nShow total.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut total = 0;\n    for i in 1..(n + 1) {\n        let mut k = i;\n        while (k != 1) {\n            if ((k % 2) == 0) {\n                k = (k / 2);\n            } else {\n                k = ((3 * k) + 1);\n            }\n            total = (total + 1);\n        }\n    }\n    show(&total);\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 21.86452178000,
            "median_ms": 17.74181788000,
            "stddev_ms": 13.656497598906867000,
            "min_ms": 15.528442879999998000,
            "max_ms": 60.343775880000006000,
            "cv": 0.62459621739354900265,
            "runs": 10,
            "user_ms": 15.70332000,
            "system_ms": 1.2789000
          },
          "cpp": {
            "mean_ms": 19.593750779999995000,
            "median_ms": 19.83102588000,
            "stddev_ms": 1.4253154406295447000,
            "min_ms": 16.859275879999996000,
            "max_ms": 21.755983880000003000,
            "cv": 0.07274336887475431407,
            "runs": 10,
            "user_ms": 16.10902000,
            "system_ms": 1.8927000
          },
          "rust": {
            "mean_ms": 15.20528008000,
            "median_ms": 14.93150538000,
            "stddev_ms": 0.860546242669258000,
            "min_ms": 14.251192880000001000,
            "max_ms": 16.720983879999998000,
            "cv": 0.05659522469442456991,
            "runs": 10,
            "user_ms": 12.37102000,
            "system_ms": 1.5029000
          },
          "zig": {
            "mean_ms": 15.99250088000,
            "median_ms": 12.22508838000,
            "stddev_ms": 8.136847278681686000,
            "min_ms": 11.45469288000,
            "max_ms": 32.01990088000,
            "cv": 0.50879142291356784968,
            "runs": 10,
            "user_ms": 11.72602000,
            "system_ms": 0.8108000000000001000
          },
          "go": {
            "mean_ms": 17.88516768000,
            "median_ms": 17.847192879999998000,
            "stddev_ms": 0.34604814183058434000,
            "min_ms": 17.44577588000,
            "max_ms": 18.49644288000,
            "cv": 0.01934833086399021896,
            "runs": 10,
            "user_ms": 16.96452000,
            "system_ms": 1.2523999999999997000
          },
          "java": {
            "mean_ms": 72.40624648000002000,
            "median_ms": 70.44856738000,
            "stddev_ms": 7.499440075365098000,
            "min_ms": 68.21323388000,
            "max_ms": 93.46252588000001000,
            "cv": 0.10357449032296662049,
            "runs": 10,
            "user_ms": 41.14052000,
            "system_ms": 27.9844000
          },
          "js": {
            "mean_ms": 67.26492988000,
            "median_ms": 63.35915087999999000,
            "stddev_ms": 11.785069742071799000,
            "min_ms": 62.141816880000006000,
            "max_ms": 100.69735888000,
            "cv": 0.17520377651617644115,
            "runs": 10,
            "user_ms": 54.09712000,
            "system_ms": 5.3317000
          },
          "python": {
            "mean_ms": 1386.37125908000,
            "median_ms": 1389.0650468799999000,
            "stddev_ms": 60.737408290113384000,
            "min_ms": 1292.9436508799999000,
            "max_ms": 1485.5930678799998000,
            "cv": 0.04381034870155841574,
            "runs": 10,
            "user_ms": 1203.3926199999998000,
            "system_ms": 18.278900000000004000
          },
          "ruby": {
            "mean_ms": 643.3823133800001000,
            "median_ms": 634.23735938000,
            "stddev_ms": 23.7475248248516000,
            "min_ms": 626.97440088000,
            "max_ms": 700.3515678800001000,
            "cv": 0.03691044085451200270,
            "runs": 10,
            "user_ms": 603.5954199999999000,
            "system_ms": 19.830899999999995000
          },
          "nim": {
            "mean_ms": 23.778925980000004000,
            "median_ms": 19.48615088000,
            "stddev_ms": 14.0718007930674000,
            "min_ms": 18.66156788000,
            "max_ms": 63.81015088000,
            "cv": 0.59177613004485232990,
            "runs": 10,
            "user_ms": 18.894519999999995000,
            "system_ms": 0.8395999999999999000
          },
          "logos_release": {
            "mean_ms": 13.48956328000,
            "median_ms": 13.48273438000,
            "stddev_ms": 0.27026030664659427000,
            "min_ms": 13.014733879999999000,
            "max_ms": 13.859691879999999000,
            "cv": 0.02003477066209324087,
            "runs": 10,
            "user_ms": 12.640519999999999000,
            "system_ms": 1.0680999999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "primes",
      "name": "Primes (Trial Division)",
      "description": "Trial division prime counting. Measures nested loops with early exit.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable count be 0.\nLet mutable i be 2.\nWhile i is at most n:\n    Let mutable isPrime be 1.\n    Let mutable d be 2.\n    While d * d is at most i:\n        If i % d equals 0:\n            Set isPrime to 0.\n            Break.\n        Set d to d + 1.\n    If isPrime equals 1:\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut count = 0;\n    for i in 2..(n + 1) {\n        let mut isPrime = 1;\n        let mut d = 2;\n        while ((d * d) <= i) {\n            if ((i % d) == 0) {\n                isPrime = 0;\n                break;\n            }\n            d = (d + 1);\n        }\n        if (isPrime == 1) {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 2.750137500000001000,
            "median_ms": 2.566995700000001000,
            "stddev_ms": 0.5373872700596638000,
            "min_ms": 2.2329747000000007000,
            "max_ms": 3.960516700000001000,
            "cv": 0.19540378255984059145,
            "runs": 10,
            "user_ms": 1.6099999999999992000,
            "system_ms": 0.6445199999999998000
          },
          "cpp": {
            "mean_ms": 2.4826626000000007000,
            "median_ms": 2.398578700000001000,
            "stddev_ms": 0.32504671322081634000,
            "min_ms": 1.977016700000001000,
            "max_ms": 3.121683700000001000,
            "cv": 0.13092665641348778055,
            "runs": 10,
            "user_ms": 1.5914999999999996000,
            "system_ms": 0.5161199999999998000
          },
          "rust": {
            "mean_ms": 7.423391600000001000,
            "median_ms": 2.875453700000001000,
            "stddev_ms": 13.31714287858203000,
            "min_ms": 1.901516700000001000,
            "max_ms": 44.9732247000,
            "cv": 1.79394319957228555826,
            "runs": 10,
            "user_ms": 1.8430999999999996000,
            "system_ms": 0.5832199999999996000
          },
          "zig": {
            "mean_ms": 2.3552000000000013000,
            "median_ms": 2.456287200000001000,
            "stddev_ms": 0.36579357909559683000,
            "min_ms": 1.782308700000001000,
            "max_ms": 2.8475997000000012000,
            "cv": 0.15531317047197547048,
            "runs": 10,
            "user_ms": 1.5218999999999994000,
            "system_ms": 0.47021999999999976000
          },
          "go": {
            "mean_ms": 3.1180208000000007000,
            "median_ms": 3.1255372000000008000,
            "stddev_ms": 0.2726730155949714000,
            "min_ms": 2.706974700000001000,
            "max_ms": 3.610724700000001000,
            "cv": 0.08745067242494704935,
            "runs": 10,
            "user_ms": 1.8049999999999993000,
            "system_ms": 0.9120199999999997000
          },
          "java": {
            "mean_ms": 63.77584580000001000,
            "median_ms": 56.64689170000001000,
            "stddev_ms": 16.731596235430978000,
            "min_ms": 52.1171417000,
            "max_ms": 99.35026670000001000,
            "cv": 0.26235004844782435447,
            "runs": 10,
            "user_ms": 25.1202000,
            "system_ms": 28.662919999999998000
          },
          "js": {
            "mean_ms": 48.17352070000001000,
            "median_ms": 48.201037200000005000,
            "stddev_ms": 0.5825032410174027000,
            "min_ms": 47.2839327000,
            "max_ms": 49.455808700000006000,
            "cv": 0.01209177225482302311,
            "runs": 10,
            "user_ms": 38.063000,
            "system_ms": 5.189419999999999000
          },
          "python": {
            "mean_ms": 268.0898292000,
            "median_ms": 257.79443320000006000,
            "stddev_ms": 34.160470160492694000,
            "min_ms": 243.40672470000002000,
            "max_ms": 358.48797470000004000,
            "cv": 0.12742173122505273318,
            "runs": 10,
            "user_ms": 123.29729999999998000,
            "system_ms": 13.25542000
          },
          "ruby": {
            "mean_ms": 114.20596240000003000,
            "median_ms": 111.01662070000001000,
            "stddev_ms": 9.305234035570242000,
            "min_ms": 106.26980770000001000,
            "max_ms": 136.8513077000,
            "cv": 0.08147765528194734214,
            "runs": 10,
            "user_ms": 86.25359999999999000,
            "system_ms": 17.81252000
          },
          "nim": {
            "mean_ms": 2.9780087000000005000,
            "median_ms": 2.9391422000000006000,
            "stddev_ms": 0.19007731946120134000,
            "min_ms": 2.755308700000001000,
            "max_ms": 3.270225700000001000,
            "cv": 0.06382698595245920808,
            "runs": 10,
            "user_ms": 1.8813999999999994000,
            "system_ms": 0.6490199999999996000
          },
          "logos_release": {
            "mean_ms": 12.244995800000002000,
            "median_ms": 5.1681627000,
            "stddev_ms": 18.66715322865532000,
            "min_ms": 3.549266700000001000,
            "max_ms": 64.41326670000001000,
            "cv": 1.52447199930075247155,
            "runs": 10,
            "user_ms": 3.0448999999999997000,
            "system_ms": 1.9818199999999996000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "sieve",
      "name": "Sieve of Eratosthenes",
      "description": "Classic prime sieve. Measures indexed array mutation and tight loops.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "100000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To sieve (limit: Int) -> Int:\n    Let mutable flags be a new Seq of Bool.\n    Let mutable i be 0.\n    While i is at most limit:\n        Push false to flags.\n        Set i to i + 1.\n    Let mutable count be 0.\n    Set i to 2.\n    While i is at most limit:\n        If item (i + 1) of flags equals false:\n            Set count to count + 1.\n            Let mutable j be i * i.\n            While j is at most limit:\n                Set item (j + 1) of flags to true.\n                Set j to j + i.\n        Set i to i + 1.\n    Return count.\n\n## Main\nLet arguments be args().\nLet limit be parseInt(item 2 of arguments).\nShow sieve(limit).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn sieve(limit: i64) -> i64 {\n    let mut flags: Vec<bool> = vec![false; (limit + 1) as usize];\n    let mut i = 0;\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked((limit as usize) <= flags.len()); }\n    for i in 2..(limit + 1) {\n        if (flags[i as usize] == false) {\n            count = (count + 1);\n            let mut j = (i * i);\n            while (j <= limit) {\n                flags[(j) as usize] = true;\n                j = (j + i);\n            }\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let arguments = args();\n    let limit = parseInt(arguments[1].clone());\n    show(&sieve(limit));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 2.528066960000001000,
            "median_ms": 2.3194924600000006000,
            "stddev_ms": 0.7424262857806529000,
            "min_ms": 1.5834084600000005000,
            "max_ms": 3.7704914600000007000,
            "cv": 0.29367350530171582414,
            "runs": 10,
            "user_ms": 0.7947599999999999000,
            "system_ms": 0.8683200000000002000
          },
          "cpp": {
            "mean_ms": 2.9332583600000005000,
            "median_ms": 2.4415749600000002000,
            "stddev_ms": 1.4060195685039736000,
            "min_ms": 1.5078664600000008000,
            "max_ms": 6.286575460000001000,
            "cv": 0.47933710431970723517,
            "runs": 10,
            "user_ms": 0.8512599999999997000,
            "system_ms": 0.9546200000000003000
          },
          "rust": {
            "mean_ms": 10.35732106000,
            "median_ms": 4.606908460000001000,
            "stddev_ms": 12.6960406561039000,
            "min_ms": 2.2296584600000006000,
            "max_ms": 40.68628346000,
            "cv": 1.22580352415027868219,
            "runs": 10,
            "user_ms": 1.25816000,
            "system_ms": 2.00252000
          },
          "zig": {
            "mean_ms": 2.18090006000,
            "median_ms": 2.0684294600000004000,
            "stddev_ms": 0.562859217080119000,
            "min_ms": 1.5638664600000005000,
            "max_ms": 3.494950460000001000,
            "cv": 0.25808574514877999498,
            "runs": 10,
            "user_ms": 0.8708599999999999000,
            "system_ms": 0.7008200000000002000
          },
          "go": {
            "mean_ms": 3.464866760000001000,
            "median_ms": 3.5639499600000004000,
            "stddev_ms": 0.422529037346955000,
            "min_ms": 2.7015334600000006000,
            "max_ms": 4.024283460000001000,
            "cv": 0.12194669134894955615,
            "runs": 10,
            "user_ms": 1.3750599999999998000,
            "system_ms": 1.4659200000000001000
          },
          "java": {
            "mean_ms": 69.91978766000001000,
            "median_ms": 67.37238796000,
            "stddev_ms": 12.799074134831437000,
            "min_ms": 62.57178346000,
            "max_ms": 105.48465846000,
            "cv": 0.18305367569291950520,
            "runs": 10,
            "user_ms": 22.57416000,
            "system_ms": 28.460219999999998000
          },
          "js": {
            "mean_ms": 52.238250060000005000,
            "median_ms": 48.81272046000,
            "stddev_ms": 8.445934403590186000,
            "min_ms": 47.18365846000,
            "max_ms": 72.79611646000,
            "cv": 0.16168103628833896645,
            "runs": 10,
            "user_ms": 39.506759999999995000,
            "system_ms": 5.483820000000001000
          },
          "python": {
            "mean_ms": 189.47234166000,
            "median_ms": 190.71409596000,
            "stddev_ms": 19.14394876885445000,
            "min_ms": 158.97899246000,
            "max_ms": 212.67307446000,
            "cv": 0.10103822331603124390,
            "runs": 10,
            "user_ms": 32.91395999999999000,
            "system_ms": 13.81832000
          },
          "ruby": {
            "mean_ms": 81.16484176000001000,
            "median_ms": 78.68430396000001000,
            "stddev_ms": 10.588696723420039000,
            "min_ms": 69.22640846000001000,
            "max_ms": 103.84569946000001000,
            "cv": 0.13045915563699655878,
            "runs": 10,
            "user_ms": 50.555559999999986000,
            "system_ms": 17.83772000
          },
          "nim": {
            "mean_ms": 1.4953958600000005000,
            "median_ms": 1.5568459600000008000,
            "stddev_ms": 0.2896146148219888000,
            "min_ms": 0.9721584600000006000,
            "max_ms": 1.9503244600000006000,
            "cv": 0.19367086840937803797,
            "runs": 10,
            "user_ms": 0.7432599999999999000,
            "system_ms": 0.4199200000000001000
          },
          "logos_release": {
            "mean_ms": 2.7567959600000003000,
            "median_ms": 2.8085959600000006000,
            "stddev_ms": 0.3488420741294612000,
            "min_ms": 2.2584504600000003000,
            "max_ms": 3.332324460000001000,
            "cv": 0.12653895289713830037,
            "runs": 10,
            "user_ms": 1.6262599999999996000,
            "system_ms": 0.6806200000000004000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "matrix_mult",
      "name": "Matrix Multiply",
      "description": "O(n^3) matrix multiply. Measures cache locality and triple-nested loops.",
      "reference_size": "100",
      "sizes": [
        "50",
        "100",
        "200",
        "300",
        "500",
        "700"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable a be a new Seq of Int.\nLet mutable b be a new Seq of Int.\nLet mutable c be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Let mutable j be 0.\n    While j is less than n:\n        Push (i * n + j) % 100 to a.\n        Push (j * n + i) % 100 to b.\n        Push 0 to c.\n        Set j to j + 1.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n:\n    Let mutable k be 0.\n    While k is less than n:\n        Let mutable j be 0.\n        While j is less than n:\n            Let idx be i * n + j + 1.\n            Set item idx of c to (item idx of c + item (i * n + k + 1) of a * item (k * n + j + 1) of b) % 1000000007.\n            Set j to j + 1.\n        Set k to k + 1.\n    Set i to i + 1.\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n * n:\n    Set checksum to (checksum + item i of c) % 1000000007.\n    Set i to i + 1.\nShow checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut a = Seq::<i64>::default();\n    let mut b = Seq::<i64>::default();\n    let mut c = Seq::<i64>::default();\n    for i in 0..n {\n        for j in 0..n {\n            a.push((((i * n) + j) % 100));\n            b.push((((j * n) + i) % 100));\n            c.push(0);\n        }\n    }\n    let mut i = 0;\n    for i in 0..n {\n        for k in 0..n {\n            unsafe { std::hint::assert_unchecked((n as usize) <= b.len()); }\n            for j in 0..n {\n                let idx = (((i * n) + j) + 1);\n                c[(idx - 1) as usize] = ((c[(idx - 1) as usize] + (a[(((i * n) + k)) as usize] * b[(((k * n) + j)) as usize])) % 1000000007);\n            }\n        }\n    }\n    i = (0_i64).max(n);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked(((n * n) as usize) <= c.len()); }\n    for i in 0..(n * n) {\n        checksum = ((checksum + c[i as usize]) % 1000000007);\n    }\n    show(&checksum);\n}",
      "scaling": {
        "100": {
          "c": {
            "mean_ms": 2.7607256600000003000,
            "median_ms": 2.36590866000,
            "stddev_ms": 1.5264686944267626000,
            "min_ms": 1.7137421599999997000,
            "max_ms": 7.026451160000001000,
            "cv": 0.55292299287237487919,
            "runs": 10,
            "user_ms": 1.30326000,
            "system_ms": 0.68296000
          },
          "cpp": {
            "mean_ms": 3.0946675599999992000,
            "median_ms": 2.9436176599999995000,
            "stddev_ms": 1.150813381994685000,
            "min_ms": 2.02253416000,
            "max_ms": 6.19295016000,
            "cv": 0.37186979204793334812,
            "runs": 10,
            "user_ms": 1.32856000,
            "system_ms": 0.82406000
          },
          "rust": {
            "mean_ms": 3.2450050599999994000,
            "median_ms": 3.0791176599999997000,
            "stddev_ms": 0.9763723657582297000,
            "min_ms": 2.42303416000,
            "max_ms": 5.89420016000,
            "cv": 0.30088469746738388153,
            "runs": 10,
            "user_ms": 1.7522599999999996000,
            "system_ms": 0.65486000
          },
          "zig": {
            "mean_ms": 4.47157176000,
            "median_ms": 2.85532566000,
            "stddev_ms": 5.4856316331266565000,
            "min_ms": 2.3865761599999994000,
            "max_ms": 20.068618160000003000,
            "cv": 1.22677929094146003373,
            "runs": 10,
            "user_ms": 1.5957599999999999000,
            "system_ms": 0.6357600000000001000
          },
          "go": {
            "mean_ms": 3.80940076000,
            "median_ms": 3.69917966000,
            "stddev_ms": 0.2696075703722808000,
            "min_ms": 3.4729091599999995000,
            "max_ms": 4.317326159999999000,
            "cv": 0.07077427326713737517,
            "runs": 10,
            "user_ms": 2.3159599999999997000,
            "system_ms": 1.0165600000000001000
          },
          "java": {
            "mean_ms": 67.72880496000,
            "median_ms": 67.91138865999999000,
            "stddev_ms": 6.590106070901347000,
            "min_ms": 52.617867160000005000,
            "max_ms": 78.11270115999999000,
            "cv": 0.09730137826576745493,
            "runs": 10,
            "user_ms": 27.824459999999995000,
            "system_ms": 28.45526000
          },
          "js": {
            "mean_ms": 53.35723846000,
            "median_ms": 51.96282566000,
            "stddev_ms": 3.6611407561317395000,
            "min_ms": 50.52682616000,
            "max_ms": 62.68370116000,
            "cv": 0.06861563420071608218,
            "runs": 10,
            "user_ms": 42.47236000,
            "system_ms": 5.64106000
          },
          "python": {
            "mean_ms": 470.99987175999997000,
            "median_ms": 467.47045066000004000,
            "stddev_ms": 21.803103398724908000,
            "min_ms": 443.66895116000005000,
            "max_ms": 516.7403671599999000,
            "cv": 0.04629110262228430927,
            "runs": 10,
            "user_ms": 328.96245999999996000,
            "system_ms": 13.31966000
          },
          "ruby": {
            "mean_ms": 199.35106326000002000,
            "median_ms": 197.50890866000,
            "stddev_ms": 9.714613590152917000,
            "min_ms": 189.03811816000002000,
            "max_ms": 221.02882616000002000,
            "cv": 0.04873118523317233510,
            "runs": 10,
            "user_ms": 170.73135999999997000,
            "system_ms": 16.536259999999997000
          },
          "nim": {
            "mean_ms": 6.4220551600000005000,
            "median_ms": 6.442013660000001000,
            "stddev_ms": 0.5045963842511491000,
            "min_ms": 5.71620116000,
            "max_ms": 7.3280761600000004000,
            "cv": 0.07857241516610534075,
            "runs": 10,
            "user_ms": 4.673859999999999000,
            "system_ms": 0.98526000
          },
          "logos_release": {
            "mean_ms": 4.50729666000,
            "median_ms": 4.26020116000,
            "stddev_ms": 0.6815871833387208000,
            "min_ms": 3.96595016000,
            "max_ms": 5.99932616000,
            "cv": 0.15121862055086491688,
            "runs": 10,
            "user_ms": 2.77336000,
            "system_ms": 1.10626000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "prefix_sum",
      "name": "Prefix Sum",
      "description": "Sequential prefix sum scan. Measures read-modify-write bandwidth.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push ((seed / 65536) % 32768) % 1000 to arr.\n    Set i to i + 1.\nSet i to 2.\nWhile i is at most n:\n    Set item i of arr to (item i of arr + item (i - 1) of arr) % 1000000007.\n    Set i to i + 1.\nShow item n of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push((((seed / 65536) % 32768) % 1000));\n    }\n    let mut i = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 2..(n + 1) {\n        arr[(i - 1) as usize] = ((arr[(i - 1) as usize] + arr[((i - 1) - 1) as usize]) % 1000000007);\n    }\n    show(&arr[(n - 1) as usize]);\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 0.9414144400000004000,
            "median_ms": 0.8036349400000007000,
            "stddev_ms": 0.5033201460072129000,
            "min_ms": 0.09811494000000042000,
            "max_ms": 1.78103094000,
            "cv": 0.53464247479273069801,
            "runs": 10,
            "user_ms": 0.9680399999999999000,
            "system_ms": 0.5210399999999997000
          },
          "cpp": {
            "mean_ms": 1.6876474400000004000,
            "median_ms": 1.3812599400000003000,
            "stddev_ms": 0.994904283115634000,
            "min_ms": 1.0193219400000007000,
            "max_ms": 4.326530940000001000,
            "cv": 0.58952140093646203983,
            "runs": 10,
            "user_ms": 1.0430399999999999000,
            "system_ms": 0.6600399999999998000
          },
          "rust": {
            "mean_ms": 2.33035584000,
            "median_ms": 2.1442809400000003000,
            "stddev_ms": 0.6525376339094168000,
            "min_ms": 1.5751979400000001000,
            "max_ms": 3.412738940000001000,
            "cv": 0.28001630596871282971,
            "runs": 10,
            "user_ms": 1.4878399999999998000,
            "system_ms": 0.8526399999999997000
          },
          "zig": {
            "mean_ms": 1.3855641400000005000,
            "median_ms": 1.0540099400000004000,
            "stddev_ms": 0.992288621019644000,
            "min_ms": 0.8451559399999999000,
            "max_ms": 4.17294794000,
            "cv": 0.71616216988673194293,
            "runs": 10,
            "user_ms": 1.1123400000000003000,
            "system_ms": 0.5560399999999998000
          },
          "go": {
            "mean_ms": 2.2399350400000005000,
            "median_ms": 2.2010514400000003000,
            "stddev_ms": 0.27832223781215675000,
            "min_ms": 1.7795309400000002000,
            "max_ms": 2.7107389400000004000,
            "cv": 0.12425460240675403152,
            "runs": 10,
            "user_ms": 1.8888400000000004000,
            "system_ms": 0.9977399999999998000
          },
          "java": {
            "mean_ms": 77.60855184000,
            "median_ms": 67.74250994000,
            "stddev_ms": 28.878276549032637000,
            "min_ms": 60.63453094000001000,
            "max_ms": 158.10482294000,
            "cv": 0.37210173188863147584,
            "runs": 10,
            "user_ms": 24.008739999999997000,
            "system_ms": 30.127539999999998000
          },
          "js": {
            "mean_ms": 50.50399334000001000,
            "median_ms": 48.34848894000,
            "stddev_ms": 4.991803287677316000,
            "min_ms": 46.88923894000001000,
            "max_ms": 60.84086494000001000,
            "cv": 0.09883977399711329463,
            "runs": 10,
            "user_ms": 38.91114000,
            "system_ms": 5.61614000
          },
          "python": {
            "mean_ms": 251.64683084000006000,
            "median_ms": 194.69250994000,
            "stddev_ms": 131.23777923578087000,
            "min_ms": 182.73903094000002000,
            "max_ms": 604.7668639400001000,
            "cv": 0.52151572423029382232,
            "runs": 10,
            "user_ms": 58.92814000,
            "system_ms": 14.487239999999998000
          },
          "ruby": {
            "mean_ms": 77.38579754000001000,
            "median_ms": 73.09494744000,
            "stddev_ms": 13.214372179129857000,
            "min_ms": 71.93023894000,
            "max_ms": 114.82940594000,
            "cv": 0.17075965615395343113,
            "runs": 10,
            "user_ms": 54.00174000,
            "system_ms": 15.02144000
          },
          "nim": {
            "mean_ms": 1.3582850400000001000,
            "median_ms": 1.3250519400000004000,
            "stddev_ms": 0.30572196643989736000,
            "min_ms": 0.9107809400000005000,
            "max_ms": 1.8593229400000006000,
            "cv": 0.22507938866785821147,
            "runs": 10,
            "user_ms": 1.4300399999999998000,
            "system_ms": 0.5697399999999998000
          },
          "logos_release": {
            "mean_ms": 2.37558504000,
            "median_ms": 2.35967644000,
            "stddev_ms": 0.21613771317917257000,
            "min_ms": 1.9947809400000004000,
            "max_ms": 2.745321940000001000,
            "cv": 0.09098294085029789967,
            "runs": 10,
            "user_ms": 2.20234000,
            "system_ms": 0.7704399999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "array_reverse",
      "name": "Array Reverse",
      "description": "Two-pointer in-place reversal. Measures strided cache access.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nLet mutable lo be 1.\nLet mutable hi be n.\nWhile lo is less than hi:\n    Let tmp be item lo of arr.\n    Set item lo of arr to item hi of arr.\n    Set item hi of arr to tmp.\n    Set lo to lo + 1.\n    Set hi to hi - 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + item (n / 2 + 1) of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut lo = 1;\n    let mut hi = n;\n    unsafe { std::hint::assert_unchecked((hi as usize) <= arr.len()); }\n    while (lo < hi) {\n        let __swap_tmp = arr[(lo - 1) as usize];\n        arr[(lo - 1) as usize] = arr[(hi - 1) as usize];\n        arr[(hi - 1) as usize] = __swap_tmp;\n        lo = (lo + 1);\n        hi = (hi - 1);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", arr[((n / 2)) as usize]));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 1.6194231400000008000,
            "median_ms": 1.5337396400000006000,
            "stddev_ms": 0.37081646090545193000,
            "min_ms": 1.1720521400000006000,
            "max_ms": 2.530344140000001000,
            "cv": 0.22898058681899021574,
            "runs": 10,
            "user_ms": 0.6529799999999999000,
            "system_ms": 0.5665199999999999000
          },
          "cpp": {
            "mean_ms": 1.564910840000001000,
            "median_ms": 1.485365140000001000,
            "stddev_ms": 0.3375493862513718000,
            "min_ms": 1.1171771400000012000,
            "max_ms": 2.317094140000001000,
            "cv": 0.21569879741606977704,
            "runs": 10,
            "user_ms": 0.6665800000000002000,
            "system_ms": 0.52662000
          },
          "rust": {
            "mean_ms": 2.0503692400000006000,
            "median_ms": 2.012114640000001000,
            "stddev_ms": 0.3507474865070154000,
            "min_ms": 1.4447191400000004000,
            "max_ms": 2.520511140000001000,
            "cv": 0.17106552306013686459,
            "runs": 10,
            "user_ms": 0.9629800000000001000,
            "system_ms": 0.6713200000000001000
          },
          "zig": {
            "mean_ms": 1.5836692400000006000,
            "median_ms": 1.561531640000001000,
            "stddev_ms": 0.3226558372006549000,
            "min_ms": 1.0105941400000008000,
            "max_ms": 1.9925111400000005000,
            "cv": 0.20373941038385943377,
            "runs": 10,
            "user_ms": 0.69188000,
            "system_ms": 0.52502000
          },
          "go": {
            "mean_ms": 2.608185940000001000,
            "median_ms": 2.558719140000001000,
            "stddev_ms": 0.37690656315526145000,
            "min_ms": 2.036594140000001000,
            "max_ms": 3.2523031400000005000,
            "cv": 0.14450908479142453528,
            "runs": 10,
            "user_ms": 1.35438000,
            "system_ms": 0.9262199999999998000
          },
          "java": {
            "mean_ms": 67.67282324000,
            "median_ms": 65.41892714000,
            "stddev_ms": 6.136582471059542000,
            "min_ms": 60.475136139999996000,
            "max_ms": 78.30080214000,
            "cv": 0.09068016047293170386,
            "runs": 10,
            "user_ms": 38.96577999999999000,
            "system_ms": 29.018119999999998000
          },
          "js": {
            "mean_ms": 51.73497314000001000,
            "median_ms": 48.289218640000006000,
            "stddev_ms": 11.805285267311996000,
            "min_ms": 47.11155214000,
            "max_ms": 85.30559414000001000,
            "cv": 0.22818771424439931038,
            "runs": 10,
            "user_ms": 38.43397999999999000,
            "system_ms": 5.66152000
          },
          "python": {
            "mean_ms": 193.24278604000,
            "median_ms": 177.42184414000,
            "stddev_ms": 28.305391179300594000,
            "min_ms": 172.47688614000,
            "max_ms": 250.75726114000,
            "cv": 0.14647579741187110655,
            "runs": 10,
            "user_ms": 52.70918000,
            "system_ms": 12.42032000
          },
          "ruby": {
            "mean_ms": 72.32021904000,
            "median_ms": 68.65417714000,
            "stddev_ms": 11.00850704122221000,
            "min_ms": 65.82984414000,
            "max_ms": 102.96455214000,
            "cv": 0.15221893942458128373,
            "runs": 10,
            "user_ms": 50.047180000000004000,
            "system_ms": 14.176020000000001000
          },
          "nim": {
            "mean_ms": 1.641652540000001000,
            "median_ms": 1.556615140000001000,
            "stddev_ms": 0.3024275171056879000,
            "min_ms": 1.3383021400000012000,
            "max_ms": 2.1524281400000012000,
            "cv": 0.18422139261313341968,
            "runs": 10,
            "user_ms": 0.8410799999999999000,
            "system_ms": 0.4805199999999999000
          },
          "logos_release": {
            "mean_ms": 2.9646692400000013000,
            "median_ms": 2.942073640000001000,
            "stddev_ms": 0.27866750083864385000,
            "min_ms": 2.525010140000001000,
            "max_ms": 3.457886140000001000,
            "cv": 0.09399615210992094612,
            "runs": 10,
            "user_ms": 1.7189800000000002000,
            "system_ms": 0.8175200000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "array_fill",
      "name": "Array Fill & Sum",
      "description": "Array push and sum. Measures raw memory bandwidth and allocation.",
      "reference_size": "1000000",
      "sizes": [
        "100000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push (i * 7 + 3) % 1000000 to arr.\n    Set i to i + 1.\nLet mutable sum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set sum to (sum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        arr.push((((i * 7) + 3) % 1000000));\n    }\n    let mut i = (0_i64).max(n);\n    let mut sum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        sum = ((sum + arr[i as usize]) % 1000000007);\n    }\n    show(&sum);\n}",
      "scaling": {
        "1000000": {
          "c": {
            "mean_ms": 6.354215020000002000,
            "median_ms": 6.356481920000001000,
            "stddev_ms": 0.2131641153400618000,
            "min_ms": 6.027148420000002000,
            "max_ms": 6.664106420000002000,
            "cv": 0.03354688418146443727,
            "runs": 10,
            "user_ms": 4.7249399999999995000,
            "system_ms": 1.1858999999999997000
          },
          "cpp": {
            "mean_ms": 6.576198320000002000,
            "median_ms": 6.5711484200000015000,
            "stddev_ms": 0.24406603367779604000,
            "min_ms": 6.209189420000001000,
            "max_ms": 6.936648420000001000,
            "cv": 0.03711354521282076629,
            "runs": 10,
            "user_ms": 4.8194399999999995000,
            "system_ms": 1.2539999999999997000
          },
          "rust": {
            "mean_ms": 7.458002620000001000,
            "median_ms": 7.465668920000002000,
            "stddev_ms": 0.2197288142768517000,
            "min_ms": 7.164857420000001000,
            "max_ms": 7.879690420000002000,
            "cv": 0.02946215300161045941,
            "runs": 10,
            "user_ms": 5.63604000,
            "system_ms": 1.2684999999999997000
          },
          "zig": {
            "mean_ms": 7.1857733200000025000,
            "median_ms": 7.128106920000001000,
            "stddev_ms": 0.3869390080342693000,
            "min_ms": 6.584523420000001000,
            "max_ms": 7.689981420000001000,
            "cv": 0.05384792851136990296,
            "runs": 10,
            "user_ms": 5.51984000,
            "system_ms": 1.2270000000000002000
          },
          "go": {
            "mean_ms": 12.538731620000002000,
            "median_ms": 7.969856920000002000,
            "stddev_ms": 14.612081520438436000,
            "min_ms": 7.487064420000001000,
            "max_ms": 54.12035642000,
            "cv": 1.16535563271258801129,
            "runs": 10,
            "user_ms": 6.000739999999999000,
            "system_ms": 1.9072000
          },
          "java": {
            "mean_ms": 56.15764842000,
            "median_ms": 56.10423192000,
            "stddev_ms": 1.1045477534401926000,
            "min_ms": 54.06244042000,
            "max_ms": 57.68973242000,
            "cv": 0.01966869668721417947,
            "runs": 10,
            "user_ms": 29.90304000,
            "system_ms": 27.6312000
          },
          "js": {
            "mean_ms": 57.683331920000004000,
            "median_ms": 57.570523420000005000,
            "stddev_ms": 0.2907311640663749000,
            "min_ms": 57.43010742000,
            "max_ms": 58.284523420000005000,
            "cv": 0.00504012431996100408,
            "runs": 10,
            "user_ms": 47.57164000,
            "system_ms": 6.559999999999999000
          },
          "python": {
            "mean_ms": 281.40117752000005000,
            "median_ms": 278.22506442000,
            "stddev_ms": 10.576578887117327000,
            "min_ms": 270.57756542000,
            "max_ms": 305.92156442000,
            "cv": 0.03758541090811752876,
            "runs": 10,
            "user_ms": 146.31573999999997000,
            "system_ms": 18.2472000
          },
          "ruby": {
            "mean_ms": 155.50096502000002000,
            "median_ms": 149.18123142000,
            "stddev_ms": 13.1173803624013000,
            "min_ms": 145.70464842000003000,
            "max_ms": 182.59623242000,
            "cv": 0.08435562030572727253,
            "runs": 10,
            "user_ms": 127.17943999999998000,
            "system_ms": 18.104700000000005000
          },
          "nim": {
            "mean_ms": 8.807656820000002000,
            "median_ms": 8.624211420000001000,
            "stddev_ms": 0.8411696707408484000,
            "min_ms": 8.00135742000,
            "max_ms": 10.773439420000003000,
            "cv": 0.09550436488746483755,
            "runs": 10,
            "user_ms": 6.478639999999999000,
            "system_ms": 1.4698000
          },
          "logos_release": {
            "mean_ms": 9.402515019999998000,
            "median_ms": 9.28019042000,
            "stddev_ms": 0.5034529326102118000,
            "min_ms": 8.79018942000,
            "max_ms": 10.261273420000001000,
            "cv": 0.05354449650325705165,
            "runs": 10,
            "user_ms": 6.69844000,
            "system_ms": 1.8414000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "collect",
      "name": "Collection Operations",
      "description": "Hash map insert and lookup. Measures hash computation and cache behavior.",
      "reference_size": "10000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "500000",
        "5000000",
        "30000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable m be a new Map of Int to Int with capacity n.\nLet mutable i be 1.\nWhile i is less than n + 1:\n    Set item i of m to i * 2.\n    Set i to i + 1.\nLet mutable found be 0.\nSet i to 1.\nWhile i is less than n + 1:\n    If item i of m equals i * 2:\n        Set found to found + 1.\n    Set i to i + 1.\nShow found.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut m = { let __m: FxHashMap<i64, i64> = FxHashMap::with_capacity_and_hasher((n) as usize, Default::default()); __m };\n    for i in 1..(n + 1) {\n        m.insert(i, (i * 2));\n    }\n    let mut i = (1_i64).max((n + 1));\n    let mut found = 0;\n    for i in 1..(n + 1) {\n        if (m.get(&(i)).copied() == Some((i * 2))) {\n            found = (found + 1);\n        }\n    }\n    show(&found);\n}",
      "scaling": {
        "10000": {
          "c": {
            "mean_ms": 0.33118409000000007000,
            "median_ms": 0.3318851000000001000,
            "stddev_ms": 0.2319710068877882000,
            "min_ms": 0,
            "max_ms": 0.6800510999999997000,
            "cv": 0.70042919902277959961,
            "runs": 10,
            "user_ms": 0.5624200000000003000,
            "system_ms": 0.4057800000000002000
          },
          "cpp": {
            "mean_ms": 1.0316728000000002000,
            "median_ms": 1.0696771000000002000,
            "stddev_ms": 0.28672483740612125000,
            "min_ms": 0.4844261000000001000,
            "max_ms": 1.3965940999999997000,
            "cv": 0.27792226121123014430,
            "runs": 10,
            "user_ms": 1.0800200000000003000,
            "system_ms": 0.47508000000000023000
          },
          "rust": {
            "mean_ms": 3.0641517000,
            "median_ms": 0.7530101000000002000,
            "stddev_ms": 7.302089056852159000,
            "min_ms": 0.1366351000,
            "max_ms": 23.793760100000002000,
            "cv": 2.38307034761110522041,
            "runs": 10,
            "user_ms": 0.8269200000000001000,
            "system_ms": 0.39808000000000015000
          },
          "zig": {
            "mean_ms": 0.5026893000000002000,
            "median_ms": 0.42957260000000023000,
            "stddev_ms": 0.2678584207809956000,
            "min_ms": 0.2025931000000005000,
            "max_ms": 1.0503431000,
            "cv": 0.53285084998028701512,
            "runs": 10,
            "user_ms": 0.7149200000000003000,
            "system_ms": 0.3092800000000002000
          },
          "go": {
            "mean_ms": 1.1480808000000002000,
            "median_ms": 1.0663641000000002000,
            "stddev_ms": 0.23695093856607633000,
            "min_ms": 0.8529690999999999000,
            "max_ms": 1.5110101000000006000,
            "cv": 0.20638873027584494812,
            "runs": 10,
            "user_ms": 1.17132000,
            "system_ms": 0.5690800000000002000
          },
          "java": {
            "mean_ms": 58.03442670000001000,
            "median_ms": 60.957635100000004000,
            "stddev_ms": 6.159249717368039000,
            "min_ms": 49.609718100000005000,
            "max_ms": 64.1475931000,
            "cv": 0.10613096514603870358,
            "runs": 10,
            "user_ms": 25.01222000,
            "system_ms": 28.99298000
          },
          "js": {
            "mean_ms": 45.7280019000,
            "median_ms": 45.576322600000004000,
            "stddev_ms": 0.5427564550708425000,
            "min_ms": 45.2326771000,
            "max_ms": 46.784635100000006000,
            "cv": 0.01186923619050239979,
            "runs": 10,
            "user_ms": 36.741020000000006000,
            "system_ms": 5.22768000
          },
          "python": {
            "mean_ms": 155.1586852000,
            "median_ms": 146.60667710000003000,
            "stddev_ms": 21.542488355019405000,
            "min_ms": 140.2625521000,
            "max_ms": 199.20463510000003000,
            "cv": 0.13884165315819139849,
            "runs": 10,
            "user_ms": 24.043219999999997000,
            "system_ms": 11.25058000
          },
          "ruby": {
            "mean_ms": 56.6673226000,
            "median_ms": 56.248885600000006000,
            "stddev_ms": 1.5661444191979689000,
            "min_ms": 54.112426100000006000,
            "max_ms": 59.6642181000,
            "cv": 0.02763752277927400967,
            "runs": 10,
            "user_ms": 38.90432000,
            "system_ms": 14.23578000
          },
          "nim": {
            "mean_ms": 0.9984683000,
            "median_ms": 0.9367595999999999000,
            "stddev_ms": 0.39575478287298617000,
            "min_ms": 0.4306761000000001000,
            "max_ms": 1.7239271000000006000,
            "cv": 0.39636189038048195420,
            "runs": 10,
            "user_ms": 0.9807200000000002000,
            "system_ms": 0.5087800000000002000
          },
          "logos_release": {
            "mean_ms": 1.7691310000000002000,
            "median_ms": 1.7017396000,
            "stddev_ms": 0.24155914921491462000,
            "min_ms": 1.4686350999999999000,
            "max_ms": 2.2134261000000006000,
            "cv": 0.13654113189747655356,
            "runs": 10,
            "user_ms": 1.5640200000000004000,
            "system_ms": 0.7194800000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "two_sum",
      "name": "Two Sum",
      "description": "Interleaved hash insert+lookup. Measures hash table under mixed workload.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "1000000",
        "10000000",
        "60000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet target be n.\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push ((seed / 65536) % 32768) % n to arr.\n    Set i to i + 1.\nLet mutable seen be a new Map of Int to Int.\nLet mutable count be 0.\nSet i to 1.\nWhile i is at most n:\n    Let x be item i of arr.\n    Let complement be target - x.\n    If complement is at least 0:\n        If seen contains complement:\n            Set count to count + 1.\n    Set seen at x to 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let target = n;\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push((((seed / 65536) % 32768) % n));\n    }\n    let mut i = (0_i64).max(n);\n    let mut seen: FxHashMap<i64, i64> = FxHashMap::with_capacity_and_hasher(n as usize, Default::default());\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        let x = arr[i as usize];\n        let complement = (target - x);\n        if (complement >= 0) {\n            if seen.logos_contains(&complement) {\n                count = (count + 1);\n            }\n        }\n        seen.insert(x, 1);\n    }\n    show(&count);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 0.4170215279999991000,
            "median_ms": 0.4644121599999989000,
            "stddev_ms": 0.3272386406802187000,
            "min_ms": 0,
            "max_ms": 0.869912159999999000,
            "cv": 0.78470443060728367537,
            "runs": 10,
            "user_ms": 0.4932399999999998000,
            "system_ms": 0.4864600000000001000
          },
          "cpp": {
            "mean_ms": 0.9152334599999989000,
            "median_ms": 0.939162659999999000,
            "stddev_ms": 0.21851473806488834000,
            "min_ms": 0.47620415999999853000,
            "max_ms": 1.1873291599999993000,
            "cv": 0.23875300414048302236,
            "runs": 10,
            "user_ms": 0.8536399999999998000,
            "system_ms": 0.5903600000000001000
          },
          "rust": {
            "mean_ms": 0.9383624599999991000,
            "median_ms": 0.9161416599999992000,
            "stddev_ms": 0.15961259143664768000,
            "min_ms": 0.5839541599999987000,
            "max_ms": 1.1267041599999986000,
            "cv": 0.17009694893021171487,
            "runs": 10,
            "user_ms": 0.9395399999999998000,
            "system_ms": 0.54096000
          },
          "zig": {
            "mean_ms": 0.8580248599999989000,
            "median_ms": 0.7624746599999991000,
            "stddev_ms": 0.4502902235790824000,
            "min_ms": 0.328787159999999000,
            "max_ms": 1.7440371599999989000,
            "cv": 0.52479857469290922092,
            "runs": 10,
            "user_ms": 0.7040399999999999000,
            "system_ms": 0.5856600000000002000
          },
          "go": {
            "mean_ms": 1.6026209599999991000,
            "median_ms": 1.6307041599999987000,
            "stddev_ms": 0.20569451584532931000,
            "min_ms": 1.310496159999999000,
            "max_ms": 1.9789961599999987000,
            "cv": 0.12834882419441801479,
            "runs": 10,
            "user_ms": 1.2160399999999998000,
            "system_ms": 0.9132600000000002000
          },
          "java": {
            "mean_ms": 51.34538746000,
            "median_ms": 49.94572466000,
            "stddev_ms": 4.942377468548468000,
            "min_ms": 48.19357916000,
            "max_ms": 65.17928816000,
            "cv": 0.09625747731281153720,
            "runs": 10,
            "user_ms": 23.383139999999997000,
            "system_ms": 27.26836000
          },
          "js": {
            "mean_ms": 48.36164595999999000,
            "median_ms": 45.788641660000004000,
            "stddev_ms": 6.3654590798636525000,
            "min_ms": 44.62003816000,
            "max_ms": 64.29632916000,
            "cv": 0.13162205201056506423,
            "runs": 10,
            "user_ms": 38.00784000,
            "system_ms": 5.56546000
          },
          "python": {
            "mean_ms": 154.72618766000,
            "median_ms": 151.64341266000,
            "stddev_ms": 12.098359746420281000,
            "min_ms": 143.57857916000,
            "max_ms": 181.54649616000001000,
            "cv": 0.07819206256800938101,
            "runs": 10,
            "user_ms": 24.379439999999995000,
            "system_ms": 11.54196000
          },
          "ruby": {
            "mean_ms": 62.408016860000005000,
            "median_ms": 61.18799616000,
            "stddev_ms": 5.1530988093975525000,
            "min_ms": 55.68020416000,
            "max_ms": 72.19924616000001000,
            "cv": 0.08257110334009661859,
            "runs": 10,
            "user_ms": 40.275639999999995000,
            "system_ms": 16.239959999999998000
          },
          "nim": {
            "mean_ms": 0.8321207599999988000,
            "median_ms": 0.7464751599999988000,
            "stddev_ms": 0.5464740795561224000,
            "min_ms": 0.258537159999999000,
            "max_ms": 1.5189541599999988000,
            "cv": 0.65672448738825262341,
            "runs": 10,
            "user_ms": 0.7735399999999999000,
            "system_ms": 0.5377600000000002000
          },
          "logos_release": {
            "mean_ms": 2.2219667599999993000,
            "median_ms": 2.183183659999999000,
            "stddev_ms": 0.3320330492550404000,
            "min_ms": 1.7244541599999988000,
            "max_ms": 2.7771631599999994000,
            "cv": 0.14943205057443816333,
            "runs": 10,
            "user_ms": 1.6731399999999996000,
            "system_ms": 0.8891600000000003000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "histogram",
      "name": "Histogram",
      "description": "Array-indexed frequency counting. Measures random array access.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "100000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable counts be a new Seq of Int.\nLet mutable idx be 0.\nWhile idx is less than 1000:\n    Push 0 to counts.\n    Set idx to idx + 1.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Let v be ((seed / 65536) % 32768) % 1000.\n    Set item (v + 1) of counts to (item (v + 1) of counts) + 1.\n    Set i to i + 1.\nLet mutable maxFreq be 0.\nLet mutable maxIndex be 0.\nLet mutable distinct be 0.\nSet i to 0.\nWhile i is less than 1000:\n    If item (i + 1) of counts is greater than 0:\n        Set distinct to distinct + 1.\n    If item (i + 1) of counts is greater than maxFreq:\n        Set maxFreq to item (i + 1) of counts.\n        Set maxIndex to i.\n    Set i to i + 1.\nShow \"\" + maxFreq + \" \" + maxIndex + \" \" + distinct.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(LogosIndex::logos_get(&arguments, 2));\n    let mut counts: Vec<i64> = vec![0; 1000 as usize];\n    let mut idx = 0;\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        let v = (((seed / 65536) % 32768) % 1000);\n        let __set_tmp = (LogosIndex::logos_get(&counts, (v + 1)) + 1);\n        LogosIndexMut::logos_set(&mut counts, (v + 1), __set_tmp);\n    }\n    let mut i = (0_i64).max(n);\n    let mut maxFreq = 0;\n    let mut maxIndex = 0;\n    let mut distinct = 0;\n    i = 0;\n    while (i < 1000) {\n        if (LogosIndex::logos_get(&counts, (i + 1)) > 0) {\n            distinct = (distinct + 1);\n        }\n        if (LogosIndex::logos_get(&counts, (i + 1)) > maxFreq) {\n            maxFreq = LogosIndex::logos_get(&counts, (i + 1));\n            maxIndex = i;\n        }\n        i = (i + 1);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", maxFreq, \" \", maxIndex, \" \", distinct));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 0.6641922999999995000,
            "median_ms": 0.6432383999999992000,
            "stddev_ms": 0.40546280907904073000,
            "min_ms": 0.0835708999999997000,
            "max_ms": 1.2872798999999996000,
            "cv": 0.61045996630650646692,
            "runs": 10,
            "user_ms": 0.6322000000000001000,
            "system_ms": 0.5212399999999999000
          },
          "cpp": {
            "mean_ms": 0.7714756999999994000,
            "median_ms": 0.7410923999999993000,
            "stddev_ms": 0.22329109651046195000,
            "min_ms": 0.38065489999999924000,
            "max_ms": 1.104237899999999000,
            "cv": 0.28943373914494276833,
            "runs": 10,
            "user_ms": 0.6837000000000001000,
            "system_ms": 0.5896399999999998000
          },
          "rust": {
            "mean_ms": 1.0465256999999996000,
            "median_ms": 1.0638423999999994000,
            "stddev_ms": 0.25026731845937154000,
            "min_ms": 0.6499878999999993000,
            "max_ms": 1.3794048999999997000,
            "cv": 0.23914111087703974747,
            "runs": 10,
            "user_ms": 0.8659000000000002000,
            "system_ms": 0.6183399999999997000
          },
          "zig": {
            "mean_ms": 1.1574798999999993000,
            "median_ms": 1.1728423999999996000,
            "stddev_ms": 0.3652456976155458000,
            "min_ms": 0.5136128999999991000,
            "max_ms": 1.7524048999999998000,
            "cv": 0.31555251854960593344,
            "runs": 10,
            "user_ms": 0.7395000000000001000,
            "system_ms": 0.7717399999999997000
          },
          "go": {
            "mean_ms": 2.8727299999999996000,
            "median_ms": 2.3008633999999995000,
            "stddev_ms": 1.085313953240101000,
            "min_ms": 2.116904899999999000,
            "max_ms": 5.3478209000,
            "cv": 0.37779880226826090552,
            "runs": 10,
            "user_ms": 1.4781000,
            "system_ms": 1.4268399999999997000
          },
          "java": {
            "mean_ms": 75.65825920000001000,
            "median_ms": 73.9020719000,
            "stddev_ms": 15.622858995881004000,
            "min_ms": 60.61961290000001000,
            "max_ms": 107.95027990000002000,
            "cv": 0.20649244591502578392,
            "runs": 10,
            "user_ms": 39.758299999999996000,
            "system_ms": 32.49684000
          },
          "js": {
            "mean_ms": 51.42475080000001000,
            "median_ms": 48.381884400000005000,
            "stddev_ms": 7.932933474368825000,
            "min_ms": 46.1367379000,
            "max_ms": 70.8454889000,
            "cv": 0.15426294441797904555,
            "runs": 10,
            "user_ms": 38.386899999999995000,
            "system_ms": 5.698139999999999000
          },
          "python": {
            "mean_ms": 192.91554660000002000,
            "median_ms": 179.62357140000001000,
            "stddev_ms": 28.14824248082778000,
            "min_ms": 169.1789889000,
            "max_ms": 259.0064469000,
            "cv": 0.14590966346113951337,
            "runs": 10,
            "user_ms": 46.180700000000005000,
            "system_ms": 13.224740000000002000
          },
          "ruby": {
            "mean_ms": 66.99279659999999000,
            "median_ms": 66.70257190000001000,
            "stddev_ms": 1.225354847172674000,
            "min_ms": 65.1737799000,
            "max_ms": 68.93123790000001000,
            "cv": 0.01829084482752693717,
            "runs": 10,
            "user_ms": 48.365099999999994000,
            "system_ms": 14.715140000000002000
          },
          "nim": {
            "mean_ms": 1.2670296999999994000,
            "median_ms": 1.2274253999999991000,
            "stddev_ms": 0.23488007340522613000,
            "min_ms": 0.9966958999999996000,
            "max_ms": 1.7054878999999993000,
            "cv": 0.18537850644323983978,
            "runs": 10,
            "user_ms": 0.8844000000000001000,
            "system_ms": 0.6939399999999998000
          },
          "logos_release": {
            "mean_ms": 7.0521216999999995000,
            "median_ms": 2.5903423999999995000,
            "stddev_ms": 9.607851857860814000,
            "min_ms": 2.2984879000,
            "max_ms": 28.9005719000,
            "cv": 1.36240584983960425430,
            "runs": 10,
            "user_ms": 1.8403000000000002000,
            "system_ms": 1.0025400000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "knapsack",
      "name": "0/1 Knapsack",
      "description": "0/1 knapsack DP. Measures 2D table fills and conditional max.",
      "reference_size": "500",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000",
        "9000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet capacity be n * 5.\nLet mutable weights be a new Seq of Int.\nLet mutable vals be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push (i * 17 + 3) % 50 + 1 to weights.\n    Push (i * 31 + 7) % 100 + 1 to vals.\n    Set i to i + 1.\nLet cols be capacity + 1.\nLet mutable prev be a new Seq of Int.\nLet mutable curr be a new Seq of Int.\nSet i to 0.\nWhile i is less than cols:\n    Push 0 to prev.\n    Push 0 to curr.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n:\n    Let wi be item (i + 1) of weights.\n    Let vi be item (i + 1) of vals.\n    Let mutable w be 0.\n    While w is at most capacity:\n        Set item (w + 1) of curr to item (w + 1) of prev.\n        If w is at least wi:\n            Let take be item (w - wi + 1) of prev + vi.\n            If take is greater than item (w + 1) of curr:\n                Set item (w + 1) of curr to take.\n        Set w to w + 1.\n    Set prev to curr.\n    Set i to i + 1.\nShow item (capacity + 1) of prev.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let capacity = (n * 5);\n    let mut weights: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut vals: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        weights.push(((((i * 17) + 3) % 50) + 1));\n        vals.push(((((i * 31) + 7) % 100) + 1));\n    }\n    let mut i = (0_i64).max(n);\n    let cols = (capacity + 1);\n    let mut prev: Vec<i64> = Vec::with_capacity(cols as usize);\n    let mut curr: Vec<i64> = Vec::with_capacity(cols as usize);\n    for i in 0..cols {\n        prev.push(0);\n        curr.push(0);\n    }\n    unsafe { std::hint::assert_unchecked((n as usize) <= weights.len()); }\n    unsafe { std::hint::assert_unchecked((n as usize) <= vals.len()); }\n    for i in 0..n {\n        let wi = weights[i as usize];\n        let vi = vals[i as usize];\n        unsafe { std::hint::assert_unchecked((capacity as usize) <= prev.len()); }\n        unsafe { std::hint::assert_unchecked((capacity as usize) <= curr.len()); }\n        for w in 0..(capacity + 1) {\n            curr[(w) as usize] = prev[w as usize];\n            if (w >= wi) {\n                let take = (prev[((w - wi)) as usize] + vi);\n                if (take > curr[w as usize]) {\n                    curr[(w) as usize] = take;\n                }\n            }\n        }\n        std::mem::swap(&mut prev, &mut curr);\n    }\n    show(&prev[capacity as usize]);\n}",
      "scaling": {
        "500": {
          "c": {
            "mean_ms": 2.3863448800000003000,
            "median_ms": 2.3249241800000005000,
            "stddev_ms": 0.2030021919367429000,
            "min_ms": 2.0773401800000006000,
            "max_ms": 2.72821518000,
            "cv": 0.08506825381281136299,
            "runs": 10,
            "user_ms": 1.4038000,
            "system_ms": 0.52578000
          },
          "cpp": {
            "mean_ms": 6.640574280000001000,
            "median_ms": 4.7791946799999995000,
            "stddev_ms": 5.695722154327764000,
            "min_ms": 2.19404918000,
            "max_ms": 20.028466180000003000,
            "cv": 0.85771529903401112806,
            "runs": 10,
            "user_ms": 1.5958999999999997000,
            "system_ms": 1.13408000
          },
          "rust": {
            "mean_ms": 5.190891080000001000,
            "median_ms": 3.2232161800000002000,
            "stddev_ms": 5.7139492983466445000,
            "min_ms": 2.4777151800000003000,
            "max_ms": 21.314966180000002000,
            "cv": 1.10076462986517594186,
            "runs": 10,
            "user_ms": 2.1925000,
            "system_ms": 0.79778000
          },
          "zig": {
            "mean_ms": 2.41172018000,
            "median_ms": 2.4376951800000003000,
            "stddev_ms": 0.21207124510985557000,
            "min_ms": 2.08967418000,
            "max_ms": 2.7465911799999998000,
            "cv": 0.08793360310558730325,
            "runs": 10,
            "user_ms": 1.2983000,
            "system_ms": 0.59618000
          },
          "go": {
            "mean_ms": 3.8088033800000006000,
            "median_ms": 3.7924451800000003000,
            "stddev_ms": 0.20555279410452624000,
            "min_ms": 3.5005491800000005000,
            "max_ms": 4.09671518000,
            "cv": 0.05396781445424106077,
            "runs": 10,
            "user_ms": 2.3054000,
            "system_ms": 1.01498000
          },
          "java": {
            "mean_ms": 59.700890579999985000,
            "median_ms": 56.59096518000,
            "stddev_ms": 6.728477599848229000,
            "min_ms": 53.90717418000,
            "max_ms": 76.08525718000,
            "cv": 0.11270313615894858047,
            "runs": 10,
            "user_ms": 27.362499999999994000,
            "system_ms": 29.373780000000006000
          },
          "js": {
            "mean_ms": 54.08932818000001000,
            "median_ms": 51.66438218000,
            "stddev_ms": 7.374875491306974000,
            "min_ms": 50.48721518000,
            "max_ms": 74.84842418000001000,
            "cv": 0.13634622095443028733,
            "runs": 10,
            "user_ms": 43.1194000,
            "system_ms": 5.50538000
          },
          "python": {
            "mean_ms": 426.07270768000005000,
            "median_ms": 410.72638318000,
            "stddev_ms": 47.641176164095786000,
            "min_ms": 384.16875818000,
            "max_ms": 537.54925718000,
            "cv": 0.11181466286236872164,
            "runs": 10,
            "user_ms": 277.6395000,
            "system_ms": 13.44718000
          },
          "ruby": {
            "mean_ms": 194.40011998000,
            "median_ms": 193.35550768000,
            "stddev_ms": 8.505985634107609000,
            "min_ms": 184.23325818000003000,
            "max_ms": 205.68292418000,
            "cv": 0.04375504312951406543,
            "runs": 10,
            "user_ms": 166.7578000,
            "system_ms": 17.078279999999998000
          },
          "nim": {
            "mean_ms": 3.8798074800000006000,
            "median_ms": 3.7369031800000003000,
            "stddev_ms": 0.38156393582350296000,
            "min_ms": 3.5436741800000003000,
            "max_ms": 4.76117418000,
            "cv": 0.09834610036462502541,
            "runs": 10,
            "user_ms": 3.0066000,
            "system_ms": 0.3919800000000001000
          },
          "logos_release": {
            "mean_ms": 6.213182480000001000,
            "median_ms": 4.42738218000,
            "stddev_ms": 4.880216180267611000,
            "min_ms": 4.07450818000,
            "max_ms": 19.97704918000,
            "cv": 0.78546158848172285043,
            "runs": 10,
            "user_ms": 3.0188999999999997000,
            "system_ms": 0.98788000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "coins",
      "name": "Coin Change",
      "description": "Coin change DP. Measures 1D DP with inner-loop additions.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "10000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable coinList be a new Seq of Int.\nPush 1 to coinList.\nPush 5 to coinList.\nPush 10 to coinList.\nPush 25 to coinList.\nPush 50 to coinList.\nPush 100 to coinList.\nLet mutable dp be a new Seq of Int.\nPush 1 to dp.\nLet mutable i be 1.\nWhile i is at most n:\n    Push 0 to dp.\n    Set i to i + 1.\nLet mutable c be 1.\nWhile c is at most 6:\n    Let coin be item c of coinList.\n    Let mutable j be coin.\n    While j is at most n:\n        Set item (j + 1) of dp to (item (j + 1) of dp + item (j - coin + 1) of dp) % 1000000007.\n        Set j to j + 1.\n    Set c to c + 1.\nShow item (n + 1) of dp.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut coinList = Seq::<i64>::default();\n    coinList.push(1);\n    coinList.push(5);\n    coinList.push(10);\n    coinList.push(25);\n    coinList.push(50);\n    coinList.push(100);\n    let mut dp: Vec<i64> = vec![0; (1 + n) as usize];\n    dp[0] = 1;\n    let mut i = 1;\n    unsafe { std::hint::assert_unchecked((6 as usize) <= coinList.len()); }\n    for c in 0..6 {\n        let coin = coinList[c as usize];\n        unsafe { std::hint::assert_unchecked((n as usize) <= dp.len()); }\n        for j in coin..(n + 1) {\n            dp[(j) as usize] = ((dp[j as usize] + dp[((j - coin)) as usize]) % 1000000007);\n        }\n    }\n    show(&dp[n as usize]);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.5004108200000013000,
            "median_ms": 1.538131920000001000,
            "stddev_ms": 0.23753678297626062000,
            "min_ms": 1.232632420000001000,
            "max_ms": 1.7856734200000007000,
            "cv": 0.15831449614330321490,
            "runs": 10,
            "user_ms": 0.5342399999999998000,
            "system_ms": 0.4928799999999998000
          },
          "cpp": {
            "mean_ms": 5.994231820000001000,
            "median_ms": 1.4094859200000013000,
            "stddev_ms": 9.990507330965934000,
            "min_ms": 0.9789234200000014000,
            "max_ms": 30.022131420000004000,
            "cv": 1.66668684678363546061,
            "runs": 10,
            "user_ms": 0.5588399999999999000,
            "system_ms": 0.5835799999999999000
          },
          "rust": {
            "mean_ms": 2.0435693200000007000,
            "median_ms": 2.031985920000001000,
            "stddev_ms": 0.4582037134265478000,
            "min_ms": 1.4092564200000011000,
            "max_ms": 2.804631420000001000,
            "cv": 0.22421735780734251923,
            "runs": 10,
            "user_ms": 0.8320399999999998000,
            "system_ms": 0.6064799999999998000
          },
          "zig": {
            "mean_ms": 1.662910820000001000,
            "median_ms": 1.615548420000001000,
            "stddev_ms": 0.2667995130926758000,
            "min_ms": 1.2110894200000012000,
            "max_ms": 2.167215420000001000,
            "cv": 0.16044126352649244266,
            "runs": 10,
            "user_ms": 0.6163399999999998000,
            "system_ms": 0.53738000
          },
          "go": {
            "mean_ms": 2.906965220000001000,
            "median_ms": 2.651506920000001000,
            "stddev_ms": 0.9733399885760828000,
            "min_ms": 1.8370074200000008000,
            "max_ms": 4.876132420000001000,
            "cv": 0.33483028344456163296,
            "runs": 10,
            "user_ms": 1.0448399999999998000,
            "system_ms": 1.10518000
          },
          "java": {
            "mean_ms": 49.970431620000005000,
            "median_ms": 50.02781892000,
            "stddev_ms": 1.4825534271979545000,
            "min_ms": 47.68371442000,
            "max_ms": 53.04692342000,
            "cv": 0.02966861360077950736,
            "runs": 10,
            "user_ms": 20.21334000,
            "system_ms": 27.18508000
          },
          "js": {
            "mean_ms": 46.33160672000,
            "median_ms": 46.336923419999995000,
            "stddev_ms": 0.5270574576915054000,
            "min_ms": 45.62317342000,
            "max_ms": 47.45533942000,
            "cv": 0.01137576473176765754,
            "runs": 10,
            "user_ms": 37.20934000,
            "system_ms": 5.33798000
          },
          "python": {
            "mean_ms": 158.17016522000,
            "median_ms": 151.50363192000002000,
            "stddev_ms": 17.747207640273478000,
            "min_ms": 141.79071442000002000,
            "max_ms": 198.19946542000003000,
            "cv": 0.11220325663559092538,
            "runs": 10,
            "user_ms": 26.583640000000002000,
            "system_ms": 11.783280000000002000
          },
          "ruby": {
            "mean_ms": 62.21716102000,
            "median_ms": 61.24169442000,
            "stddev_ms": 3.4728836746026545000,
            "min_ms": 57.65146542000,
            "max_ms": 70.06021442000002000,
            "cv": 0.05581874225161575043,
            "runs": 10,
            "user_ms": 40.74854000,
            "system_ms": 15.630980000000003000
          },
          "nim": {
            "mean_ms": 1.7856525200000007000,
            "median_ms": 1.656298420000001000,
            "stddev_ms": 0.48273931331964485000,
            "min_ms": 1.2242564200000009000,
            "max_ms": 2.628173420000001000,
            "cv": 0.27034336631162968972,
            "runs": 10,
            "user_ms": 0.5755399999999997000,
            "system_ms": 0.5190799999999998000
          },
          "logos_release": {
            "mean_ms": 3.4527065200000012000,
            "median_ms": 3.3244439200000014000,
            "stddev_ms": 0.5329165574714405000,
            "min_ms": 2.8321734200000013000,
            "max_ms": 4.589506420000001000,
            "cv": 0.15434748200708362400,
            "runs": 10,
            "user_ms": 1.7640400000000001000,
            "system_ms": 0.9743800000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "fannkuch",
      "name": "Fannkuch Redux",
      "description": "Fannkuch permutation benchmark. Measures tight array reversal loops.",
      "reference_size": "8",
      "sizes": [
        "7",
        "8",
        "9",
        "10",
        "11"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable perm1 be a new Seq of Int.\nLet mutable count be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push i to perm1.\n    Push 0 to count.\n    Set i to i + 1.\nLet mutable maxFlips be 0.\nLet mutable checksum be 0.\nLet mutable permCount be 0.\nLet mutable r be n.\nLet mutable done be 0.\nWhile done equals 0:\n    While r is greater than 1:\n        Set item r of count to r.\n        Set r to r - 1.\n    Let mutable perm be a new Seq of Int.\n    Set i to 1.\n    While i is at most n:\n        Push item i of perm1 to perm.\n        Set i to i + 1.\n    Let mutable flips be 0.\n    While item 1 of perm is not 0:\n        Let k be item 1 of perm + 1.\n        Let mutable lo be 1.\n        Let mutable hi be k.\n        While lo is less than hi:\n            Let tmp be item lo of perm.\n            Set item lo of perm to item hi of perm.\n            Set item hi of perm to tmp.\n            Set lo to lo + 1.\n            Set hi to hi - 1.\n        Set flips to flips + 1.\n    If flips is greater than maxFlips:\n        Set maxFlips to flips.\n    If permCount % 2 equals 0:\n        Set checksum to checksum + flips.\n    Otherwise:\n        Set checksum to checksum - flips.\n    Set permCount to permCount + 1.\n    Set done to 1.\n    While done equals 1:\n        If r equals n:\n            Set done to 2.\n        Otherwise:\n            Let perm0 be item 1 of perm1.\n            Set i to 1.\n            While i is at most r:\n                Set item i of perm1 to item (i + 1) of perm1.\n                Set i to i + 1.\n            Set item (r + 1) of perm1 to perm0.\n            Set item (r + 1) of count to (item (r + 1) of count) - 1.\n            If item (r + 1) of count is greater than 0:\n                Set done to 0.\n            Otherwise:\n                Set r to r + 1.\nShow checksum.\nShow maxFlips.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut perm1: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut count: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        perm1.push(i);\n        count.push(0);\n    }\n    let mut i = (0_i64).max(n);\n    let mut maxFlips = 0;\n    let mut checksum = 0;\n    let mut permCount = 0;\n    let mut r = n;\n    let mut done = 0;\n    while (done == 0) {\n        while (r > 1) {\n            count[(r - 1) as usize] = r;\n            r = (r - 1);\n        }\n        let mut perm: Vec<i64> = perm1[..n as usize].to_vec();\n        i = n + 1;\n        let mut flips = 0;\n        while (perm[0] != 0) {\n            let k = (perm[0] + 1);\n            let mut lo = 1;\n            let mut hi = k;\n            unsafe { std::hint::assert_unchecked((hi as usize) <= perm.len()); }\n            while (lo < hi) {\n                let __swap_tmp = perm[(lo - 1) as usize];\n                perm[(lo - 1) as usize] = perm[(hi - 1) as usize];\n                perm[(hi - 1) as usize] = __swap_tmp;\n                lo = (lo + 1);\n                hi = (hi - 1);\n            }\n            flips = (flips + 1);\n        }\n        if (flips > maxFlips) {\n            maxFlips = flips;\n        }\n        if ((permCount % 2) == 0) {\n            checksum = (checksum + flips);\n        } else {\n            checksum = (checksum - flips);\n        }\n        permCount = (permCount + 1);\n        done = 1;\n        while (done == 1) {\n            if (r == n) {\n                done = 2;\n            } else {\n                perm1[0..=(r as usize)].rotate_left(1);\n                count[(r) as usize] = (count[r as usize] - 1);\n                if (count[r as usize] > 0) {\n                    done = 0;\n                } else {\n                    r = (r + 1);\n                }\n            }\n        }\n    }\n    show(&checksum);\n    show(&maxFlips);\n}",
      "scaling": {
        "8": {
          "c": {
            "mean_ms": 1.9683951800000005000,
            "median_ms": 1.9901829800000005000,
            "stddev_ms": 0.6147293841939809000,
            "min_ms": 1.0475779800000005000,
            "max_ms": 2.96782898000,
            "cv": 0.31229978128374645981,
            "runs": 10,
            "user_ms": 2.2370999999999997000,
            "system_ms": 0.43250000000000027000
          },
          "cpp": {
            "mean_ms": 1.6147157800000002000,
            "median_ms": 1.5403699800000002000,
            "stddev_ms": 0.36484150399707056000,
            "min_ms": 1.2049119800000008000,
            "max_ms": 2.3372869800000005000,
            "cv": 0.22594781602807555073,
            "runs": 10,
            "user_ms": 2.1509000,
            "system_ms": 0.40050000000000025000
          },
          "rust": {
            "mean_ms": 2.6018865800000006000,
            "median_ms": 2.4904324800000006000,
            "stddev_ms": 0.40669796821643674000,
            "min_ms": 2.166911980000001000,
            "max_ms": 3.5627029800000005000,
            "cv": 0.15630887654466346731,
            "runs": 10,
            "user_ms": 3.2753000000000005000,
            "system_ms": 0.32590000000000033000
          },
          "zig": {
            "mean_ms": 1.6596824800000007000,
            "median_ms": 1.6838284800000007000,
            "stddev_ms": 0.31421521513243483000,
            "min_ms": 1.1896619800000003000,
            "max_ms": 2.1159109800000008000,
            "cv": 0.18932248723408509890,
            "runs": 10,
            "user_ms": 2.1883000,
            "system_ms": 0.4065000000000003000
          },
          "go": {
            "mean_ms": 2.0215783800000007000,
            "median_ms": 1.9223284800000007000,
            "stddev_ms": 0.2569587255914847000,
            "min_ms": 1.7800359800000005000,
            "max_ms": 2.5317449800000003000,
            "cv": 0.12710797074881885659,
            "runs": 10,
            "user_ms": 2.384000,
            "system_ms": 0.6982000000000002000
          },
          "java": {
            "mean_ms": 71.80664117999999000,
            "median_ms": 61.67218298000,
            "stddev_ms": 19.349606562911598000,
            "min_ms": 59.905161979999996000,
            "max_ms": 118.80299498000,
            "cv": 0.26946820300934734090,
            "runs": 10,
            "user_ms": 44.17999999999999000,
            "system_ms": 28.4733000
          },
          "js": {
            "mean_ms": 50.64614078000,
            "median_ms": 48.708557480000005000,
            "stddev_ms": 6.451517836469194000,
            "min_ms": 47.271869980000006000,
            "max_ms": 68.90282798000,
            "cv": 0.12738419427639544621,
            "runs": 10,
            "user_ms": 41.06539999999999000,
            "system_ms": 5.413000
          },
          "python": {
            "mean_ms": 239.96434088000002000,
            "median_ms": 240.34686998000004000,
            "stddev_ms": 13.86064986993875000,
            "min_ms": 218.34645298000002000,
            "max_ms": 258.04870298000004000,
            "cv": 0.05776128994461766149,
            "runs": 10,
            "user_ms": 106.3361000,
            "system_ms": 11.968399999999999000
          },
          "ruby": {
            "mean_ms": 150.04211178000004000,
            "median_ms": 146.19655748000002000,
            "stddev_ms": 9.209490845523458000,
            "min_ms": 143.57907798000002000,
            "max_ms": 172.16141198000,
            "cv": 0.06137937367228553642,
            "runs": 10,
            "user_ms": 123.63709999999999000,
            "system_ms": 17.080999999999995000
          },
          "nim": {
            "mean_ms": 3.0032489800000004000,
            "median_ms": 2.953932480000001000,
            "stddev_ms": 0.2288573480479828000,
            "min_ms": 2.7234949800000003000,
            "max_ms": 3.39374498000,
            "cv": 0.07620325506544674478,
            "runs": 10,
            "user_ms": 3.2181000,
            "system_ms": 0.5166000000000003000
          },
          "logos_release": {
            "mean_ms": 5.40017418000,
            "median_ms": 5.053724480000001000,
            "stddev_ms": 1.6747339128312497000,
            "min_ms": 3.92832798000,
            "max_ms": 9.275535980000001000,
            "cv": 0.31012590650015842637,
            "runs": 10,
            "user_ms": 4.2997000,
            "system_ms": 1.1058000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "strings",
      "name": "String Assembly",
      "description": "String concatenation and assembly. Measures allocator throughput and GC pressure.",
      "reference_size": "10000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "500000",
        "5000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable result be \"\" with capacity n * 6.\nLet mutable i be 0.\nWhile i is less than n:\n    Set result to result + i + \" \".\n    Set i to i + 1.\nLet mutable count be 0.\nSet i to 1.\nWhile i is at most length of result:\n    If item i of result equals \" \":\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut result = String::with_capacity(((n * 6)) as usize);\n    for i in 0..n {\n        write!(result, \"{}{}\", i, \" \").unwrap();\n    }\n    let mut i = (0_i64).max(n);\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked(((result.len() as i64) as usize) <= result.len()); }\n    for i in 1..((result.len() as i64) + 1) {\n        if (result.logos_get_char(i) == ' ') {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "10000": {
          "c": {
            "mean_ms": 1.8818705799999989000,
            "median_ms": 1.8249458799999992000,
            "stddev_ms": 0.3643565548613825000,
            "min_ms": 1.2793208799999987000,
            "max_ms": 2.4642788799999994000,
            "cv": 0.19361403421343815948,
            "runs": 10,
            "user_ms": 0.9939200000000001000,
            "system_ms": 0.4986200000000003000
          },
          "cpp": {
            "mean_ms": 2.8111500799999994000,
            "median_ms": 2.150549879999999000,
            "stddev_ms": 1.7335961911661998000,
            "min_ms": 1.6555708799999985000,
            "max_ms": 7.167236879999999000,
            "cv": 0.61668574847707887940,
            "runs": 10,
            "user_ms": 0.7323200000000001000,
            "system_ms": 0.6326200000000003000
          },
          "rust": {
            "mean_ms": 2.348133279999999000,
            "median_ms": 2.331966879999999000,
            "stddev_ms": 0.3704409440230805000,
            "min_ms": 1.7279038799999993000,
            "max_ms": 2.870111879999999000,
            "cv": 0.15775976056311448290,
            "runs": 10,
            "user_ms": 1.1297200000000003000,
            "system_ms": 0.5700200000000003000
          },
          "zig": {
            "mean_ms": 1.3528876799999991000,
            "median_ms": 1.2508628799999988000,
            "stddev_ms": 0.30103568499055604000,
            "min_ms": 0.9599878799999989000,
            "max_ms": 1.8753208799999989000,
            "cv": 0.22251343510686433352,
            "runs": 10,
            "user_ms": 0.6250200000000001000,
            "system_ms": 0.3977200000000003000
          },
          "go": {
            "mean_ms": 3.960908479999999000,
            "median_ms": 2.736383879999999000,
            "stddev_ms": 3.0094464073978865000,
            "min_ms": 2.111529879999999000,
            "max_ms": 11.75102888000,
            "cv": 0.75978690812817953819,
            "runs": 10,
            "user_ms": 1.2912200000000003000,
            "system_ms": 1.0934200000000003000
          },
          "java": {
            "mean_ms": 72.13895828000,
            "median_ms": 65.34167538000,
            "stddev_ms": 15.706176510831713000,
            "min_ms": 63.24607088000,
            "max_ms": 114.58027888000001000,
            "cv": 0.21772114382175845581,
            "runs": 10,
            "user_ms": 29.17012000,
            "system_ms": 29.526919999999995000
          },
          "js": {
            "mean_ms": 49.222000179999996000,
            "median_ms": 48.16538388000,
            "stddev_ms": 3.273835515935639000,
            "min_ms": 47.23794588000,
            "max_ms": 58.347070880000004000,
            "cv": 0.06651163105854182429,
            "runs": 10,
            "user_ms": 38.81942000,
            "system_ms": 5.35482000
          },
          "python": {
            "mean_ms": 206.30758358000004000,
            "median_ms": 195.49746688000003000,
            "stddev_ms": 46.688097116672635000,
            "min_ms": 151.43194588000003000,
            "max_ms": 283.64102888000,
            "cv": 0.22630334913776137568,
            "runs": 10,
            "user_ms": 25.43652000,
            "system_ms": 14.674119999999999000
          },
          "ruby": {
            "mean_ms": 82.20377488000,
            "median_ms": 76.25948737999999000,
            "stddev_ms": 19.86478759056173000,
            "min_ms": 63.52598688000,
            "max_ms": 121.90257088000002000,
            "cv": 0.24165298515256857995,
            "runs": 10,
            "user_ms": 44.04652000,
            "system_ms": 20.60952000
          },
          "nim": {
            "mean_ms": 1.9652168799999988000,
            "median_ms": 1.937904879999999000,
            "stddev_ms": 0.28184383830017954000,
            "min_ms": 1.395736879999999000,
            "max_ms": 2.5285288799999986000,
            "cv": 0.14341614972296579912,
            "runs": 10,
            "user_ms": 0.89262000,
            "system_ms": 0.6231200000000004000
          },
          "logos_release": {
            "mean_ms": 3.280941679999999000,
            "median_ms": 3.245862379999999000,
            "stddev_ms": 0.29557514301322595000,
            "min_ms": 2.8143618799999987000,
            "max_ms": 3.708403879999999000,
            "cv": 0.09008850867877238222,
            "runs": 10,
            "user_ms": 1.83682000,
            "system_ms": 0.9023200000000004000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "binary_trees",
      "name": "Binary Trees",
      "description": "Recursive tree creation and checksum. Measures allocation pressure.",
      "reference_size": "14",
      "sizes": [
        "10",
        "12",
        "14",
        "16",
        "18",
        "20",
        "25",
        "30"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To makeCheck (depth: Int) -> Int:\n    If depth equals 0:\n        Return 1.\n    Return 1 + makeCheck(depth - 1) + makeCheck(depth - 1).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet minDepth be 4.\nLet mutable maxDepth be n.\nIf minDepth + 2 is greater than maxDepth:\n    Set maxDepth to minDepth + 2.\n\nLet stretchCheck be makeCheck(maxDepth + 1).\nShow \"stretch tree of depth \" + (maxDepth + 1) + \" check: \" + stretchCheck.\n\nLet longLived be makeCheck(maxDepth).\n\nLet mutable depth be minDepth.\nWhile depth is at most maxDepth:\n    Let mutable iterations be 1.\n    Let mutable p be 0.\n    While p is less than maxDepth - depth + minDepth:\n        Set iterations to iterations * 2.\n        Set p to p + 1.\n    Let mutable totalCheck be 0.\n    Let mutable i be 0.\n    While i is less than iterations:\n        Set totalCheck to totalCheck + makeCheck(depth).\n        Set i to i + 1.\n    Show \"\" + iterations + \" trees of depth \" + depth + \" check: \" + totalCheck.\n    Set depth to depth + 2.\nShow \"long lived tree of depth \" + maxDepth + \" check: \" + longLived.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn makeCheck(depth: i64) -> i64 {\n    if depth == 0 { return 1; }\n    (2i64 << depth) - 1\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let minDepth = 4;\n    let mut maxDepth = n;\n    if ((minDepth + 2) > maxDepth) {\n        maxDepth = (minDepth + 2);\n    }\n    let stretchCheck = makeCheck((maxDepth + 1));\n    show(&format!(\"{}{}{}{}\", \"stretch tree of depth \", (maxDepth + 1), \" check: \", stretchCheck));\n    let longLived = makeCheck(maxDepth);\n    let mut depth = minDepth;\n    while (depth <= maxDepth) {\n        let mut iterations = 1;\n        for p in 0..((maxDepth - depth) + minDepth) {\n            iterations = (iterations * 2);\n        }\n        let mut totalCheck = 0;\n        for i in 0..iterations {\n            totalCheck = (totalCheck + makeCheck(depth));\n        }\n        show(&format!(\"{}{}{}{}{}{}\", \"\", iterations, \" trees of depth \", depth, \" check: \", totalCheck));\n        depth = (depth + 2);\n    }\n    show(&format!(\"{}{}{}{}\", \"long lived tree of depth \", maxDepth, \" check: \", longLived));\n}",
      "scaling": {
        "14": {
          "c": {
            "mean_ms": 0.40821107800000035000,
            "median_ms": 0.3650399200000004000,
            "stddev_ms": 0.3781293954263169000,
            "min_ms": 0,
            "max_ms": 1.2613734200000006000,
            "cv": 0.92630850999667523915,
            "runs": 10,
            "user_ms": 0.40534000,
            "system_ms": 0.4032799999999998000
          },
          "cpp": {
            "mean_ms": 1.8670735200000007000,
            "median_ms": 0.9231654200000006000,
            "stddev_ms": 1.9822051020947718000,
            "min_ms": 0.05604042000000031000,
            "max_ms": 6.222790420000001000,
            "cv": 1.06166419311370826834,
            "runs": 10,
            "user_ms": 0.5576400000000002000,
            "system_ms": 0.9085799999999998000
          },
          "rust": {
            "mean_ms": 5.22487352000,
            "median_ms": 1.0837484200000003000,
            "stddev_ms": 11.321888469751183000,
            "min_ms": 0.47395642000000026000,
            "max_ms": 36.96566542000,
            "cv": 2.16692106065587268034,
            "runs": 10,
            "user_ms": 0.73554000,
            "system_ms": 0.7112799999999999000
          },
          "zig": {
            "mean_ms": 1.1489985200000003000,
            "median_ms": 0.8289779200000005000,
            "stddev_ms": 0.707087825217781000,
            "min_ms": 0.18491541999999996000,
            "max_ms": 2.3130404200000006000,
            "cv": 0.61539489643361839611,
            "runs": 10,
            "user_ms": 0.6049400000000001000,
            "system_ms": 0.6505799999999999000
          },
          "go": {
            "mean_ms": 7.121565120000001000,
            "median_ms": 7.088477920000001000,
            "stddev_ms": 0.9285010940985658000,
            "min_ms": 5.27303942000,
            "max_ms": 8.611832420000002000,
            "cv": 0.13037879713982951961,
            "runs": 10,
            "user_ms": 4.97144000,
            "system_ms": 1.6377799999999995000
          },
          "java": {
            "mean_ms": 80.62400662000,
            "median_ms": 75.38470692000,
            "stddev_ms": 16.64443365201195000,
            "min_ms": 68.61399842000,
            "max_ms": 126.50670642000,
            "cv": 0.20644513154079652708,
            "runs": 10,
            "user_ms": 54.890839999999996000,
            "system_ms": 33.686680000000004000
          },
          "js": {
            "mean_ms": 56.964544019999994000,
            "median_ms": 55.68201942000,
            "stddev_ms": 4.813057329511096000,
            "min_ms": 54.599206420000004000,
            "max_ms": 70.59103942000,
            "cv": 0.08449215933021869393,
            "runs": 10,
            "user_ms": 46.59434000,
            "system_ms": 5.49008000
          },
          "python": {
            "mean_ms": 413.67664412000005000,
            "median_ms": 403.53174842000006000,
            "stddev_ms": 32.21174073914624000,
            "min_ms": 380.45383142000,
            "max_ms": 487.17395642000005000,
            "cv": 0.07786695525842208649,
            "runs": 10,
            "user_ms": 248.13864000,
            "system_ms": 15.56348000
          },
          "ruby": {
            "mean_ms": 170.95159002000002000,
            "median_ms": 167.22231092000,
            "stddev_ms": 13.036880105934382000,
            "min_ms": 164.75320642000002000,
            "max_ms": 207.76678942000001000,
            "cv": 0.07626065428469643007,
            "runs": 10,
            "user_ms": 148.08833999999998000,
            "system_ms": 14.70198000
          },
          "nim": {
            "mean_ms": 6.444244220000001000,
            "median_ms": 6.46222742000,
            "stddev_ms": 0.29885599680738067000,
            "min_ms": 6.084332420000001000,
            "max_ms": 6.84862342000,
            "cv": 0.04637564726052244860,
            "runs": 10,
            "user_ms": 6.435939999999999000,
            "system_ms": 0.45217999999999983000
          },
          "logos_release": {
            "mean_ms": 1.5027735200000005000,
            "median_ms": 1.5173734200000007000,
            "stddev_ms": 0.4124522687246367000,
            "min_ms": 0.8115404200000004000,
            "max_ms": 2.03528942000,
            "cv": 0.27446069766030783053,
            "runs": 10,
            "user_ms": 1.44904000,
            "system_ms": 0.5550799999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "loop_sum",
      "name": "Loop Sum",
      "description": "Pure loop accumulation. Measures raw loop overhead with minimal body.",
      "reference_size": "10000000",
      "sizes": [
        "100000",
        "10000000",
        "50000000",
        "100000000",
        "500000000",
        "1000000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Set sum to (sum + i) % 1000000007.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0;\n    for i in 1..(n + 1) {\n        sum = ((sum + i) % 1000000007);\n    }\n    show(&sum);\n}",
      "scaling": {
        "10000000": {
          "c": {
            "mean_ms": 41.37220432000,
            "median_ms": 37.81062121999999000,
            "stddev_ms": 10.552272622420941000,
            "min_ms": 36.46810072000,
            "max_ms": 70.99551672000,
            "cv": 0.25505705571795699282,
            "runs": 10,
            "user_ms": 35.95834000,
            "system_ms": 1.0155799999999999000
          },
          "cpp": {
            "mean_ms": 37.28157942000,
            "median_ms": 37.51360022000,
            "stddev_ms": 0.7127874734472712000,
            "min_ms": 36.01872572000,
            "max_ms": 38.12839172000,
            "cv": 0.01911902565653886130,
            "runs": 10,
            "user_ms": 35.81144000,
            "system_ms": 0.7097799999999999000
          },
          "rust": {
            "mean_ms": 41.907933220000006000,
            "median_ms": 38.531245719999996000,
            "stddev_ms": 9.411229897584509000,
            "min_ms": 37.11380872000,
            "max_ms": 68.12455772000,
            "cv": 0.22456917281459072756,
            "runs": 10,
            "user_ms": 36.637039999999996000,
            "system_ms": 1.39378000
          },
          "zig": {
            "mean_ms": 51.18256682000,
            "median_ms": 47.54053772000,
            "stddev_ms": 8.282143756598739000,
            "min_ms": 46.92822472000,
            "max_ms": 71.51401672000,
            "cv": 0.16181571717037107753,
            "runs": 10,
            "user_ms": 45.84614000,
            "system_ms": 0.96148000
          },
          "go": {
            "mean_ms": 42.12637912000,
            "median_ms": 39.14105822000,
            "stddev_ms": 9.350414198048282000,
            "min_ms": 38.35959972000,
            "max_ms": 68.70830872000,
            "cv": 0.22196102284065191691,
            "runs": 10,
            "user_ms": 36.85074000000001000,
            "system_ms": 1.3172799999999999000
          },
          "java": {
            "mean_ms": 93.34869162000001000,
            "median_ms": 87.43587072000,
            "stddev_ms": 13.283872622359883000,
            "min_ms": 83.10268272000,
            "max_ms": 121.71435072000002000,
            "cv": 0.14230379014239772991,
            "runs": 10,
            "user_ms": 57.78194000,
            "system_ms": 28.720579999999996000
          },
          "js": {
            "mean_ms": 85.63346252000,
            "median_ms": 85.61376672000001000,
            "stddev_ms": 0.979150299792269000,
            "min_ms": 83.48472472000,
            "max_ms": 87.01830772000001000,
            "cv": 0.01143420189932860605,
            "runs": 10,
            "user_ms": 75.05374000,
            "system_ms": 5.289380000000001000
          },
          "python": {
            "mean_ms": 844.14892942000,
            "median_ms": 854.8674337200001000,
            "stddev_ms": 46.47518130649707000,
            "min_ms": 785.27018272000,
            "max_ms": 897.40389172000,
            "cv": 0.05505566575607618923,
            "runs": 10,
            "user_ms": 698.5037399999999000,
            "system_ms": 15.432479999999998000
          },
          "ruby": {
            "mean_ms": 398.90685002000004000,
            "median_ms": 399.36926672000006000,
            "stddev_ms": 2.3038610463640805000,
            "min_ms": 395.41430872000005000,
            "max_ms": 402.11672472000004000,
            "cv": 0.00577543616071915422,
            "runs": 10,
            "user_ms": 375.13233999999995000,
            "system_ms": 16.652379999999994000
          },
          "nim": {
            "mean_ms": 44.648041619999995000,
            "median_ms": 38.54412122000,
            "stddev_ms": 13.386086131890977000,
            "min_ms": 37.74001672000,
            "max_ms": 75.14497472000001000,
            "cv": 0.29981351132531439570,
            "runs": 10,
            "user_ms": 37.32794000,
            "system_ms": 0.8219800000000001000
          },
          "logos_release": {
            "mean_ms": 38.071695919999995000,
            "median_ms": 38.15264172000,
            "stddev_ms": 0.5010084147908976000,
            "min_ms": 37.09314172000,
            "max_ms": 38.594641719999996000,
            "cv": 0.01315960328753586204,
            "runs": 10,
            "user_ms": 36.29064000,
            "system_ms": 0.98678000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "fib_iterative",
      "name": "Iterative Fibonacci",
      "description": "Iterative fibonacci mod. Measures loop + data dependency chain.",
      "reference_size": "10000000",
      "sizes": [
        "100000",
        "10000000",
        "50000000",
        "100000000",
        "500000000",
        "1000000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable a be 0.\nLet mutable b be 1.\nLet mutable i be 0.\nWhile i is less than n:\n    Let temp be b.\n    Set b to (a + b) % 1000000007.\n    Set a to temp.\n    Set i to i + 1.\nShow a.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut a = 0;\n    let mut b = 1;\n    for i in 0..n {\n        let temp = b;\n        b = ((a + b) % 1000000007);\n        a = temp;\n    }\n    show(&a);\n}",
      "scaling": {
        "10000000": {
          "c": {
            "mean_ms": 40.60964684000,
            "median_ms": 36.600721940000004000,
            "stddev_ms": 12.752515130169065000,
            "min_ms": 35.598992940000004000,
            "max_ms": 76.87282594000,
            "cv": 0.31402674296610713889,
            "runs": 10,
            "user_ms": 35.23728000,
            "system_ms": 0.8019000
          },
          "cpp": {
            "mean_ms": 38.78654254000001000,
            "median_ms": 37.266242940000006000,
            "stddev_ms": 4.417724465994789000,
            "min_ms": 36.46199194000,
            "max_ms": 51.15332594000001000,
            "cv": 0.11389838270422924530,
            "runs": 10,
            "user_ms": 35.769880000000004000,
            "system_ms": 0.8145999999999999000
          },
          "rust": {
            "mean_ms": 42.70068424000001000,
            "median_ms": 39.471346940000006000,
            "stddev_ms": 9.761457344130368000,
            "min_ms": 36.539075940000006000,
            "max_ms": 69.05320094000,
            "cv": 0.22860189521240247259,
            "runs": 10,
            "user_ms": 36.21828000,
            "system_ms": 1.3149999999999998000
          },
          "zig": {
            "mean_ms": 50.823425940000014000,
            "median_ms": 50.166617440000005000,
            "stddev_ms": 5.003321229541587000,
            "min_ms": 46.59661794000,
            "max_ms": 64.24957594000,
            "cv": 0.09844517832088486756,
            "runs": 10,
            "user_ms": 46.093779999999994000,
            "system_ms": 1.3449000
          },
          "go": {
            "mean_ms": 37.63565934000,
            "median_ms": 37.57701344000,
            "stddev_ms": 0.5532976895202876000,
            "min_ms": 36.827242940000005000,
            "max_ms": 38.96432594000,
            "cv": 0.01470142145038045718,
            "runs": 10,
            "user_ms": 35.934480000000005000,
            "system_ms": 1.2128999999999998000
          },
          "java": {
            "mean_ms": 94.11113433999999000,
            "median_ms": 87.81222193999999000,
            "stddev_ms": 15.581309752286499000,
            "min_ms": 83.96745094000,
            "max_ms": 125.83286794000,
            "cv": 0.16556287267769107898,
            "runs": 10,
            "user_ms": 57.16278000,
            "system_ms": 28.387799999999998000
          },
          "js": {
            "mean_ms": 85.05938014000,
            "median_ms": 84.94057594000,
            "stddev_ms": 0.7507917561904326000,
            "min_ms": 83.85945094000,
            "max_ms": 86.25632594000,
            "cv": 0.00882667796255624817,
            "runs": 10,
            "user_ms": 74.32668000,
            "system_ms": 5.2959999999999995000
          },
          "python": {
            "mean_ms": 1111.1564385400001000,
            "median_ms": 1121.66817994000,
            "stddev_ms": 45.166852910508815000,
            "min_ms": 1047.63011794000,
            "max_ms": 1173.56120094000,
            "cv": 0.04064850937628155637,
            "runs": 10,
            "user_ms": 955.2579800000001000,
            "system_ms": 16.6317000
          },
          "ruby": {
            "mean_ms": 684.94741344000,
            "median_ms": 679.47940944000,
            "stddev_ms": 17.228148859289503000,
            "min_ms": 665.15590994000,
            "max_ms": 724.70803394000,
            "cv": 0.02515251320209365794,
            "runs": 10,
            "user_ms": 652.85478000,
            "system_ms": 17.851899999999997000
          },
          "nim": {
            "mean_ms": 39.07110904000,
            "median_ms": 39.099075440000006000,
            "stddev_ms": 0.7514342118917879000,
            "min_ms": 38.01665894000,
            "max_ms": 40.19724194000,
            "cv": 0.01923247715140332499,
            "runs": 10,
            "user_ms": 37.233880000000004000,
            "system_ms": 1.0661999999999998000
          },
          "logos_release": {
            "mean_ms": 37.62164254000001000,
            "median_ms": 36.11982594000,
            "stddev_ms": 3.293992606708939000,
            "min_ms": 34.91190894000001000,
            "max_ms": 45.28978394000,
            "cv": 0.08755578928290296079,
            "runs": 10,
            "user_ms": 34.165480000000005000,
            "system_ms": 1.4778999999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "graph_bfs",
      "name": "Graph BFS",
      "description": "BFS on generated graph. Measures queue operations and random access.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable adj be a new Seq of Int.\nLet mutable adjStarts be a new Seq of Int.\nLet mutable adjCounts be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push i * 5 to adjStarts.\n    Push 0 to adjCounts.\n    Push 0 to adj. Push 0 to adj. Push 0 to adj. Push 0 to adj. Push 0 to adj.\n    Set i to i + 1.\nLet mutable primes be a new Seq of Int.\nPush 31 to primes. Push 37 to primes. Push 41 to primes. Push 43 to primes. Push 47 to primes.\nLet mutable offsets be a new Seq of Int.\nPush 7 to offsets. Push 13 to offsets. Push 17 to offsets. Push 23 to offsets. Push 29 to offsets.\nLet mutable p be 1.\nWhile p is at most 5:\n    Set i to 0.\n    While i is less than n:\n        Let neighbor be (i * item p of primes + item p of offsets) % n.\n        If neighbor is not i:\n            Let start be item (i + 1) of adjStarts.\n            Let cnt be item (i + 1) of adjCounts.\n            Set item (start + cnt + 1) of adj to neighbor.\n            Set item (i + 1) of adjCounts to cnt + 1.\n        Set i to i + 1.\n    Set p to p + 1.\nLet mutable queue be a new Seq of Int.\nLet mutable dist be a new Seq of Int.\nSet i to 0.\nWhile i is less than n:\n    Push 0 - 1 to dist.\n    Set i to i + 1.\nPush 0 to queue.\nSet item 1 of dist to 0.\nLet mutable front be 1.\nWhile front is at most length of queue:\n    Let v be item front of queue.\n    Let start be item (v + 1) of adjStarts.\n    Let cnt be item (v + 1) of adjCounts.\n    Let mutable e be 0.\n    While e is less than cnt:\n        Let u be item (start + e + 1) of adj.\n        If item (u + 1) of dist equals 0 - 1:\n            Set item (u + 1) of dist to item (v + 1) of dist + 1.\n            Push u to queue.\n        Set e to e + 1.\n    Set front to front + 1.\nLet mutable reachable be 0.\nLet mutable totalDist be 0.\nSet i to 0.\nWhile i is less than n:\n    If item (i + 1) of dist is at least 0:\n        Set reachable to reachable + 1.\n        Set totalDist to totalDist + item (i + 1) of dist.\n    Set i to i + 1.\nShow \"\" + reachable + \" \" + totalDist.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut adj: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut adjStarts: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut adjCounts: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        adjStarts.push((i * 5));\n        adjCounts.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n    }\n    let mut i = (0_i64).max(n);\n    let mut primes = Seq::<i64>::default();\n    primes.push(31);\n    primes.push(37);\n    primes.push(41);\n    primes.push(43);\n    primes.push(47);\n    let mut offsets = Seq::<i64>::default();\n    offsets.push(7);\n    offsets.push(13);\n    offsets.push(17);\n    offsets.push(23);\n    offsets.push(29);\n    for p in 0..5 {\n        unsafe { std::hint::assert_unchecked((n as usize) <= adjStarts.len()); }\n        unsafe { std::hint::assert_unchecked((n as usize) <= adjCounts.len()); }\n        for i in 0..n {\n            let neighbor = (((i * primes[p as usize]) + offsets[p as usize]) % n);\n            if (neighbor != i) {\n                let start = adjStarts[i as usize];\n                let cnt = adjCounts[i as usize];\n                adj[((start + cnt)) as usize] = neighbor;\n                adjCounts[(i) as usize] = (cnt + 1);\n            }\n        }\n    }\n    let mut queue = Seq::<i64>::default();\n    let mut dist: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        dist.push((0 - 1));\n    }\n    i = (0_i64).max(n);\n    queue.push(0);\n    dist[0] = 0;\n    let mut front = 1;\n    unsafe { std::hint::assert_unchecked(((queue.len() as i64) as usize) <= queue.len()); }\n    while (front <= (queue.len() as i64)) {\n        let v = queue[(front - 1) as usize];\n        let start = adjStarts[v as usize];\n        let cnt = adjCounts[v as usize];\n        unsafe { std::hint::assert_unchecked((cnt as usize) <= adj.len()); }\n        for e in 0..cnt {\n            let u = adj[((start + e)) as usize];\n            if (dist[u as usize] == (0 - 1)) {\n                dist[(u) as usize] = (dist[v as usize] + 1);\n                queue.push(u);\n            }\n        }\n        front = (front + 1);\n    }\n    let mut reachable = 0;\n    let mut totalDist = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= dist.len()); }\n    for i in 0..n {\n        if (dist[i as usize] >= 0) {\n            reachable = (reachable + 1);\n            totalDist = (totalDist + dist[i as usize]);\n        }\n    }\n    show(&format!(\"{}{}{}{}\", \"\", reachable, \" \", totalDist));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.7654985000000005000,
            "median_ms": 1.7420610000000005000,
            "stddev_ms": 0.27181735398118593000,
            "min_ms": 1.3479365000000003000,
            "max_ms": 2.1379775000000003000,
            "cv": 0.15396068248213513238,
            "runs": 10,
            "user_ms": 0.6139800000000003000,
            "system_ms": 0.6000199999999999000
          },
          "cpp": {
            "mean_ms": 2.138056700000001000,
            "median_ms": 2.1421025000000005000,
            "stddev_ms": 0.34529329188541535000,
            "min_ms": 1.5954775000000007000,
            "max_ms": 2.6183525000,
            "cv": 0.16149865992114015895,
            "runs": 10,
            "user_ms": 0.6952800000000004000,
            "system_ms": 0.8232199999999998000
          },
          "rust": {
            "mean_ms": 2.2944945000000004000,
            "median_ms": 2.1556655000000004000,
            "stddev_ms": 0.375570393066629000,
            "min_ms": 1.9238525000000004000,
            "max_ms": 3.1227695000000002000,
            "cv": 0.16368328320971304770,
            "runs": 10,
            "user_ms": 0.8889800000000004000,
            "system_ms": 0.79272000
          },
          "zig": {
            "mean_ms": 1.6513442000000006000,
            "median_ms": 1.6057280000000007000,
            "stddev_ms": 0.21006215721968796000,
            "min_ms": 1.4125605000000004000,
            "max_ms": 2.0723105000,
            "cv": 0.12720676720194849969,
            "runs": 10,
            "user_ms": 0.6720800000000002000,
            "system_ms": 0.6000199999999999000
          },
          "go": {
            "mean_ms": 7.2692567000000015000,
            "median_ms": 2.5017275000000006000,
            "stddev_ms": 14.98103426960406000,
            "min_ms": 2.0681435000000008000,
            "max_ms": 49.8959355000,
            "cv": 2.06087566966840735018,
            "runs": 10,
            "user_ms": 1.13578000,
            "system_ms": 1.1091199999999997000
          },
          "java": {
            "mean_ms": 65.6814523000,
            "median_ms": 61.2699145000,
            "stddev_ms": 11.982034513277312000,
            "min_ms": 57.971852500000004000,
            "max_ms": 97.5024775000,
            "cv": 0.18242645516651147496,
            "runs": 10,
            "user_ms": 34.04738000,
            "system_ms": 28.882519999999995000
          },
          "js": {
            "mean_ms": 47.2839984000,
            "median_ms": 47.265519000,
            "stddev_ms": 1.0328958967901264000,
            "min_ms": 45.7266025000,
            "max_ms": 49.5598115000,
            "cv": 0.02184451255691875668,
            "runs": 10,
            "user_ms": 37.72558000,
            "system_ms": 5.41962000
          },
          "python": {
            "mean_ms": 164.21234000,
            "median_ms": 160.2740605000,
            "stddev_ms": 14.410643128179308000,
            "min_ms": 151.83018550000002000,
            "max_ms": 202.7844775000,
            "cv": 0.08775615235846044213,
            "runs": 10,
            "user_ms": 34.09968000000001000,
            "system_ms": 11.97512000
          },
          "ruby": {
            "mean_ms": 65.4406357000,
            "median_ms": 64.84554000000001000,
            "stddev_ms": 2.472068447355002000,
            "min_ms": 63.1454775000,
            "max_ms": 71.5257685000,
            "cv": 0.03777574011792495469,
            "runs": 10,
            "user_ms": 43.74978000,
            "system_ms": 16.09882000
          },
          "nim": {
            "mean_ms": 1.958844100000001000,
            "median_ms": 1.9671445000000007000,
            "stddev_ms": 0.315689322858619000,
            "min_ms": 1.3339355000000007000,
            "max_ms": 2.438727500000001000,
            "cv": 0.16116102494252546123,
            "runs": 10,
            "user_ms": 0.7709800000000003000,
            "system_ms": 0.69952000
          },
          "logos_release": {
            "mean_ms": 3.1200984000,
            "median_ms": 3.2250610000000004000,
            "stddev_ms": 0.30611808189522424000,
            "min_ms": 2.4692275000000002000,
            "max_ms": 3.4166025000000005000,
            "cv": 0.09811167554690718728,
            "runs": 10,
            "user_ms": 1.6548799999999998000,
            "system_ms": 0.9416199999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "string_search",
      "name": "Naive String Search",
      "description": "Naive O(nm) string search. Measures character-level access and inner loop.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable text be \"\".\nLet mutable pos be 0.\nWhile pos is less than n:\n    If pos is greater than 0:\n        If pos % 1000 equals 0:\n            If pos + 5 is at most n:\n                Set text to text + \"XXXXX\".\n                Set pos to pos + 5.\n    If pos is less than n:\n        Let mutable ch be \"a\".\n        If pos % 5 equals 1:\n            Set ch to \"b\".\n        If pos % 5 equals 2:\n            Set ch to \"c\".\n        If pos % 5 equals 3:\n            Set ch to \"d\".\n        If pos % 5 equals 4:\n            Set ch to \"e\".\n        Set text to text + ch.\n        Set pos to pos + 1.\nLet needle be \"XXXXX\".\nLet needleLen be 5.\nLet textLen be length of text.\nLet mutable count be 0.\nLet mutable i be 1.\nWhile i is at most textLen - needleLen + 1:\n    Let mutable match be 1.\n    Let mutable j be 0.\n    While j is less than needleLen:\n        If item (i + j) of text is not item (j + 1) of needle:\n            Set match to 0.\n            Set j to needleLen.\n        Set j to j + 1.\n    If match equals 1:\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut text = String::from(\"\");\n    let mut pos = 0;\n    while (pos < n) {\n        if (pos > 0) {\n            if ((pos % 1000) == 0) {\n                if ((pos + 5) <= n) {\n                    text.push_str(\"XXXXX\");\n                    pos = (pos + 5);\n                }\n            }\n        }\n        if (pos < n) {\n            let mut ch: u8 = b'a';\n            if ((pos % 5) == 1) {\n                ch = b'b';\n            }\n            if ((pos % 5) == 2) {\n                ch = b'c';\n            }\n            if ((pos % 5) == 3) {\n                ch = b'd';\n            }\n            if ((pos % 5) == 4) {\n                ch = b'e';\n            }\n            text.push(ch as char);\n            pos = (pos + 1);\n        }\n    }\n    let needle = String::from(\"XXXXX\");\n    let needleLen = 5;\n    let textLen = (text.len() as i64);\n    let mut count = 0;\n    for i in 1..(((textLen - needleLen) + 1) + 1) {\n        let mut r#match = 1;\n        let mut j = 0;\n        unsafe { std::hint::assert_unchecked((needleLen as usize) <= text.len()); }\n        unsafe { std::hint::assert_unchecked((needleLen as usize) <= needle.len()); }\n        while (j < needleLen) {\n            if (text.as_bytes()[((i + j) - 1) as usize] != needle.as_bytes()[(j) as usize]) {\n                r#match = 0;\n                break;\n            }\n            j = (j + 1);\n        }\n        if (r#match == 1) {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 1.5035240800000006000,
            "median_ms": 1.5046612800000002000,
            "stddev_ms": 0.2146819942984403000,
            "min_ms": 1.1434532800000006000,
            "max_ms": 1.8633282800000006000,
            "cv": 0.14278587031239314393,
            "runs": 10,
            "user_ms": 0.60154000,
            "system_ms": 0.6332399999999996000
          },
          "cpp": {
            "mean_ms": 1.5912285800000002000,
            "median_ms": 1.6667867799999999000,
            "stddev_ms": 0.424753758565556000,
            "min_ms": 1.0474952800000005000,
            "max_ms": 2.16457828000,
            "cv": 0.26693447057465241518,
            "runs": 10,
            "user_ms": 0.58764000,
            "system_ms": 0.6329399999999996000
          },
          "rust": {
            "mean_ms": 1.6433864800000004000,
            "median_ms": 1.52974478000,
            "stddev_ms": 0.36033521211714946000,
            "min_ms": 1.16499528000,
            "max_ms": 2.30541128000,
            "cv": 0.21926382899118737565,
            "runs": 10,
            "user_ms": 0.79784000,
            "system_ms": 0.5255399999999997000
          },
          "zig": {
            "mean_ms": 1.38284488000,
            "median_ms": 1.44453678000,
            "stddev_ms": 0.2603693973032245000,
            "min_ms": 0.9191202800000004000,
            "max_ms": 1.6824942800000003000,
            "cv": 0.18828532474533549995,
            "runs": 10,
            "user_ms": 0.59344000,
            "system_ms": 0.4489399999999998000
          },
          "go": {
            "mean_ms": 2.55009518000,
            "median_ms": 2.6314952800000004000,
            "stddev_ms": 0.2747528618305914000,
            "min_ms": 2.01678628000,
            "max_ms": 2.8440782800000005000,
            "cv": 0.10774219879533727835,
            "runs": 10,
            "user_ms": 1.11944000,
            "system_ms": 1.0097399999999996000
          },
          "java": {
            "mean_ms": 52.61888668000,
            "median_ms": 51.68876578000,
            "stddev_ms": 3.236740479009337000,
            "min_ms": 50.19091128000,
            "max_ms": 61.51999428000,
            "cv": 0.06151290312722627524,
            "runs": 10,
            "user_ms": 23.02534000,
            "system_ms": 27.248239999999996000
          },
          "js": {
            "mean_ms": 49.770836779999994000,
            "median_ms": 48.16172378000,
            "stddev_ms": 5.395969754040107000,
            "min_ms": 47.25516228000,
            "max_ms": 65.03453628000001000,
            "cv": 0.10841629562893814080,
            "runs": 10,
            "user_ms": 37.96364000000001000,
            "system_ms": 5.52444000
          },
          "python": {
            "mean_ms": 207.06175328000,
            "median_ms": 195.71224528000003000,
            "stddev_ms": 29.1342135293851000,
            "min_ms": 181.43266228000002000,
            "max_ms": 275.07607828000,
            "cv": 0.14070301766443682650,
            "runs": 10,
            "user_ms": 44.77554000,
            "system_ms": 15.000840000000001000
          },
          "ruby": {
            "mean_ms": 86.21416568000,
            "median_ms": 81.34697428000001000,
            "stddev_ms": 12.29408942906374000,
            "min_ms": 77.84286928000,
            "max_ms": 114.52786928000001000,
            "cv": 0.14259941312539695854,
            "runs": 10,
            "user_ms": 56.83034000,
            "system_ms": 17.40884000
          },
          "nim": {
            "mean_ms": 3.47649498000,
            "median_ms": 3.5417867800000002000,
            "stddev_ms": 0.5050802726020776000,
            "min_ms": 2.9002872800000003000,
            "max_ms": 4.431578280000001000,
            "cv": 0.14528433825095803820,
            "runs": 10,
            "user_ms": 1.7047399999999997000,
            "system_ms": 0.8772399999999998000
          },
          "logos_release": {
            "mean_ms": 3.5400406800000007000,
            "median_ms": 3.4990572800000005000,
            "stddev_ms": 0.44100444555436293000,
            "min_ms": 2.8494952800000002000,
            "max_ms": 4.09728628000,
            "cv": 0.12457609542339011844,
            "runs": 10,
            "user_ms": 1.6402399999999998000,
            "system_ms": 0.9982399999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    }
  ],
  "summary": {
    "geometric_mean_speedup_vs_c": {
      "c": 1.000,
      "cpp": 0.787,
      "go": 0.547,
      "java": 0.034,
      "js": 0.043,
      "logos_release": 0.462,
      "nim": 0.680,
      "python": 0.008,
      "ruby": 0.019,
      "rust": 0.670,
      "zig": 0.843
    }
  }
}

{
  "schema_version": 1,
  "metadata": {
    "date": "2026-02-28T08:46:02Z",
    "commit": "3eff14e",
    "logos_version": "0.9.1",
    "cpu": "Apple M1 Max",
    "os": "macOS 15.2 arm64",
    "warmup": 3,
    "runs": 10,
    "versions": {
      "c": "Apple clang version 16.0.0 (clang-1600.0.26.6)",
      "cpp": "Apple clang version 16.0.0 (clang-1600.0.26.6)",
      "rust": "rustc 1.88.0 (6b00bc388 2025-06-23)",
      "zig": "0.15.2",
      "go": "go version go1.21.4 darwin/arm64",
      "java": "openjdk 21.0.8 2025-07-15",
      "node": "v22.8.0",
      "python": "Python 3.10.12",
      "ruby": "ruby 2.6.10p210 (2022-04-12 revision 67958) [universal.arm64e-darwin24]",
      "nim": "Nim Compiler Version 2.2.6 [MacOSX: arm64]"
    }
  },
  "languages": [
    {
      "id": "c",
      "label": "C",
      "color": "#555555",
      "tier": "systems"
    },
    {
      "id": "cpp",
      "label": "C++",
      "color": "#f34b7d",
      "tier": "systems"
    },
    {
      "id": "rust",
      "label": "Rust",
      "color": "#dea584",
      "tier": "systems"
    },
    {
      "id": "zig",
      "label": "Zig",
      "color": "#f7a41d",
      "tier": "systems"
    },
    {
      "id": "logos_release",
      "label": "LOGOS",
      "color": "#00d4ff",
      "tier": "systems"
    },
    {
      "id": "go",
      "label": "Go",
      "color": "#00ADD8",
      "tier": "managed"
    },
    {
      "id": "java",
      "label": "Java",
      "color": "#b07219",
      "tier": "managed"
    },
    {
      "id": "js",
      "label": "JavaScript",
      "color": "#f7df1e",
      "tier": "managed"
    },
    {
      "id": "python",
      "label": "Python",
      "color": "#3776ab",
      "tier": "interpreted"
    },
    {
      "id": "ruby",
      "label": "Ruby",
      "color": "#cc342d",
      "tier": "interpreted"
    },
    {
      "id": "nim",
      "label": "Nim",
      "color": "#ffe953",
      "tier": "transpiled"
    }
  ],
  "benchmarks": [
    {
      "id": "fib",
      "name": "Recursive Fibonacci",
      "description": "Naive recursive fibonacci. Measures function call overhead and recursion depth.",
      "reference_size": "25",
      "sizes": [
        "10",
        "15",
        "20",
        "25",
        "30",
        "35",
        "40"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To fib (n: Int) -> Int:\n    If n is less than 2:\n        Return n.\n    Return fib(n - 1) + fib(n - 2).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow fib(n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn fib(n: i64) -> i64 {\n    use std::cell::RefCell;\n    thread_local! {\n        static __MEMO_FIB: RefCell<FxHashMap<i64, i64>> = RefCell::new(FxHashMap::default());\n    }\n    if let Some(__v) = __MEMO_FIB.with(|c| c.borrow().get(&n).copied()) {\n        return __v;\n    }\n    let __memo_result = (|| -> i64 {\n        if (n < 2) {\n            return n;\n        }\n        return (fib((n - 1)) + fib((n - 2)));\n    })();\n    __MEMO_FIB.with(|c| c.borrow_mut().insert(n, __memo_result));\n    __memo_result\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&fib(n));\n}",
      "scaling": {
        "25": {
          "c": {
            "mean_ms": 2.5962694800000003000,
            "median_ms": 1.911902980000001000,
            "stddev_ms": 1.7785206990775133000,
            "min_ms": 1.2837149800000005000,
            "max_ms": 6.989006980000001000,
            "cv": 0.68502931331978415988,
            "runs": 10,
            "user_ms": 0.75256000,
            "system_ms": 0.6607000000000002000
          },
          "cpp": {
            "mean_ms": 1.801189880000001000,
            "median_ms": 1.6787564800000011000,
            "stddev_ms": 0.4965730566587692000,
            "min_ms": 1.3237979800000011000,
            "max_ms": 2.8787149800000005000,
            "cv": 0.27569167591523938848,
            "runs": 10,
            "user_ms": 0.7149599999999999000,
            "system_ms": 0.48220000000000034000
          },
          "rust": {
            "mean_ms": 1.9534276800000005000,
            "median_ms": 1.9228404800000006000,
            "stddev_ms": 0.4238841158013329000,
            "min_ms": 1.2112149800000008000,
            "max_ms": 2.6898399800000007000,
            "cv": 0.21699503910036372142,
            "runs": 10,
            "user_ms": 0.95316000,
            "system_ms": 0.5922000000000003000
          },
          "zig": {
            "mean_ms": 2.0013358800000007000,
            "median_ms": 1.9337984800000007000,
            "stddev_ms": 0.5804370277769541000,
            "min_ms": 1.3974649800000006000,
            "max_ms": 3.3636309800000007000,
            "cv": 0.29002479472708693804,
            "runs": 10,
            "user_ms": 0.7709599999999999000,
            "system_ms": 0.5623000000000002000
          },
          "go": {
            "mean_ms": 2.3736858800000008000,
            "median_ms": 2.3165274800000008000,
            "stddev_ms": 0.36537170722474163000,
            "min_ms": 1.8334229800000008000,
            "max_ms": 3.097089980000001000,
            "cv": 0.15392588813172765170,
            "runs": 10,
            "user_ms": 1.1467599999999997000,
            "system_ms": 0.8027000000000003000
          },
          "java": {
            "mean_ms": 53.446373479999996000,
            "median_ms": 51.57098598000,
            "stddev_ms": 7.152934893239702000,
            "min_ms": 49.11958998000,
            "max_ms": 73.29379898000,
            "cv": 0.13383386799698168286,
            "runs": 10,
            "user_ms": 20.978260000000002000,
            "system_ms": 28.0935000
          },
          "js": {
            "mean_ms": 46.64730678000,
            "median_ms": 46.54125648000,
            "stddev_ms": 0.4942697775638994000,
            "min_ms": 45.90571498000,
            "max_ms": 47.65075698000,
            "cv": 0.01059589098884090816,
            "runs": 10,
            "user_ms": 36.207960000000004000,
            "system_ms": 5.1088000
          },
          "python": {
            "mean_ms": 175.12996078000,
            "median_ms": 168.90781948000,
            "stddev_ms": 15.262277696498365000,
            "min_ms": 163.43863098000003000,
            "max_ms": 213.88633998000,
            "cv": 0.08714829620541621753,
            "runs": 10,
            "user_ms": 37.72146000,
            "system_ms": 12.053999999999999000
          },
          "ruby": {
            "mean_ms": 74.25800648000,
            "median_ms": 66.78942298000001000,
            "stddev_ms": 17.550868031692677000,
            "min_ms": 63.80921498000001000,
            "max_ms": 112.10504798000001000,
            "cv": 0.23634984109652437036,
            "runs": 10,
            "user_ms": 45.77196000,
            "system_ms": 15.9154000
          },
          "nim": {
            "mean_ms": 2.136081680000001000,
            "median_ms": 2.118840480000001000,
            "stddev_ms": 0.2489303935213169000,
            "min_ms": 1.663339980000001000,
            "max_ms": 2.5005899800000005000,
            "cv": 0.11653599010376643624,
            "runs": 10,
            "user_ms": 0.9979599999999998000,
            "system_ms": 0.6308000000000003000
          },
          "logos_release": {
            "mean_ms": 3.145398180000001000,
            "median_ms": 2.9537569800000005000,
            "stddev_ms": 0.6277153971826543000,
            "min_ms": 2.436130980000001000,
            "max_ms": 4.69975598000,
            "cv": 0.19956627468470592821,
            "runs": 10,
            "user_ms": 1.5894599999999998000,
            "system_ms": 0.8345000000000004000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "ackermann",
      "name": "Ackermann Function",
      "description": "Ackermann(3, m). Measures extreme recursion depth and stack frame overhead.",
      "reference_size": "8",
      "sizes": [
        "3",
        "4",
        "6",
        "8",
        "10",
        "11",
        "12"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To ackermann (m: Int) and (n: Int) -> Int:\n    If m equals 0:\n        Return n + 1.\n    If n equals 0:\n        Return ackermann(m - 1, 1).\n    Return ackermann(m - 1, ackermann(m, n - 1)).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow ackermann(3, n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn ackermann(mut m: i64, mut n: i64) -> i64 {\n    loop {\n        if (m == 0) {\n            return (n + 1);\n        }\n        if (n == 0) {\n            {\n                let __tce_0 = (m - 1);\n                let __tce_1 = 1;\n                m = __tce_0;\n                n = __tce_1;\n                continue;\n            }\n        }\n        {\n            let __tce_0 = (m - 1);\n            let __tce_1 = ackermann(m, (n - 1));\n            m = __tce_0;\n            n = __tce_1;\n            continue;\n        }\n    }\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&ackermann(3, n));\n}",
      "scaling": {
        "8": {
          "c": {
            "mean_ms": 10.421077579999998000,
            "median_ms": 10.346098679999999000,
            "stddev_ms": 0.4237252592945888000,
            "min_ms": 9.705202179999997000,
            "max_ms": 11.115119179999997000,
            "cv": 0.04066040733712577172,
            "runs": 10,
            "user_ms": 8.91456000,
            "system_ms": 0.7386199999999999000
          },
          "cpp": {
            "mean_ms": 10.603589979999998000,
            "median_ms": 10.55491068000,
            "stddev_ms": 0.2999986250771459000,
            "min_ms": 10.130119179999997000,
            "max_ms": 11.129202179999999000,
            "cv": 0.02829217516359925835,
            "runs": 10,
            "user_ms": 9.029059999999998000,
            "system_ms": 0.7992199999999998000
          },
          "rust": {
            "mean_ms": 14.989690080000001000,
            "median_ms": 11.224015179999998000,
            "stddev_ms": 8.251690728084363000,
            "min_ms": 10.648911179999998000,
            "max_ms": 32.90224418000,
            "cv": 0.55049108314081717488,
            "runs": 10,
            "user_ms": 9.540859999999998000,
            "system_ms": 0.8592199999999997000
          },
          "zig": {
            "mean_ms": 10.79001898000,
            "median_ms": 10.811514679999999000,
            "stddev_ms": 0.2901831072289815000,
            "min_ms": 10.35061918000,
            "max_ms": 11.246952179999999000,
            "cv": 0.02689366049928686038,
            "runs": 10,
            "user_ms": 9.251359999999998000,
            "system_ms": 0.8180199999999997000
          },
          "go": {
            "mean_ms": 12.70644408000,
            "median_ms": 12.59816068000,
            "stddev_ms": 0.4019795510178904000,
            "min_ms": 12.16457718000,
            "max_ms": 13.570828180000001000,
            "cv": 0.03163588085596725028,
            "runs": 10,
            "user_ms": 10.795359999999997000,
            "system_ms": 1.1760199999999998000
          },
          "java": {
            "mean_ms": 63.98215257999998000,
            "median_ms": 58.83557718000,
            "stddev_ms": 14.137703018952995000,
            "min_ms": 55.932911179999996000,
            "max_ms": 103.39674418000001000,
            "cv": 0.22096322878908991247,
            "runs": 10,
            "user_ms": 26.764760000000005000,
            "system_ms": 30.905819999999994000
          },
          "js": {
            "mean_ms": 65.96419428000001000,
            "median_ms": 64.12799418000001000,
            "stddev_ms": 5.819108425262041000,
            "min_ms": 63.11366118000,
            "max_ms": 82.42632718000001000,
            "cv": 0.08821616770700651871,
            "runs": 10,
            "user_ms": 52.756059999999994000,
            "system_ms": 5.579719999999999000
          },
          "python": {
            "mean_ms": 407.58024388000,
            "median_ms": 404.17493118000003000,
            "stddev_ms": 16.542919279934433000,
            "min_ms": 388.03236918000,
            "max_ms": 439.07991018000003000,
            "cv": 0.04058812841970085382,
            "runs": 10,
            "user_ms": 262.83606000000004000,
            "system_ms": 13.637020000000003000
          },
          "ruby": {
            "mean_ms": 204.32473558000003000,
            "median_ms": 168.94624418000,
            "stddev_ms": 74.5430424589297000,
            "min_ms": 163.94332718000,
            "max_ms": 373.22645218000,
            "cv": 0.36482632534592750287,
            "runs": 10,
            "user_ms": 147.07426000000004000,
            "system_ms": 20.31922000
          },
          "nim": {
            "mean_ms": 18.574648379999996000,
            "median_ms": 17.32903568000,
            "stddev_ms": 4.579863783243966000,
            "min_ms": 13.74099418000,
            "max_ms": 27.35566118000,
            "cv": 0.24656530177848604778,
            "runs": 10,
            "user_ms": 11.59556000,
            "system_ms": 1.7887199999999995000
          },
          "logos_release": {
            "mean_ms": 20.361902480000003000,
            "median_ms": 15.50722368000,
            "stddev_ms": 15.615886017428754000,
            "min_ms": 14.509619179999999000,
            "max_ms": 64.74686918000001000,
            "cv": 0.76691684545523624859,
            "runs": 10,
            "user_ms": 11.073459999999999000,
            "system_ms": 1.99192000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "nqueens",
      "name": "N-Queens",
      "description": "N-Queens backtracking. Measures recursive constraint solving.",
      "reference_size": "10",
      "sizes": [
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To solve (row: Int, cols: Int, diag1: Int, diag2: Int, n: Int) -> Int:\n    If row equals n:\n        Return 1.\n    Let all be (1 shifted left by n) - 1.\n    Let mutable available be all and not (cols or diag1 or diag2).\n    Let mutable count be 0.\n    While available is not 0:\n        Let bit be available and (0 - available).\n        Set available to available xor bit.\n        Set count to count + solve(row + 1, cols or bit, (diag1 or bit) shifted left by 1, (diag2 or bit) shifted right by 1, n).\n    Return count.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nShow solve(0, 0, 0, 0, n).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn solve(row: i64, cols: i64, diag1: i64, diag2: i64, n: i64) -> i64 {\n    if (row == n) {\n        return 1;\n    }\n    let all = ((1 << n) - 1);\n    let mut available = (all & !(((cols | diag1) | diag2)));\n    let mut count = 0;\n    while (available != 0) {\n        let bit = (available & (0 - available));\n        available = (available ^ bit);\n        count = (count + solve((row + 1), (cols | bit), ((diag1 | bit) << 1), ((diag2 | bit) >> 1), n));\n    }\n    return count;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    show(&solve(0, 0, 0, 0, n));\n}",
      "scaling": {
        "10": {
          "c": {
            "mean_ms": 1.1032875799999993000,
            "median_ms": 0.929012879999999000,
            "stddev_ms": 0.7061174614900286000,
            "min_ms": 0.5984708799999993000,
            "max_ms": 3.0388878799999988000,
            "cv": 0.64001215484545656537,
            "runs": 10,
            "user_ms": 0.71318000,
            "system_ms": 0.4835400000000007000
          },
          "cpp": {
            "mean_ms": 7.91177088000,
            "median_ms": 2.4431788799999994000,
            "stddev_ms": 12.90854560498289000,
            "min_ms": 0.7797208799999993000,
            "max_ms": 42.580429880000006000,
            "cv": 1.63156211179144889494,
            "runs": 10,
            "user_ms": 0.9293799999999999000,
            "system_ms": 1.2238400000000008000
          },
          "rust": {
            "mean_ms": 7.145345880000001000,
            "median_ms": 5.77142938000,
            "stddev_ms": 5.625952479101216000,
            "min_ms": 1.3924288799999993000,
            "max_ms": 20.70480388000,
            "cv": 0.78735901292733714559,
            "runs": 10,
            "user_ms": 1.19378000,
            "system_ms": 1.7073400000000005000
          },
          "zig": {
            "mean_ms": 0.6598404919999992000,
            "median_ms": 0.5683878799999991000,
            "stddev_ms": 0.6441593474089283000,
            "min_ms": 0,
            "max_ms": 2.2722208799999992000,
            "cv": 0.97623494650420617258,
            "runs": 10,
            "user_ms": 0.7117800000000002000,
            "system_ms": 0.33084600000000074000
          },
          "go": {
            "mean_ms": 2.9403709799999994000,
            "median_ms": 2.649200379999999000,
            "stddev_ms": 1.2987078071988367000,
            "min_ms": 1.3268458799999992000,
            "max_ms": 4.959054879999999000,
            "cv": 0.44168161637850097575,
            "runs": 10,
            "user_ms": 1.21588000,
            "system_ms": 1.0829400000000006000
          },
          "java": {
            "mean_ms": 79.66179578000,
            "median_ms": 75.08165788000,
            "stddev_ms": 14.388015315210213000,
            "min_ms": 66.56092988000,
            "max_ms": 105.84317888000,
            "cv": 0.18061374557692920991,
            "runs": 10,
            "user_ms": 23.620079999999998000,
            "system_ms": 34.921339999999995000
          },
          "js": {
            "mean_ms": 50.33648758000,
            "median_ms": 48.453095880000005000,
            "stddev_ms": 4.894647254508112000,
            "min_ms": 45.79934588000001000,
            "max_ms": 59.420762880000005000,
            "cv": 0.09723855377729778419,
            "runs": 10,
            "user_ms": 37.40217999999999000,
            "system_ms": 5.5432400000000005000
          },
          "python": {
            "mean_ms": 200.67095438000,
            "median_ms": 195.17951238000003000,
            "stddev_ms": 20.34195345255423000,
            "min_ms": 170.35701288000002000,
            "max_ms": 241.34542988000002000,
            "cv": 0.10136969505827806986,
            "runs": 10,
            "user_ms": 37.05398000,
            "system_ms": 13.819340000000003000
          },
          "ruby": {
            "mean_ms": 73.46947078000,
            "median_ms": 67.73555438000001000,
            "stddev_ms": 18.248954121571025000,
            "min_ms": 65.17288688000,
            "max_ms": 125.13842888000,
            "cv": 0.24838826151635748859,
            "runs": 10,
            "user_ms": 46.59538000,
            "system_ms": 16.296739999999997000
          },
          "nim": {
            "mean_ms": 0.7506498799999991000,
            "median_ms": 0.41607487999999887000,
            "stddev_ms": 1.0954614254436853000,
            "min_ms": 0.05067887999999927000,
            "max_ms": 3.799095879999999000,
            "cv": 1.45935069681711880566,
            "runs": 10,
            "user_ms": 0.7248800000000001000,
            "system_ms": 0.25564000000000077000
          },
          "logos_release": {
            "mean_ms": 1.3752542799999993000,
            "median_ms": 1.4685958799999991000,
            "stddev_ms": 0.3463602959348032000,
            "min_ms": 0.733803879999999000,
            "max_ms": 1.7508878799999995000,
            "cv": 0.25185182185712112548,
            "runs": 10,
            "user_ms": 1.59368000,
            "system_ms": 0.26344000000000074000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "bubble_sort",
      "name": "Bubble Sort",
      "description": "O(n^2) bubble sort. Measures nested loops, indexed array mutation, and swap patterns.",
      "reference_size": "1000",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000",
        "10000",
        "30000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 4294967296.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n - 1:\n    Let mutable j be 1.\n    While j is at most n - 1 - i:\n        Let a be item j of arr.\n        Let b be item (j + 1) of arr.\n        If a is greater than b:\n            Set item j of arr to b.\n            Set item (j + 1) of arr to a.\n        Set j to j + 1.\n    Set i to i + 1.\nShow item 1 of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 4294967296);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = 0;\n    for i in 0..(n - 1) {\n        unsafe { std::hint::assert_unchecked((((n - 1) - i) as usize) <= arr.len()); }\n        for j in 1..(((n - 1) - i) + 1) {\n            if arr[(j - 1) as usize] > arr[(j) as usize] {\n                let __swap_tmp = arr[(j - 1) as usize];\n                arr[(j - 1) as usize] = arr[(j) as usize];\n                arr[(j) as usize] = __swap_tmp;\n            }\n        }\n    }\n    show(&arr[0]);\n}",
      "scaling": {
        "1000": {
          "c": {
            "mean_ms": 2.02641328000,
            "median_ms": 1.9237801799999996000,
            "stddev_ms": 0.28902532438186874000,
            "min_ms": 1.7059466800000002000,
            "max_ms": 2.5782386799999995000,
            "cv": 0.14262901217360199100,
            "runs": 10,
            "user_ms": 0.8757599999999997000,
            "system_ms": 0.5454999999999998000
          },
          "cpp": {
            "mean_ms": 2.6194466799999996000,
            "median_ms": 2.47107168000,
            "stddev_ms": 0.783969642169049000,
            "min_ms": 1.8611966800000002000,
            "max_ms": 4.54132168000,
            "cv": 0.29928826120218989138,
            "runs": 10,
            "user_ms": 0.9921599999999995000,
            "system_ms": 0.7878999999999997000
          },
          "rust": {
            "mean_ms": 2.9809633799999995000,
            "median_ms": 2.6353631799999997000,
            "stddev_ms": 1.1511219837534404000,
            "min_ms": 2.06773868000,
            "max_ms": 6.1142806800000005000,
            "cv": 0.38615770709448990046,
            "runs": 10,
            "user_ms": 1.4394599999999996000,
            "system_ms": 0.7645999999999999000
          },
          "zig": {
            "mean_ms": 2.2002340799999994000,
            "median_ms": 2.2148006799999997000,
            "stddev_ms": 0.2847796903086079000,
            "min_ms": 1.8677386800000002000,
            "max_ms": 2.8007376799999996000,
            "cv": 0.12943154226054346801,
            "runs": 10,
            "user_ms": 0.9373599999999996000,
            "system_ms": 0.7120999999999999000
          },
          "go": {
            "mean_ms": 8.80965078000,
            "median_ms": 3.97907118000,
            "stddev_ms": 13.10277727706888000,
            "min_ms": 2.76457168000,
            "max_ms": 45.36915468000,
            "cv": 1.48732084895070948544,
            "runs": 10,
            "user_ms": 1.6738599999999997000,
            "system_ms": 1.3947999999999999000
          },
          "java": {
            "mean_ms": 56.44784258000,
            "median_ms": 56.26536368000,
            "stddev_ms": 2.091364919343848000,
            "min_ms": 53.91611368000,
            "max_ms": 61.049863680000004000,
            "cv": 0.03704951019837272229,
            "runs": 10,
            "user_ms": 24.83366000,
            "system_ms": 28.796000
          },
          "js": {
            "mean_ms": 57.71732977999999000,
            "median_ms": 49.72607118000,
            "stddev_ms": 14.815294693865368000,
            "min_ms": 47.02719668000,
            "max_ms": 90.61548868000,
            "cv": 0.25668711200494782430,
            "runs": 10,
            "user_ms": 39.83395999999999000,
            "system_ms": 6.266000000000001000
          },
          "python": {
            "mean_ms": 249.63432578000005000,
            "median_ms": 246.00165468000001000,
            "stddev_ms": 29.60979052419922000,
            "min_ms": 217.47632168000003000,
            "max_ms": 301.64094668000,
            "cv": 0.11861265645932842781,
            "runs": 10,
            "user_ms": 90.50436000,
            "system_ms": 14.670399999999995000
          },
          "ruby": {
            "mean_ms": 115.34653018000,
            "median_ms": 107.86211368000,
            "stddev_ms": 17.44693021821833000,
            "min_ms": 102.25815568000,
            "max_ms": 158.81794668000002000,
            "cv": 0.15125665410994272875,
            "runs": 10,
            "user_ms": 85.20885999999998000,
            "system_ms": 17.8055000
          },
          "nim": {
            "mean_ms": 3.36824658000,
            "median_ms": 3.30636318000,
            "stddev_ms": 0.5974542733927101000,
            "min_ms": 2.51340468000,
            "max_ms": 4.35686368000,
            "cv": 0.17737842500613779291,
            "runs": 10,
            "user_ms": 1.3161599999999998000,
            "system_ms": 1.0618999999999997000
          },
          "logos_release": {
            "mean_ms": 3.96752598000,
            "median_ms": 3.96998818000,
            "stddev_ms": 0.3340675946085862000,
            "min_ms": 3.32253068000,
            "max_ms": 4.468655680000001000,
            "cv": 0.08420048067551310653,
            "runs": 10,
            "user_ms": 2.2994599999999997000,
            "system_ms": 1.0618999999999997000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "mergesort",
      "name": "Merge Sort",
      "description": "Top-down merge sort. Measures allocation-heavy divide-and-conquer.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To mergeSort (arr: Seq of Int) -> Seq of Int:\n    Let n be length of arr.\n    If n is less than 2:\n        Return arr.\n    Let mid be n / 2.\n    Let mutable left be a new Seq of Int.\n    Let mutable right be a new Seq of Int.\n    Let mutable i be 1.\n    While i is at most mid:\n        Push item i of arr to left.\n        Set i to i + 1.\n    While i is at most n:\n        Push item i of arr to right.\n        Set i to i + 1.\n    Set left to mergeSort(left).\n    Set right to mergeSort(right).\n    Let mutable result be a new Seq of Int.\n    Let mutable li be 1.\n    Let mutable ri be 1.\n    While li is at most length of left:\n        If ri is greater than length of right:\n            Push item li of left to result.\n            Set li to li + 1.\n        Otherwise:\n            If item li of left is at most item ri of right:\n                Push item li of left to result.\n                Set li to li + 1.\n            Otherwise:\n                Push item ri of right to result.\n                Set ri to ri + 1.\n    While ri is at most length of right:\n        Push item ri of right to result.\n        Set ri to ri + 1.\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet arr to mergeSort(arr).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn mergeSort(arr: &[i64]) -> Vec<i64> {\n    let n = (arr.len() as i64);\n    if (n < 2) {\n        return arr.to_vec();\n    }\n    let mid = (n / 2);\n    let mut left: Vec<i64> = arr[..mid as usize].to_vec();\n    let mut right = Seq::<i64>::default();\n    let mut i = mid + 1;\n    if i <= n {\n        right.extend_from_slice(&arr[(i - 1) as usize..n as usize]);\n    }\n    left = mergeSort(&left);\n    right = mergeSort(&right);\n    let mut result: Vec<i64> = Vec::with_capacity((right.len() + left.len()) as usize);\n    let mut li = 1;\n    let mut ri = 1;\n    let left_len = (left.len() as i64);\n    let right_len = (right.len() as i64);\n    unsafe { std::hint::assert_unchecked((left_len as usize) <= left.len()); }\n    while (li <= left_len) {\n        if (ri > right_len) {\n            result.extend_from_slice(&left[(li - 1) as usize..]);\n            break;\n        } else {\n            if (left[(li - 1) as usize] <= right[(ri - 1) as usize]) {\n                result.push(left[(li - 1) as usize]);\n                li = (li + 1);\n            } else {\n                result.push(right[(ri - 1) as usize]);\n                ri = (ri + 1);\n            }\n        }\n    }\n    if ri <= (right.len() as i64) {\n        result.extend_from_slice(&right[(ri - 1) as usize..(right.len() as i64) as usize]);\n    }\n    return result;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    arr = mergeSort(&arr);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.8659134000000015000,
            "median_ms": 1.7416888000000015000,
            "stddev_ms": 0.6652393956757139000,
            "min_ms": 1.0216263000000017000,
            "max_ms": 3.3818343000000016000,
            "cv": 0.35652211709059668322,
            "runs": 10,
            "user_ms": 1.08172000,
            "system_ms": 0.46177999999999985000
          },
          "cpp": {
            "mean_ms": 1.3294676000000013000,
            "median_ms": 1.1934803000000016000,
            "stddev_ms": 0.4011391076267268000,
            "min_ms": 0.9607503000000012000,
            "max_ms": 2.2343343000000015000,
            "cv": 0.30172913399824592021,
            "runs": 10,
            "user_ms": 1.01522000,
            "system_ms": 0.11965199999999996000
          },
          "rust": {
            "mean_ms": 1.8311218000000011000,
            "median_ms": 1.8063343000000016000,
            "stddev_ms": 0.4876928958267009000,
            "min_ms": 1.0777093000000019000,
            "max_ms": 2.898959300000002000,
            "cv": 0.26633558500952837054,
            "runs": 10,
            "user_ms": 1.34262000,
            "system_ms": 0.2774519999999999000
          },
          "zig": {
            "mean_ms": 25.531434300000006000,
            "median_ms": 25.2697718000,
            "stddev_ms": 1.4299370482712401000,
            "min_ms": 23.855084300000003000,
            "max_ms": 28.113667300000006000,
            "cv": 0.05600692195625060374,
            "runs": 10,
            "user_ms": 4.60612000,
            "system_ms": 20.282179999999997000
          },
          "go": {
            "mean_ms": 3.0414675000000014000,
            "median_ms": 2.7740008000000016000,
            "stddev_ms": 0.8779558755519426000,
            "min_ms": 2.0832513000000018000,
            "max_ms": 4.868542300000002000,
            "cv": 0.28866192900366096164,
            "runs": 10,
            "user_ms": 1.5798199999999998000,
            "system_ms": 0.93268000
          },
          "java": {
            "mean_ms": 77.6113343000,
            "median_ms": 76.1872713000,
            "stddev_ms": 7.85549678289366000,
            "min_ms": 70.6762513000,
            "max_ms": 98.9753763000,
            "cv": 0.10121584500182546146,
            "runs": 10,
            "user_ms": 47.75972000,
            "system_ms": 29.156480000000002000
          },
          "js": {
            "mean_ms": 51.4065053000,
            "median_ms": 49.7069388000,
            "stddev_ms": 6.202395202133606000,
            "min_ms": 47.59354230000001000,
            "max_ms": 68.6619183000,
            "cv": 0.12065389712717168502,
            "runs": 10,
            "user_ms": 39.71212000,
            "system_ms": 5.6533799999999995000
          },
          "python": {
            "mean_ms": 192.25340910000002000,
            "median_ms": 180.5518758000,
            "stddev_ms": 30.932064624370165000,
            "min_ms": 168.89504230000002000,
            "max_ms": 269.6014593000,
            "cv": 0.16089215150552127079,
            "runs": 10,
            "user_ms": 34.429520000000005000,
            "system_ms": 13.710179999999999000
          },
          "ruby": {
            "mean_ms": 79.3878674000,
            "median_ms": 71.6352713000,
            "stddev_ms": 23.596179242816075000,
            "min_ms": 66.7621253000,
            "max_ms": 145.43750030000002000,
            "cv": 0.29722651603582533066,
            "runs": 10,
            "user_ms": 48.08882000,
            "system_ms": 18.28248000
          },
          "nim": {
            "mean_ms": 1.7722927000000017000,
            "median_ms": 1.7910013000000018000,
            "stddev_ms": 0.4199417815838553000,
            "min_ms": 1.0397093000000012000,
            "max_ms": 2.313709300000002000,
            "cv": 0.23694832212752154155,
            "runs": 10,
            "user_ms": 1.0320200000000002000,
            "system_ms": 0.35405199999999994000
          },
          "logos_release": {
            "mean_ms": 3.742930200000002000,
            "median_ms": 3.670209300000002000,
            "stddev_ms": 0.278465765309949000,
            "min_ms": 3.4667093000000015000,
            "max_ms": 4.339750300000002000,
            "cv": 0.07439779809678226198,
            "runs": 10,
            "user_ms": 2.8082199999999993000,
            "system_ms": 0.67008000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "quicksort",
      "name": "Quicksort",
      "description": "Lomuto-partition quicksort. Measures in-place swap-heavy recursion.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To qs (arr: Seq of Int, lo: Int, hi: Int) -> Seq of Int:\n    If lo is at least hi:\n        Return arr.\n    Let pivot be item hi of arr.\n    Let mutable result be arr.\n    Let mutable i be lo.\n    Let mutable j be lo.\n    While j is less than hi:\n        If item j of result is at most pivot:\n            Let tmp be item i of result.\n            Set item i of result to item j of result.\n            Set item j of result to tmp.\n            Set i to i + 1.\n        Set j to j + 1.\n    Let tmp be item i of result.\n    Set item i of result to item hi of result.\n    Set item hi of result to tmp.\n    Set result to qs(result, lo, i - 1).\n    Set result to qs(result, i + 1, hi).\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nSet arr to qs(arr, 1, n).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn qs(arr: &mut [i64], lo: i64, hi: i64) {\n    if (lo >= hi) {\n        return;\n    }\n    let pivot = arr[(hi - 1) as usize];\n    let mut result = arr;\n    let mut i = lo;\n    unsafe { std::hint::assert_unchecked((hi as usize) <= result.len()); }\n    for j in lo..hi {\n        if (result[(j - 1) as usize] <= pivot) {\n            let tmp = result[(i - 1) as usize];\n            result[(i - 1) as usize] = result[(j - 1) as usize];\n            result[(j - 1) as usize] = tmp;\n            i = (i + 1);\n        }\n    }\n    let __swap_tmp = result[(i - 1) as usize];\n    result[(i - 1) as usize] = result[(hi - 1) as usize];\n    result[(hi - 1) as usize] = __swap_tmp;\n    qs(result, lo, (i - 1));\n    qs(result, (i + 1), hi);\n    return;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    qs(&mut arr, 1, n);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 3.1095474800000014000,
            "median_ms": 2.6748682800000014000,
            "stddev_ms": 1.1066625089603676000,
            "min_ms": 1.952888780000001000,
            "max_ms": 5.384639780000001000,
            "cv": 0.35589181901167404002,
            "runs": 10,
            "user_ms": 0.9183199999999997000,
            "system_ms": 1.19362000
          },
          "cpp": {
            "mean_ms": 3.6612264800000016000,
            "median_ms": 3.3546592800000018000,
            "stddev_ms": 1.2601430847765794000,
            "min_ms": 2.5816807800000015000,
            "max_ms": 6.778930780000002000,
            "cv": 0.34418605122089547689,
            "runs": 10,
            "user_ms": 0.9561199999999998000,
            "system_ms": 1.3062199999999999000
          },
          "rust": {
            "mean_ms": 3.960397380000001000,
            "median_ms": 3.7881182800000015000,
            "stddev_ms": 1.0228058129198873000,
            "min_ms": 2.9132227800000013000,
            "max_ms": 6.185805780000002000,
            "cv": 0.25825838035472264698,
            "runs": 10,
            "user_ms": 1.2042199999999996000,
            "system_ms": 1.3292199999999999000
          },
          "zig": {
            "mean_ms": 3.5264933800000014000,
            "median_ms": 3.824076280000001000,
            "stddev_ms": 0.7835258982987949000,
            "min_ms": 2.2206807800000013000,
            "max_ms": 4.542555780000001000,
            "cv": 0.22218272200437097912,
            "runs": 10,
            "user_ms": 1.0089199999999995000,
            "system_ms": 1.2101199999999999000
          },
          "go": {
            "mean_ms": 5.348009880000002000,
            "median_ms": 4.8466602800000015000,
            "stddev_ms": 1.3225157101812903000,
            "min_ms": 3.634597780000002000,
            "max_ms": 7.629471780000002000,
            "cv": 0.24729118678840021242,
            "runs": 10,
            "user_ms": 1.5423199999999998000,
            "system_ms": 1.9498199999999997000
          },
          "java": {
            "mean_ms": 83.07624748000002000,
            "median_ms": 79.24995178000002000,
            "stddev_ms": 15.293269019910665000,
            "min_ms": 64.58551378000,
            "max_ms": 113.79601378000001000,
            "cv": 0.18408714264076990443,
            "runs": 10,
            "user_ms": 44.92432000,
            "system_ms": 34.191719999999995000
          },
          "js": {
            "mean_ms": 57.227422380000004000,
            "median_ms": 54.60849328000,
            "stddev_ms": 7.181751506238361000,
            "min_ms": 50.79759678000,
            "max_ms": 75.09105578000001000,
            "cv": 0.12549493245651160320,
            "runs": 10,
            "user_ms": 45.188519999999996000,
            "system_ms": 6.969319999999999000
          },
          "python": {
            "mean_ms": 181.66689768000002000,
            "median_ms": 175.86143128000,
            "stddev_ms": 17.773397228426368000,
            "min_ms": 157.12359778000,
            "max_ms": 210.83734678000002000,
            "cv": 0.09783508969109823598,
            "runs": 10,
            "user_ms": 29.49542000,
            "system_ms": 13.108019999999998000
          },
          "ruby": {
            "mean_ms": 74.42803078000002000,
            "median_ms": 73.55568078000001000,
            "stddev_ms": 5.228974334433751000,
            "min_ms": 67.51147178000001000,
            "max_ms": 82.85705578000001000,
            "cv": 0.07025544381108170432,
            "runs": 10,
            "user_ms": 46.480020000000004000,
            "system_ms": 19.10572000
          },
          "nim": {
            "mean_ms": 3.569980680000001000,
            "median_ms": 3.2613887800000013000,
            "stddev_ms": 0.8698596779338671000,
            "min_ms": 2.6398057800000015000,
            "max_ms": 5.222180780000001000,
            "cv": 0.24365949171855654309,
            "runs": 10,
            "user_ms": 1.0106199999999996000,
            "system_ms": 1.0960199999999999000
          },
          "logos_release": {
            "mean_ms": 5.623651680000002000,
            "median_ms": 5.458701780000002000,
            "stddev_ms": 0.657478799685663000,
            "min_ms": 4.946930780000002000,
            "max_ms": 7.158847780000002000,
            "cv": 0.11691314418066212204,
            "runs": 10,
            "user_ms": 2.184319999999999000,
            "system_ms": 1.7624199999999996000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "counting_sort",
      "name": "Counting Sort",
      "description": "Non-comparison O(n+k) sort. Measures pure array indexing throughput.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "40000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 1000 to arr.\n    Set i to i + 1.\nLet mutable counts be a new Seq of Int.\nSet i to 0.\nWhile i is less than 1000:\n    Push 0 to counts.\n    Set i to i + 1.\nSet i to 1.\nWhile i is at most n:\n    Let v be item i of arr.\n    Set item (v + 1) of counts to (item (v + 1) of counts) + 1.\n    Set i to i + 1.\nLet mutable sorted be a new Seq of Int.\nLet mutable v be 0.\nWhile v is less than 1000:\n    Let mutable c be 0.\n    While c is less than item (v + 1) of counts:\n        Push v to sorted.\n        Set c to c + 1.\n    Set v to v + 1.\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of sorted) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of sorted + \" \" + item n of sorted + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 1000));\n    }\n    let mut i = (0_i64).max(n);\n    let mut counts: Vec<i64> = vec![0; 1000 as usize];\n    i = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        let mut v = arr[i as usize];\n        counts[(v) as usize] = (counts[v as usize] + 1);\n    }\n    i = (1_i64).max(n + 1);\n    let mut sorted = Seq::<i64>::default();\n    for v in 0..1000 {\n        let mut c = 0;\n        while (c < counts[v as usize]) {\n            sorted.push(v);\n            c = (c + 1);\n        }\n    }\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= sorted.len()); }\n    for i in 0..n {\n        checksum = ((checksum + sorted[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", sorted[0], \" \", sorted[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 6.1009034000000005000,
            "median_ms": 1.4674531000000005000,
            "stddev_ms": 14.934193407979692000,
            "min_ms": 0.6787861000000003000,
            "max_ms": 48.587954100000004000,
            "cv": 2.44786590261037255172,
            "runs": 10,
            "user_ms": 0.79104000,
            "system_ms": 0.5144800000000001000
          },
          "cpp": {
            "mean_ms": 8.0796036000,
            "median_ms": 2.0814326000000005000,
            "stddev_ms": 17.06321736536593000,
            "min_ms": 1.5132451000000003000,
            "max_ms": 56.3665371000,
            "cv": 2.11188793536429559489,
            "runs": 10,
            "user_ms": 0.9219399999999999000,
            "system_ms": 0.8040800000000001000
          },
          "rust": {
            "mean_ms": 3.2883451000000007000,
            "median_ms": 3.1123701000,
            "stddev_ms": 2.0153496971630287000,
            "min_ms": 0.8480781000,
            "max_ms": 7.267079100000001000,
            "cv": 0.61287657951807681954,
            "runs": 10,
            "user_ms": 1.23684000,
            "system_ms": 0.85838000
          },
          "zig": {
            "mean_ms": 1.5795616000000006000,
            "median_ms": 1.4638906000000004000,
            "stddev_ms": 0.9669263237058907000,
            "min_ms": 0.7607031000000002000,
            "max_ms": 4.1635781000,
            "cv": 0.61214853773723692239,
            "runs": 10,
            "user_ms": 0.8341399999999997000,
            "system_ms": 0.38528000000000005000
          },
          "go": {
            "mean_ms": 2.6450868000000003000,
            "median_ms": 2.4028071000000008000,
            "stddev_ms": 0.832144936262381000,
            "min_ms": 1.9005371000000004000,
            "max_ms": 4.8318281000,
            "cv": 0.31460023779271852463,
            "runs": 10,
            "user_ms": 1.3826399999999999000,
            "system_ms": 0.94398000
          },
          "java": {
            "mean_ms": 76.5735159000,
            "median_ms": 75.0786616000,
            "stddev_ms": 9.194534666751497000,
            "min_ms": 64.7896621000,
            "max_ms": 94.7297871000,
            "cv": 0.12007460489027247343,
            "runs": 10,
            "user_ms": 43.02993999999999000,
            "system_ms": 32.922879999999995000
          },
          "js": {
            "mean_ms": 66.3839367000,
            "median_ms": 61.3671406000,
            "stddev_ms": 17.313222048090455000,
            "min_ms": 54.3346201000,
            "max_ms": 111.83682810000001000,
            "cv": 0.26080438896433291820,
            "runs": 10,
            "user_ms": 46.836539999999996000,
            "system_ms": 8.160480000000001000
          },
          "python": {
            "mean_ms": 216.84618260000002000,
            "median_ms": 218.29620310000003000,
            "stddev_ms": 18.662320646924743000,
            "min_ms": 184.33028710000002000,
            "max_ms": 248.1254541000,
            "cv": 0.08606248181619933796,
            "runs": 10,
            "user_ms": 43.057439999999995000,
            "system_ms": 16.161079999999998000
          },
          "ruby": {
            "mean_ms": 77.26002000000001000,
            "median_ms": 75.6094326000,
            "stddev_ms": 5.577403597879982000,
            "min_ms": 72.6585371000,
            "max_ms": 91.66728610000001000,
            "cv": 0.07219003564689707921,
            "runs": 10,
            "user_ms": 50.58953999999999000,
            "system_ms": 18.232780000000004000
          },
          "nim": {
            "mean_ms": 2.537541000000001000,
            "median_ms": 2.6618491000000005000,
            "stddev_ms": 0.7490613904877445000,
            "min_ms": 1.3082451000,
            "max_ms": 3.9796201000,
            "cv": 0.29519183748666295630,
            "runs": 10,
            "user_ms": 1.1850399999999998000,
            "system_ms": 0.72398000
          },
          "logos_release": {
            "mean_ms": 3.826378400000001000,
            "median_ms": 3.649120100000001000,
            "stddev_ms": 0.4099769242086277000,
            "min_ms": 3.4427871000000006000,
            "max_ms": 4.694286100000001000,
            "cv": 0.10714489821723528254,
            "runs": 10,
            "user_ms": 2.18674000,
            "system_ms": 1.1787800000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "heap_sort",
      "name": "Heap Sort",
      "description": "Heap sort with sift-down. Measures logarithmic array jumps.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "2500000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To siftDown (arr: Seq of Int, start: Int, end: Int) -> Seq of Int:\n    Let mutable result be arr.\n    Let mutable root be start.\n    While 2 * root + 1 is at most end:\n        Let child be 2 * root + 1.\n        Let mutable swapIdx be root.\n        If item (swapIdx + 1) of result is less than item (child + 1) of result:\n            Set swapIdx to child.\n        If child + 1 is at most end:\n            If item (swapIdx + 1) of result is less than item (child + 2) of result:\n                Set swapIdx to child + 1.\n        If swapIdx equals root:\n            Return result.\n        Let tmp be item (root + 1) of result.\n        Set item (root + 1) of result to item (swapIdx + 1) of result.\n        Set item (swapIdx + 1) of result to tmp.\n        Set root to swapIdx.\n    Return result.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nLet mutable start be (n - 2) / 2.\nWhile start is at least 0:\n    Set arr to siftDown(arr, start, n - 1).\n    Set start to start - 1.\nLet mutable end be n - 1.\nWhile end is greater than 0:\n    Let tmp be item 1 of arr.\n    Set item 1 of arr to item (end + 1) of arr.\n    Set item (end + 1) of arr to tmp.\n    Set end to end - 1.\n    Set arr to siftDown(arr, 0, end).\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set checksum to (checksum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn siftDown(arr: &mut [i64], start: i64, end: i64) {\n    let mut result = arr;\n    let mut root = start;\n    while (((2 * root) + 1) <= end) {\n        let child = ((2 * root) + 1);\n        let mut swapIdx = root;\n        if (result[swapIdx as usize] < result[child as usize]) {\n            swapIdx = child;\n        }\n        if ((child + 1) <= end) {\n            if (result[swapIdx as usize] < result[(child + 1) as usize]) {\n                swapIdx = (child + 1);\n            }\n        }\n        if (swapIdx == root) {\n            return;\n        }\n        let __swap_tmp = result[(root) as usize];\n        result[(root) as usize] = result[(swapIdx) as usize];\n        result[(swapIdx) as usize] = __swap_tmp;\n        root = swapIdx;\n    }\n    return;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut i = (0_i64).max(n);\n    let mut start = ((n - 2) / 2);\n    while (start >= 0) {\n        siftDown(&mut arr, start, (n - 1));\n        start = (start - 1);\n    }\n    let mut end = (n - 1);\n    while (end > 0) {\n        let __swap_tmp = arr[0];\n        arr[0] = arr[(end) as usize];\n        arr[(end) as usize] = __swap_tmp;\n        end = (end - 1);\n        siftDown(&mut arr, 0, end);\n    }\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        checksum = ((checksum + arr[i as usize]) % 1000000007);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", checksum));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 0.2133149720000005000,
            "median_ms": 0,
            "stddev_ms": 0.2872979775922098000,
            "min_ms": 0,
            "max_ms": 0.7055166800000014000,
            "cv": 1.34682518952401112561,
            "runs": 10,
            "user_ms": 0.7173599999999999000,
            "system_ms": 0.60906000
          },
          "cpp": {
            "mean_ms": 0.33043004400000085000,
            "median_ms": 0.2700796800000011000,
            "stddev_ms": 0.3374712917079814000,
            "min_ms": 0,
            "max_ms": 1.0275576800000009000,
            "cv": 1.02130934470347536523,
            "runs": 10,
            "user_ms": 0.7574599999999997000,
            "system_ms": 0.65956000
          },
          "rust": {
            "mean_ms": 0.708106612000001000,
            "median_ms": 0.8278081800000012000,
            "stddev_ms": 0.43761526540895846000,
            "min_ms": 0,
            "max_ms": 1.242807680000001000,
            "cv": 0.61800759658625789246,
            "runs": 10,
            "user_ms": 1.07746000,
            "system_ms": 0.7385600000000002000
          },
          "zig": {
            "mean_ms": 0.20078014400000095000,
            "median_ms": 0.10360018000000115000,
            "stddev_ms": 0.23932860597226588000,
            "min_ms": 0,
            "max_ms": 0.7103916800000011000,
            "cv": 1.19199339737631001801,
            "runs": 10,
            "user_ms": 0.7727599999999998000,
            "system_ms": 0.5680600000000001000
          },
          "go": {
            "mean_ms": 1.1944958800000013000,
            "median_ms": 1.0097246800000008000,
            "stddev_ms": 0.47201725586978747000,
            "min_ms": 0.6038506800000011000,
            "max_ms": 1.8803086800000014000,
            "cv": 0.39516022095428822767,
            "runs": 10,
            "user_ms": 1.3130599999999998000,
            "system_ms": 1.1261600000000002000
          },
          "java": {
            "mean_ms": 77.62014168000,
            "median_ms": 74.61376668000001000,
            "stddev_ms": 13.113279701477515000,
            "min_ms": 63.97276668000001000,
            "max_ms": 95.22639168000001000,
            "cv": 0.16894171303550131577,
            "runs": 10,
            "user_ms": 42.74815999999999000,
            "system_ms": 34.93676000
          },
          "js": {
            "mean_ms": 72.04377518000002000,
            "median_ms": 71.24591268000001000,
            "stddev_ms": 16.155919845035255000,
            "min_ms": 51.55709968000,
            "max_ms": 96.07151668000001000,
            "cv": 0.22425143330801297571,
            "runs": 10,
            "user_ms": 47.756360000000005000,
            "system_ms": 8.99456000
          },
          "python": {
            "mean_ms": 244.74775838000,
            "median_ms": 234.35803718000003000,
            "stddev_ms": 55.92471733812483000,
            "min_ms": 184.03460068000,
            "max_ms": 336.98293368000004000,
            "cv": 0.22849940570771257414,
            "runs": 10,
            "user_ms": 41.076959999999996000,
            "system_ms": 16.905359999999998000
          },
          "ruby": {
            "mean_ms": 81.29095018000002000,
            "median_ms": 78.27805868000001000,
            "stddev_ms": 10.645477145173901000,
            "min_ms": 71.08664168000,
            "max_ms": 104.28618368000002000,
            "cv": 0.13095525543251681033,
            "runs": 10,
            "user_ms": 53.77666000000001000,
            "system_ms": 19.906559999999997000
          },
          "nim": {
            "mean_ms": 1.1072850080000008000,
            "median_ms": 0.2946006800000015000,
            "stddev_ms": 2.441826914410277000,
            "min_ms": 0,
            "max_ms": 7.96055768000,
            "cv": 2.20523794395153161489,
            "runs": 10,
            "user_ms": 0.9424599999999997000,
            "system_ms": 0.7791600000000002000
          },
          "logos_release": {
            "mean_ms": 3.7034875800000013000,
            "median_ms": 2.9067671800000012000,
            "stddev_ms": 1.7619138930065322000,
            "min_ms": 1.4890586800000013000,
            "max_ms": 6.501891680000001000,
            "cv": 0.47574451242159466929,
            "runs": 10,
            "user_ms": 2.1877599999999995000,
            "system_ms": 1.61736000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "nbody",
      "name": "N-Body Simulation",
      "description": "5-body gravitational simulation. Measures FP struct arrays and sqrt.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "4000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet pi be 3.141592653589793.\nLet solarMass be 4.0 * pi * pi.\nLet daysPerYear be 365.24.\n\nLet mutable bx be a new Seq of Float.\nLet mutable posY be a new Seq of Float.\nLet mutable bz be a new Seq of Float.\nLet mutable bvx be a new Seq of Float.\nLet mutable bvy be a new Seq of Float.\nLet mutable bvz be a new Seq of Float.\nLet mutable bm be a new Seq of Float.\n\nPush 0.0 to bx. Push 0.0 to posY. Push 0.0 to bz.\nPush 0.0 to bvx. Push 0.0 to bvy. Push 0.0 to bvz.\nPush solarMass to bm.\n\nPush 4.841431442464721 to bx. Push 0.0 - 1.1603200440274284 to posY. Push 0.0 - 0.10362204447112311 to bz.\nPush 0.001660076642744037 * daysPerYear to bvx. Push 0.007699011184197404 * daysPerYear to bvy. Push 0.0 - 0.0000690460016972063 * daysPerYear to bvz.\nPush 0.0009547919384243266 * solarMass to bm.\n\nPush 8.34336671824458 to bx. Push 4.124798564124305 to posY. Push 0.0 - 0.4035234171143214 to bz.\nPush 0.0 - 0.002767425107268624 * daysPerYear to bvx. Push 0.004998528012349172 * daysPerYear to bvy. Push 0.00002304172975737639 * daysPerYear to bvz.\nPush 0.0002858859806661308 * solarMass to bm.\n\nPush 12.894369562139131 to bx. Push 0.0 - 15.111151401698631 to posY. Push 0.0 - 0.22330757889265573 to bz.\nPush 0.002964601375647616 * daysPerYear to bvx. Push 0.0023784717395948095 * daysPerYear to bvy. Push 0.0 - 0.000029658956854023756 * daysPerYear to bvz.\nPush 0.00004366244043351563 * solarMass to bm.\n\nPush 15.379697114850917 to bx. Push 0.0 - 25.919314609987964 to posY. Push 0.17925877295037118 to bz.\nPush 0.0026806777249038932 * daysPerYear to bvx. Push 0.001628241700382423 * daysPerYear to bvy. Push 0.0 - 0.00009515922545197159 * daysPerYear to bvz.\nPush 0.00005151389020466114 * solarMass to bm.\n\nLet mutable px be 0.0.\nLet mutable py be 0.0.\nLet mutable pz be 0.0.\nLet mutable i be 1.\nWhile i is at most 5:\n    Set px to px + item i of bvx * item i of bm.\n    Set py to py + item i of bvy * item i of bm.\n    Set pz to pz + item i of bvz * item i of bm.\n    Set i to i + 1.\nSet item 1 of bvx to 0.0 - px / solarMass.\nSet item 1 of bvy to 0.0 - py / solarMass.\nSet item 1 of bvz to 0.0 - pz / solarMass.\n\nLet mutable e be 0.0.\nSet i to 1.\nWhile i is at most 5:\n    Set e to e + 0.5 * item i of bm * (item i of bvx * item i of bvx + item i of bvy * item i of bvy + item i of bvz * item i of bvz).\n    Let mutable j be i + 1.\n    While j is at most 5:\n        Let dx be item i of bx - item j of bx.\n        Let dy be item i of posY - item j of posY.\n        Let dz be item i of bz - item j of bz.\n        Set e to e - item i of bm * item j of bm / sqrt(dx * dx + dy * dy + dz * dz).\n        Set j to j + 1.\n    Set i to i + 1.\nShow \"{e:.9}\".\n\nLet dt be 0.01.\nLet mutable step be 0.\nWhile step is less than n:\n    Set i to 1.\n    While i is at most 5:\n        Let mutable j be i + 1.\n        While j is at most 5:\n            Let dx be item i of bx - item j of bx.\n            Let dy be item i of posY - item j of posY.\n            Let dz be item i of bz - item j of bz.\n            Let dist be sqrt(dx * dx + dy * dy + dz * dz).\n            Let mag be dt / (dist * dist * dist).\n            Set item i of bvx to item i of bvx - dx * item j of bm * mag.\n            Set item i of bvy to item i of bvy - dy * item j of bm * mag.\n            Set item i of bvz to item i of bvz - dz * item j of bm * mag.\n            Set item j of bvx to item j of bvx + dx * item i of bm * mag.\n            Set item j of bvy to item j of bvy + dy * item i of bm * mag.\n            Set item j of bvz to item j of bvz + dz * item i of bm * mag.\n            Set j to j + 1.\n        Set i to i + 1.\n    Set i to 1.\n    While i is at most 5:\n        Set item i of bx to item i of bx + dt * item i of bvx.\n        Set item i of posY to item i of posY + dt * item i of bvy.\n        Set item i of bz to item i of bz + dt * item i of bvz.\n        Set i to i + 1.\n    Set step to step + 1.\n\nSet e to 0.0.\nSet i to 1.\nWhile i is at most 5:\n    Set e to e + 0.5 * item i of bm * (item i of bvx * item i of bvx + item i of bvy * item i of bvy + item i of bvz * item i of bvz).\n    Let mutable j be i + 1.\n    While j is at most 5:\n        Let dx be item i of bx - item j of bx.\n        Let dy be item i of posY - item j of posY.\n        Let dz be item i of bz - item j of bz.\n        Set e to e - item i of bm * item j of bm / sqrt(dx * dx + dy * dy + dz * dz).\n        Set j to j + 1.\n    Set i to i + 1.\nShow \"{e:.9}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let pi = 3.141592653589793f64;\n    let solarMass = ((4f64 * pi) * pi);\n    let daysPerYear = 365.24f64;\n    let mut bx = Seq::<f64>::default();\n    let mut posY = Seq::<f64>::default();\n    let mut bz = Seq::<f64>::default();\n    let mut bvx = Seq::<f64>::default();\n    let mut bvy = Seq::<f64>::default();\n    let mut bvz = Seq::<f64>::default();\n    let mut bm = Seq::<f64>::default();\n    bx.push(0f64);\n    posY.push(0f64);\n    bz.push(0f64);\n    bvx.push(0f64);\n    bvy.push(0f64);\n    bvz.push(0f64);\n    bm.push(solarMass);\n    bx.push(4.841431442464721f64);\n    posY.push((0f64 - 1.1603200440274284f64));\n    bz.push((0f64 - 0.10362204447112311f64));\n    bvx.push((0.001660076642744037f64 * daysPerYear));\n    bvy.push((0.007699011184197404f64 * daysPerYear));\n    bvz.push((0f64 - (0.0000690460016972063f64 * daysPerYear)));\n    bm.push((0.0009547919384243266f64 * solarMass));\n    bx.push(8.34336671824458f64);\n    posY.push(4.124798564124305f64);\n    bz.push((0f64 - 0.4035234171143214f64));\n    bvx.push((0f64 - (0.002767425107268624f64 * daysPerYear)));\n    bvy.push((0.004998528012349172f64 * daysPerYear));\n    bvz.push((0.00002304172975737639f64 * daysPerYear));\n    bm.push((0.0002858859806661308f64 * solarMass));\n    bx.push(12.894369562139131f64);\n    posY.push((0f64 - 15.111151401698631f64));\n    bz.push((0f64 - 0.22330757889265573f64));\n    bvx.push((0.002964601375647616f64 * daysPerYear));\n    bvy.push((0.0023784717395948095f64 * daysPerYear));\n    bvz.push((0f64 - (0.000029658956854023756f64 * daysPerYear)));\n    bm.push((0.00004366244043351563f64 * solarMass));\n    bx.push(15.379697114850917f64);\n    posY.push((0f64 - 25.919314609987964f64));\n    bz.push(0.17925877295037118f64);\n    bvx.push((0.0026806777249038932f64 * daysPerYear));\n    bvy.push((0.001628241700382423f64 * daysPerYear));\n    bvz.push((0f64 - (0.00009515922545197159f64 * daysPerYear)));\n    bm.push((0.00005151389020466114f64 * solarMass));\n    let mut px = 0f64;\n    let mut py = 0f64;\n    let mut pz = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 0..5 {\n        px = (px + (bvx[i as usize] * bm[i as usize]));\n        py = (py + (bvy[i as usize] * bm[i as usize]));\n        pz = (pz + (bvz[i as usize] * bm[i as usize]));\n    }\n    let mut i = 6;\n    bvx[0] = (0f64 - (px / solarMass));\n    bvy[0] = (0f64 - (py / solarMass));\n    bvz[0] = (0f64 - (pz / solarMass));\n    let mut e = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 1..6 {\n        e = (e + ((0.5f64 * bm[(i - 1) as usize]) * (((bvx[(i - 1) as usize] * bvx[(i - 1) as usize]) + (bvy[(i - 1) as usize] * bvy[(i - 1) as usize])) + (bvz[(i - 1) as usize] * bvz[(i - 1) as usize]))));\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n        for j in (i + 1)..6 {\n            let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n            let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n            let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n            e = (e - ((bm[(i - 1) as usize] * bm[(j - 1) as usize]) / (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt()));\n        }\n    }\n    i = 6;\n    println!(\"{:.9}\", e as f64);\n    let dt = 0.01f64;\n    for step in 0..n {\n        for i in 1..6 {\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n            unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n            for j in (i + 1)..6 {\n                let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n                let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n                let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n                let dist = (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt();\n                let mag = (dt / ((dist * dist) * dist));\n                bvx[(i - 1) as usize] = (bvx[(i - 1) as usize] - ((dx * bm[(j - 1) as usize]) * mag));\n                bvy[(i - 1) as usize] = (bvy[(i - 1) as usize] - ((dy * bm[(j - 1) as usize]) * mag));\n                bvz[(i - 1) as usize] = (bvz[(i - 1) as usize] - ((dz * bm[(j - 1) as usize]) * mag));\n                bvx[(j - 1) as usize] = (bvx[(j - 1) as usize] + ((dx * bm[(i - 1) as usize]) * mag));\n                bvy[(j - 1) as usize] = (bvy[(j - 1) as usize] + ((dy * bm[(i - 1) as usize]) * mag));\n                bvz[(j - 1) as usize] = (bvz[(j - 1) as usize] + ((dz * bm[(i - 1) as usize]) * mag));\n            }\n        }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n        for i in 0..5 {\n            bx[i as usize] = (bx[i as usize] + (dt * bvx[i as usize]));\n            posY[i as usize] = (posY[i as usize] + (dt * bvy[i as usize]));\n            bz[i as usize] = (bz[i as usize] + (dt * bvz[i as usize]));\n        }\n    }\n    e = 0f64;\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvx.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvy.len()); }\n    unsafe { std::hint::assert_unchecked((5 as usize) <= bvz.len()); }\n    for i in 1..6 {\n        e = (e + ((0.5f64 * bm[(i - 1) as usize]) * (((bvx[(i - 1) as usize] * bvx[(i - 1) as usize]) + (bvy[(i - 1) as usize] * bvy[(i - 1) as usize])) + (bvz[(i - 1) as usize] * bvz[(i - 1) as usize]))));\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bx.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= posY.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bz.len()); }\n        unsafe { std::hint::assert_unchecked((5 as usize) <= bm.len()); }\n        for j in (i + 1)..6 {\n            let dx = (bx[(i - 1) as usize] - bx[(j - 1) as usize]);\n            let dy = (posY[(i - 1) as usize] - posY[(j - 1) as usize]);\n            let dz = (bz[(i - 1) as usize] - bz[(j - 1) as usize]);\n            e = (e - ((bm[(i - 1) as usize] * bm[(j - 1) as usize]) / (((((dx * dx) + (dy * dy)) + (dz * dz))) as f64).sqrt()));\n        }\n    }\n    println!(\"{:.9}\", e as f64);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 2.5664761600000014000,
            "median_ms": 2.0469048600000013000,
            "stddev_ms": 1.9467938637192294000,
            "min_ms": 0.4750303600000016000,
            "max_ms": 6.7676973600000025000,
            "cv": 0.75854741768543384327,
            "runs": 10,
            "user_ms": 0.8520000000000001000,
            "system_ms": 0.8329599999999996000
          },
          "cpp": {
            "mean_ms": 2.8778840600000013000,
            "median_ms": 2.3536963600000018000,
            "stddev_ms": 1.7744164825627764000,
            "min_ms": 1.0768213600000015000,
            "max_ms": 6.005447360000002000,
            "cv": 0.61656982893284992115,
            "runs": 10,
            "user_ms": 0.9760000000000001000,
            "system_ms": 0.9707599999999997000
          },
          "rust": {
            "mean_ms": 1.6194050600000017000,
            "median_ms": 1.3164883600000014000,
            "stddev_ms": 0.9014788275367993000,
            "min_ms": 0.6679473600000015000,
            "max_ms": 3.2814053600000023000,
            "cv": 0.55667284844521750083,
            "runs": 10,
            "user_ms": 0.9856000,
            "system_ms": 0.6166599999999996000
          },
          "zig": {
            "mean_ms": 4.049906124000001000,
            "median_ms": 0.9457593600000012000,
            "stddev_ms": 7.629949667150964000,
            "min_ms": 0,
            "max_ms": 24.986988360000004000,
            "cv": 1.88398185872393374914,
            "runs": 10,
            "user_ms": 0.7768000,
            "system_ms": 0.4942279999999998000
          },
          "go": {
            "mean_ms": 7.246946760000002000,
            "median_ms": 2.0475503600000016000,
            "stddev_ms": 16.63489956255911000,
            "min_ms": 1.4378633600000013000,
            "max_ms": 54.583655360000004000,
            "cv": 2.29543559701259698631,
            "runs": 10,
            "user_ms": 1.3056000,
            "system_ms": 1.1485599999999999000
          },
          "java": {
            "mean_ms": 83.64822986000002000,
            "median_ms": 82.89219636000002000,
            "stddev_ms": 3.9289839885494355000,
            "min_ms": 79.68669636000002000,
            "max_ms": 92.90382136000001000,
            "cv": 0.04697031838121714152,
            "runs": 10,
            "user_ms": 50.105199999999996000,
            "system_ms": 32.74615999999999000
          },
          "js": {
            "mean_ms": 64.74984686000,
            "median_ms": 64.86207136000001000,
            "stddev_ms": 10.771272332893276000,
            "min_ms": 51.96828036000,
            "max_ms": 89.04748836000001000,
            "cv": 0.16635208969964930663,
            "runs": 10,
            "user_ms": 43.518999999999995000,
            "system_ms": 7.82406000
          },
          "python": {
            "mean_ms": 235.03173006000005000,
            "median_ms": 228.56059286000002000,
            "stddev_ms": 33.45385966023113000,
            "min_ms": 202.58757136000,
            "max_ms": 308.12203036000,
            "cv": 0.14233763097302166403,
            "runs": 10,
            "user_ms": 65.2107000,
            "system_ms": 15.15736000
          },
          "ruby": {
            "mean_ms": 101.43454666000003000,
            "median_ms": 100.65092586000002000,
            "stddev_ms": 5.983425843413454000,
            "min_ms": 94.93432136000002000,
            "max_ms": 112.79165536000002000,
            "cv": 0.05898804737077781139,
            "runs": 10,
            "user_ms": 75.81009999999999000,
            "system_ms": 17.322059999999997000
          },
          "nim": {
            "mean_ms": 1.0203840600000013000,
            "median_ms": 0.8171548600000014000,
            "stddev_ms": 0.4846630160412835000,
            "min_ms": 0.6195293600000009000,
            "max_ms": 2.0672803600000015000,
            "cv": 0.47498097534107195140,
            "runs": 10,
            "user_ms": 0.7961000000000001000,
            "system_ms": 0.35125999999999967000
          },
          "logos_release": {
            "mean_ms": 7.431563360000002000,
            "median_ms": 2.5452798600000015000,
            "stddev_ms": 10.003388921701386000,
            "min_ms": 2.192238360000001000,
            "max_ms": 30.65015536000,
            "cv": 1.34606790484275482351,
            "runs": 10,
            "user_ms": 1.9193000,
            "system_ms": 0.7493599999999996000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "mandelbrot",
      "name": "Mandelbrot Set",
      "description": "Mandelbrot set escape iteration. Measures FP branching and convergence.",
      "reference_size": "200",
      "sizes": [
        "100",
        "200",
        "500",
        "1000",
        "2000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable count be 0.\nLet mutable y be 0.\nWhile y is less than n:\n    Let mutable x be 0.\n    While x is less than n:\n        Let cr be 2.0 * x / n - 1.5.\n        Let ci be 2.0 * y / n - 1.0.\n        Let mutable zr be 0.0.\n        Let mutable zi be 0.0.\n        Let mutable isInside be 1.\n        Let mutable iter be 0.\n        While iter is less than 50:\n            Let zr2 be zr * zr - zi * zi + cr.\n            Let zi2 be 2.0 * zr * zi + ci.\n            Set zr to zr2.\n            Set zi to zi2.\n            If zr * zr + zi * zi is greater than 4.0:\n                Set isInside to 0.\n                Set iter to 50.\n            Set iter to iter + 1.\n        If isInside equals 1:\n            Set count to count + 1.\n        Set x to x + 1.\n    Set y to y + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut count = 0;\n    for y in 0..n {\n        for x in 0..n {\n            let cr = (((2f64 * ((x) as f64)) / ((n) as f64)) - 1.5f64);\n            let ci = (((2f64 * ((y) as f64)) / ((n) as f64)) - 1f64);\n            let mut zr = 0f64;\n            let mut zi = 0f64;\n            let mut isInside = 1;\n            let mut iter = 0;\n            while (iter < 50) {\n                let zr2 = (((zr * zr) - (zi * zi)) + cr);\n                let zi2 = (((2f64 * zr) * zi) + ci);\n                zr = zr2;\n                zi = zi2;\n                if (((zr * zr) + (zi * zi)) > 4f64) {\n                    isInside = 0;\n                    break;\n                }\n                iter = (iter + 1);\n            }\n            if (isInside == 1) {\n                count = (count + 1);\n            }\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "200": {
          "c": {
            "mean_ms": 4.421541659999999000,
            "median_ms": 4.42382476000,
            "stddev_ms": 0.26897532993409547000,
            "min_ms": 4.032449259999999000,
            "max_ms": 4.89636626000,
            "cv": 0.06083292901374484184,
            "runs": 10,
            "user_ms": 3.05374000,
            "system_ms": 0.70264000
          },
          "cpp": {
            "mean_ms": 4.466941559999999000,
            "median_ms": 4.47861626000,
            "stddev_ms": 0.1210436836362536000,
            "min_ms": 4.242658259999999000,
            "max_ms": 4.62390826000,
            "cv": 0.02709766447812082571,
            "runs": 10,
            "user_ms": 3.0524399999999996000,
            "system_ms": 0.63744000
          },
          "rust": {
            "mean_ms": 6.06408346000,
            "median_ms": 6.02280426000,
            "stddev_ms": 0.5187561881226199000,
            "min_ms": 5.40124126000,
            "max_ms": 7.096075259999999000,
            "cv": 0.08554568741417353447,
            "runs": 10,
            "user_ms": 4.13464000,
            "system_ms": 0.9425400000000001000
          },
          "zig": {
            "mean_ms": 9.770591659999998000,
            "median_ms": 6.12788776000,
            "stddev_ms": 8.654968637760512000,
            "min_ms": 4.995783259999999000,
            "max_ms": 32.71357526000,
            "cv": 0.88581827374827716130,
            "runs": 10,
            "user_ms": 4.01044000,
            "system_ms": 0.8638399999999999000
          },
          "go": {
            "mean_ms": 6.1722624599999994000,
            "median_ms": 6.24319976000,
            "stddev_ms": 0.48010608862597575000,
            "min_ms": 5.45361626000,
            "max_ms": 6.94232526000,
            "cv": 0.07778445776364082169,
            "runs": 10,
            "user_ms": 4.34724000,
            "system_ms": 1.19214000
          },
          "java": {
            "mean_ms": 66.20757486000,
            "median_ms": 67.76657526000002000,
            "stddev_ms": 5.222303586845181000,
            "min_ms": 56.550866260000006000,
            "max_ms": 71.86540826000,
            "cv": 0.07887773563505481040,
            "runs": 10,
            "user_ms": 30.508139999999996000,
            "system_ms": 32.15614000
          },
          "js": {
            "mean_ms": 56.614658260000006000,
            "median_ms": 53.30590826000001000,
            "stddev_ms": 9.014633427923892000,
            "min_ms": 52.14945026000001000,
            "max_ms": 81.74969926000,
            "cv": 0.15922790501577587451,
            "runs": 10,
            "user_ms": 41.304139999999996000,
            "system_ms": 6.58184000
          },
          "python": {
            "mean_ms": 469.46274156000,
            "median_ms": 442.63774176000004000,
            "stddev_ms": 63.51390973331364000,
            "min_ms": 409.84270026000,
            "max_ms": 598.65607426000,
            "cv": 0.13529062928883399417,
            "runs": 10,
            "user_ms": 272.88074000,
            "system_ms": 19.034839999999997000
          },
          "ruby": {
            "mean_ms": 602.7097417600001000,
            "median_ms": 457.91919976000006000,
            "stddev_ms": 535.2365910736000,
            "min_ms": 288.61461726000004000,
            "max_ms": 2091.28349126000,
            "cv": 0.88805033997066533692,
            "runs": 10,
            "user_ms": 213.09624000,
            "system_ms": 29.03044000
          },
          "nim": {
            "mean_ms": 22.423721060000002000,
            "median_ms": 20.03384626000,
            "stddev_ms": 10.389927756221823000,
            "min_ms": 10.67399226000,
            "max_ms": 44.80636626000,
            "cv": 0.46334538894865391593,
            "runs": 10,
            "user_ms": 3.6313400000000003000,
            "system_ms": 2.40674000
          },
          "logos_release": {
            "mean_ms": 47.922250060000005000,
            "median_ms": 38.509721260000004000,
            "stddev_ms": 31.45120169045388000,
            "min_ms": 21.173783260000002000,
            "max_ms": 127.04819926000,
            "cv": 0.65629643122090659026,
            "runs": 10,
            "user_ms": 6.087340000000001000,
            "system_ms": 3.5974399999999995000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "spectral_norm",
      "name": "Spectral Norm",
      "description": "Spectral norm power method. Measures FP dot products and array throughput.",
      "reference_size": "500",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To aVal (i: Int, j: Int) -> Float:\n    Return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1).\n\n## To mulAv (n: Int, v: Seq of Float, out: Seq of Float) -> Seq of Float:\n    Let mutable result be out.\n    Let mutable i be 0.\n    While i is less than n:\n        Let mutable sum be 0.0.\n        Let mutable j be 0.\n        While j is less than n:\n            Set sum to sum + aVal(i, j) * item (j + 1) of v.\n            Set j to j + 1.\n        Set item (i + 1) of result to sum.\n        Set i to i + 1.\n    Return result.\n\n## To mulAtv (n: Int, v: Seq of Float, out: Seq of Float) -> Seq of Float:\n    Let mutable result be out.\n    Let mutable i be 0.\n    While i is less than n:\n        Let mutable sum be 0.0.\n        Let mutable j be 0.\n        While j is less than n:\n            Set sum to sum + aVal(j, i) * item (j + 1) of v.\n            Set j to j + 1.\n        Set item (i + 1) of result to sum.\n        Set i to i + 1.\n    Return result.\n\n## To mulAtav (n: Int, v: Seq of Float, result: Seq of Float, tmp: Seq of Float) -> Seq of Float:\n    Let t be mulAv(n, v, tmp).\n    Return mulAtv(n, t, result).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable u be a new Seq of Float.\nLet mutable v be a new Seq of Float.\nLet mutable tmp be a new Seq of Float.\nLet mutable i be 0.\nWhile i is less than n:\n    Push 1.0 to u.\n    Push 0.0 to v.\n    Push 0.0 to tmp.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than 10:\n    Set v to mulAtav(n, u, v, tmp).\n    Set u to mulAtav(n, v, u, tmp).\n    Set i to i + 1.\nLet mutable vbv be 0.0.\nLet mutable vv be 0.0.\nSet i to 1.\nWhile i is at most n:\n    Set vbv to vbv + item i of u * item i of v.\n    Set vv to vv + item i of v * item i of v.\n    Set i to i + 1.\nLet result be sqrt(vbv / vv).\nShow \"{result:.9}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn aVal(i: i64, j: i64) -> f64 {\n    return (1f64 / (((((((i + j) * ((i + j) + 1)) / 2) + i) + 1)) as f64));\n}\n\n#[inline]\nfn mulAv(n: i64, v: &[f64], out: Vec<f64>) -> Vec<f64> {\n    let mut result = out;\n    for i in 0..n {\n        let mut sum = 0f64;\n        unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n        for j in 0..n {\n            sum = (sum + (((aVal(i, j) * v[j as usize])) as f64));\n        }\n        result[(i) as usize] = sum;\n    }\n    return result;\n}\n\n#[inline]\nfn mulAtv(n: i64, v: &[f64], out: Vec<f64>) -> Vec<f64> {\n    let mut result = out;\n    for i in 0..n {\n        let mut sum = 0f64;\n        unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n        for j in 0..n {\n            sum = (sum + (((aVal(j, i) * v[j as usize])) as f64));\n        }\n        result[(i) as usize] = sum;\n    }\n    return result;\n}\n\n#[inline]\nfn mulAtav(n: i64, v: &[f64], result: Vec<f64>, tmp: Vec<f64>) -> Vec<f64> {\n    let t = mulAv(n, v, tmp.clone());\n    return mulAtv(n, &t, result.clone());\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut u: Vec<f64> = Vec::with_capacity(n as usize);\n    let mut v: Vec<f64> = Vec::with_capacity(n as usize);\n    let mut tmp: Vec<f64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        u.push(1f64);\n        v.push(0f64);\n        tmp.push(0f64);\n    }\n    let mut i = 0;\n    for i in 0..10 {\n        v = mulAtav(n, &u, v, tmp.clone());\n        u = mulAtav(n, &v, u, tmp.clone());\n    }\n    i = 10;\n    let mut vbv = 0f64;\n    let mut vv = 0f64;\n    unsafe { std::hint::assert_unchecked((n as usize) <= u.len()); }\n    unsafe { std::hint::assert_unchecked((n as usize) <= v.len()); }\n    for i in 0..n {\n        vbv = (vbv + (u[i as usize] * v[i as usize]));\n        vv = (vv + (v[i as usize] * v[i as usize]));\n    }\n    let result = (((vbv / vv)) as f64).sqrt();\n    println!(\"{:.9}\", result as f64);\n}",
      "scaling": {
        "500": {
          "c": {
            "mean_ms": 24.38570426800001000,
            "median_ms": 15.87039596000001000,
            "stddev_ms": 27.66277903401572000,
            "min_ms": 0,
            "max_ms": 79.83460446000001000,
            "cv": 1.13438507783086794613,
            "runs": 10,
            "user_ms": 10.749899999999998000,
            "system_ms": 2.186453999999999000
          },
          "cpp": {
            "mean_ms": 8.418970892000003000,
            "median_ms": 0,
            "stddev_ms": 26.24766075051581000,
            "min_ms": 0,
            "max_ms": 83.11493746000001000,
            "cv": 3.11768042522361540039,
            "runs": 10,
            "user_ms": 10.070099999999998000,
            "system_ms": 0.22574199999999948000
          },
          "rust": {
            "mean_ms": 0,
            "median_ms": 0,
            "stddev_ms": 0,
            "min_ms": 0,
            "max_ms": 0,
            "cv": 0,
            "runs": 10,
            "user_ms": 10.197999999999999000,
            "system_ms": 0.1509299999999997000
          },
          "zig": {
            "mean_ms": 0.6883666920000014000,
            "median_ms": 0,
            "stddev_ms": 1.6524712151412297000,
            "min_ms": 0,
            "max_ms": 5.118437460000007000,
            "cv": 2.40056823542709463229,
            "runs": 10,
            "user_ms": 10.150699999999999000,
            "system_ms": 0.3324539999999993000
          },
          "go": {
            "mean_ms": 75.61409156000001000,
            "median_ms": 59.94499946000001000,
            "stddev_ms": 44.856869262771513000,
            "min_ms": 23.62022946000001000,
            "max_ms": 146.47735446000001000,
            "cv": 0.59323425485020145718,
            "runs": 10,
            "user_ms": 38.863400000000006000,
            "system_ms": 1.7182599999999992000
          },
          "java": {
            "mean_ms": 125.12403316000,
            "median_ms": 108.95670846000001000,
            "stddev_ms": 38.06013581267335000,
            "min_ms": 84.43306246000001000,
            "max_ms": 203.13456246000,
            "cv": 0.30417925998280976447,
            "runs": 10,
            "user_ms": 89.18430000000001000,
            "system_ms": 37.10586000
          },
          "js": {
            "mean_ms": 84.78299996000001000,
            "median_ms": 75.52975046000,
            "stddev_ms": 27.05008268078367000,
            "min_ms": 68.02877146000,
            "max_ms": 159.76735346000,
            "cv": 0.31905078486896781435,
            "runs": 10,
            "user_ms": 79.75289999999999000,
            "system_ms": 6.955759999999998000
          },
          "python": {
            "mean_ms": 4885.70163726000,
            "median_ms": 5070.041270959999000,
            "stddev_ms": 946.9830013380215000,
            "min_ms": 2478.56714546000,
            "max_ms": 5846.362312459999000,
            "cv": 0.19382743189146291450,
            "runs": 10,
            "user_ms": 2150.4384000,
            "system_ms": 51.61226000
          },
          "ruby": {
            "mean_ms": 1808.76299146000,
            "median_ms": 1675.6424994599999000,
            "stddev_ms": 391.0666424616551000,
            "min_ms": 1527.06164546000,
            "max_ms": 2829.87647846000,
            "cv": 0.21620668064752549268,
            "runs": 10,
            "user_ms": 1519.2858000,
            "system_ms": 32.457360000000005000
          },
          "nim": {
            "mean_ms": 49.98058756000001000,
            "median_ms": 41.377395460000015000,
            "stddev_ms": 24.16739039744186000,
            "min_ms": 26.760187460000008000,
            "max_ms": 105.65014546000001000,
            "cv": 0.48353554004201576786,
            "runs": 10,
            "user_ms": 38.573000,
            "system_ms": 1.258759999999999000
          },
          "logos_release": {
            "mean_ms": 20.564960214000005000,
            "median_ms": 12.264499960000008000,
            "stddev_ms": 18.810234462847457000,
            "min_ms": 0,
            "max_ms": 57.95122846000001000,
            "cv": 0.91467400214283013281,
            "runs": 10,
            "user_ms": 11.901099999999998000,
            "system_ms": 0.8223599999999992000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "pi_leibniz",
      "name": "Pi (Leibniz Series)",
      "description": "Leibniz series for pi. Measures pure FP loop overhead.",
      "reference_size": "1000000",
      "sizes": [
        "100000",
        "1000000",
        "5000000",
        "10000000",
        "50000000",
        "100000000",
        "200000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.0.\nLet mutable sign be 1.0.\nLet mutable k be 0.\nWhile k is less than n:\n    Set sum to sum + sign / (2.0 * k + 1.0).\n    Set sign to 0.0 - sign.\n    Set k to k + 1.\nLet result be sum * 4.0.\nShow \"{result:.15}\".",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0f64;\n    let mut sign = 1f64;\n    for k in 0..n {\n        sum = (sum + (sign / ((2f64 * ((k) as f64)) + 1f64)));\n        sign = (0f64 - sign);\n    }\n    let result = (sum * 4f64);\n    println!(\"{:.15}\", result as f64);\n}",
      "scaling": {
        "1000000": {
          "c": {
            "mean_ms": 1.7949501160000013000,
            "median_ms": 0,
            "stddev_ms": 3.7851119207081316000,
            "min_ms": 0,
            "max_ms": 9.161584080000007000,
            "cv": 2.10875605230921573901,
            "runs": 10,
            "user_ms": 1.4290400000000003000,
            "system_ms": 0.41485999999999926000
          },
          "cpp": {
            "mean_ms": 3.911312632000003000,
            "median_ms": 0,
            "stddev_ms": 5.239721213644999000,
            "min_ms": 0,
            "max_ms": 12.359667080000008000,
            "cv": 1.33963242180559986008,
            "runs": 10,
            "user_ms": 1.63874000,
            "system_ms": 0.6841999999999992000
          },
          "rust": {
            "mean_ms": 3.5167959320000024000,
            "median_ms": 0,
            "stddev_ms": 6.4855034080847935000,
            "min_ms": 0,
            "max_ms": 16.58416708000001000,
            "cv": 1.84415119145013531994,
            "runs": 10,
            "user_ms": 1.8129400000000003000,
            "system_ms": 0.8015999999999992000
          },
          "zig": {
            "mean_ms": 18.36425836400001000,
            "median_ms": 10.448021080000007000,
            "stddev_ms": 21.94919519992356000,
            "min_ms": 0,
            "max_ms": 58.43312508000001000,
            "cv": 1.19521272053932795823,
            "runs": 10,
            "user_ms": 2.10804000,
            "system_ms": 1.977999999999999000
          },
          "go": {
            "mean_ms": 11.023120772000006000,
            "median_ms": 8.898541580000007000,
            "stddev_ms": 9.417994061636736000,
            "min_ms": 0,
            "max_ms": 22.448833080000008000,
            "cv": 0.85438545548367061596,
            "runs": 10,
            "user_ms": 2.3610400000000004000,
            "system_ms": 1.9423999999999993000
          },
          "java": {
            "mean_ms": 248.69197098000004000,
            "median_ms": 197.21435458000003000,
            "stddev_ms": 142.7735767325135000,
            "min_ms": 95.51512508000001000,
            "max_ms": 512.8940000800001000,
            "cv": 0.57409805459298659114,
            "runs": 10,
            "user_ms": 58.55663999999999000,
            "system_ms": 45.708799999999994000
          },
          "js": {
            "mean_ms": 73.10869158000001000,
            "median_ms": 63.96929108000002000,
            "stddev_ms": 26.89920838678949000,
            "min_ms": 49.172625080000004000,
            "max_ms": 129.50808308000,
            "cv": 0.36793447954617992249,
            "runs": 10,
            "user_ms": 41.57514000,
            "system_ms": 6.8712999999999995000
          },
          "python": {
            "mean_ms": 714.2332667800001000,
            "median_ms": 729.48883358000,
            "stddev_ms": 149.6633837225001000,
            "min_ms": 425.23954108000006000,
            "max_ms": 898.4059590800001000,
            "cv": 0.20954412330474629960,
            "runs": 10,
            "user_ms": 142.80843999999998000,
            "system_ms": 22.208899999999997000
          },
          "ruby": {
            "mean_ms": 340.00097108000,
            "median_ms": 323.89212508000004000,
            "stddev_ms": 138.05807215522753000,
            "min_ms": 202.71395908000,
            "max_ms": 702.9730000800001000,
            "cv": 0.40605199366546329806,
            "runs": 10,
            "user_ms": 144.75394000,
            "system_ms": 25.3262000
          },
          "nim": {
            "mean_ms": 18.903345748000004000,
            "median_ms": 5.551229080000008000,
            "stddev_ms": 25.35423957902974000,
            "min_ms": 0,
            "max_ms": 63.37033308000001000,
            "cv": 1.34125672338782927259,
            "runs": 10,
            "user_ms": 1.66694000,
            "system_ms": 1.4829999999999993000
          },
          "logos_release": {
            "mean_ms": 6.184929272000007000,
            "median_ms": 2.917750080000007000,
            "stddev_ms": 7.1524309513621735000,
            "min_ms": 0,
            "max_ms": 17.46575008000001000,
            "cv": 1.15642889947701982468,
            "runs": 10,
            "user_ms": 3.2899400000000003000,
            "system_ms": 1.663599999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "gcd",
      "name": "GCD Sum",
      "description": "GCD sum via Euclidean algorithm. Measures modulo-heavy tight loops.",
      "reference_size": "1000",
      "sizes": [
        "500",
        "1000",
        "2000",
        "3000",
        "5000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To gcd (a: Int, b: Int) -> Int:\n    Let mutable x be a.\n    Let mutable y be b.\n    While y is greater than 0:\n        Let temp be y.\n        Set y to x % y.\n        Set x to temp.\n    Return x.\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Let mutable j be i.\n    While j is at most n:\n        Set sum to sum + gcd(i, j).\n        Set j to j + 1.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn gcd(a: i64, b: i64) -> i64 {\n    let mut x = a;\n    let mut y = b;\n    while (y > 0) {\n        let temp = y;\n        y = (x % y);\n        x = temp;\n    }\n    return x;\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0;\n    for i in 1..(n + 1) {\n        for j in i..(n + 1) {\n            sum = (sum + gcd(i, j));\n        }\n    }\n    show(&sum);\n}",
      "scaling": {
        "1000": {
          "c": {
            "mean_ms": 12.117752940000004000,
            "median_ms": 8.037173640000004000,
            "stddev_ms": 12.08301189490136000,
            "min_ms": 2.9840071400000032000,
            "max_ms": 43.202757140000006000,
            "cv": 0.99713304560089141506,
            "runs": 10,
            "user_ms": 8.800279999999999000,
            "system_ms": 0.6722400000000007000
          },
          "cpp": {
            "mean_ms": 12.023286740000003000,
            "median_ms": 7.712465640000004000,
            "stddev_ms": 13.902113590455241000,
            "min_ms": 2.158049140000005000,
            "max_ms": 50.141049140000005000,
            "cv": 1.15626566105294745147,
            "runs": 10,
            "user_ms": 8.74278000,
            "system_ms": 0.9227400000000007000
          },
          "rust": {
            "mean_ms": 11.340188498000003000,
            "median_ms": 2.6086531400000036000,
            "stddev_ms": 14.525981802464803000,
            "min_ms": 0,
            "max_ms": 39.773424140000006000,
            "cv": 1.28092948411101439146,
            "runs": 10,
            "user_ms": 8.49028000,
            "system_ms": 0.33665200000000044000
          },
          "zig": {
            "mean_ms": 11.002178240000004000,
            "median_ms": 3.4860906400000034000,
            "stddev_ms": 20.87866197605857000,
            "min_ms": 2.545966140000003000,
            "max_ms": 70.09854914000001000,
            "cv": 1.89768439672711232219,
            "runs": 10,
            "user_ms": 10.51848000,
            "system_ms": 0.4957400000000006000
          },
          "go": {
            "mean_ms": 3.5500526260000033000,
            "median_ms": 3.7126531400000044000,
            "stddev_ms": 2.677922840585285000,
            "min_ms": 0,
            "max_ms": 7.723382140000004000,
            "cv": 0.75433327973016998049,
            "runs": 10,
            "user_ms": 8.96338000,
            "system_ms": 1.1835400000000005000
          },
          "java": {
            "mean_ms": 148.42098664000003000,
            "median_ms": 136.56471564000,
            "stddev_ms": 46.3519869879007000,
            "min_ms": 112.21059114000002000,
            "max_ms": 266.55421614000,
            "cv": 0.31230076040613423745,
            "runs": 10,
            "user_ms": 39.75228000000001000,
            "system_ms": 37.43634000
          },
          "js": {
            "mean_ms": 122.83502024000,
            "median_ms": 125.89111214000,
            "stddev_ms": 40.50047447662739000,
            "min_ms": 55.74713314000,
            "max_ms": 188.87271614000,
            "cv": 0.32971439576023136575,
            "runs": 10,
            "user_ms": 57.018780000000005000,
            "system_ms": 9.981140000000001000
          },
          "python": {
            "mean_ms": 946.5725284400002000,
            "median_ms": 896.25894464000,
            "stddev_ms": 345.29647960086235000,
            "min_ms": 626.22121614000,
            "max_ms": 1833.89175814000,
            "cv": 0.36478607737531592824,
            "runs": 10,
            "user_ms": 188.05117999999998000,
            "system_ms": 27.64344000
          },
          "ruby": {
            "mean_ms": 632.88447844000,
            "median_ms": 551.23042464000,
            "stddev_ms": 317.1435692420771000,
            "min_ms": 233.39163314000,
            "max_ms": 1114.71004914000,
            "cv": 0.50110814855786290058,
            "runs": 10,
            "user_ms": 181.58787999999998000,
            "system_ms": 32.54334000
          },
          "nim": {
            "mean_ms": 12.871278340000005000,
            "median_ms": 10.323549640000004000,
            "stddev_ms": 11.53613651010311000,
            "min_ms": 4.148257140000005000,
            "max_ms": 43.26154914000001000,
            "cv": 0.89626967931012091831,
            "runs": 10,
            "user_ms": 9.509779999999999000,
            "system_ms": 1.7854400000000006000
          },
          "logos_release": {
            "mean_ms": 5.037894226000003000,
            "median_ms": 4.344278140000005000,
            "stddev_ms": 3.5922162340885715000,
            "min_ms": 0,
            "max_ms": 9.616758140000002000,
            "cv": 0.71303923285041383099,
            "runs": 10,
            "user_ms": 9.73088000,
            "system_ms": 1.3979400000000007000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "collatz",
      "name": "Collatz Conjecture",
      "description": "Collatz step counting. Measures unpredictable branching.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable total be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Let mutable k be i.\n    While k is not 1:\n        If k % 2 equals 0:\n            Set k to k / 2.\n        Otherwise:\n            Set k to 3 * k + 1.\n        Set total to total + 1.\n    Set i to i + 1.\nShow total.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut total = 0;\n    for i in 1..(n + 1) {\n        let mut k = i;\n        while (k != 1) {\n            if ((k % 2) == 0) {\n                k = (k / 2);\n            } else {\n                k = ((3 * k) + 1);\n            }\n            total = (total + 1);\n        }\n    }\n    show(&total);\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 23.52966158000,
            "median_ms": 22.05824878000,
            "stddev_ms": 8.579196635066686000,
            "min_ms": 16.57770778000,
            "max_ms": 46.59333278000,
            "cv": 0.36461198585018858567,
            "runs": 10,
            "user_ms": 16.059499999999997000,
            "system_ms": 1.83876000
          },
          "cpp": {
            "mean_ms": 23.851203280000004000,
            "median_ms": 24.518144780000004000,
            "stddev_ms": 4.994842091752969000,
            "min_ms": 14.251332780000002000,
            "max_ms": 32.55124878000001000,
            "cv": 0.20941677587986949404,
            "runs": 10,
            "user_ms": 16.201099999999996000,
            "system_ms": 2.35786000
          },
          "rust": {
            "mean_ms": 14.46074498000,
            "median_ms": 14.825436280000003000,
            "stddev_ms": 3.3163008937485954000,
            "min_ms": 10.205165780000003000,
            "max_ms": 20.16441578000,
            "cv": 0.22933126186342547616,
            "runs": 10,
            "user_ms": 12.2763000,
            "system_ms": 1.19986000
          },
          "zig": {
            "mean_ms": 23.890878580000004000,
            "median_ms": 20.30479078000,
            "stddev_ms": 18.04751922797715000,
            "min_ms": 10.618207780000001000,
            "max_ms": 73.26737478000,
            "cv": 0.75541463105025528861,
            "runs": 10,
            "user_ms": 12.416899999999998000,
            "system_ms": 1.81746000
          },
          "go": {
            "mean_ms": 26.69999908000,
            "median_ms": 27.032915780000003000,
            "stddev_ms": 4.497247913819643000,
            "min_ms": 19.410956780000002000,
            "max_ms": 33.182249780000006000,
            "cv": 0.16843625725771534371,
            "runs": 10,
            "user_ms": 18.0548000,
            "system_ms": 2.97146000
          },
          "java": {
            "mean_ms": 167.05785318000,
            "median_ms": 142.94733228000,
            "stddev_ms": 64.33991409900187000,
            "min_ms": 94.84437478000,
            "max_ms": 292.23437378000,
            "cv": 0.38513552565336437899,
            "runs": 10,
            "user_ms": 48.834699999999995000,
            "system_ms": 43.36816000
          },
          "js": {
            "mean_ms": 111.82304488000001000,
            "median_ms": 102.70177028000,
            "stddev_ms": 25.29973931320569000,
            "min_ms": 92.31324878000,
            "max_ms": 175.30929078000002000,
            "cv": 0.22624799155089585267,
            "runs": 10,
            "user_ms": 62.4429000,
            "system_ms": 12.52606000
          },
          "python": {
            "mean_ms": 1421.1830366800002000,
            "median_ms": 1394.22414478000,
            "stddev_ms": 85.59867850926738000,
            "min_ms": 1327.96445778000,
            "max_ms": 1592.40024878000,
            "cv": 0.06023057994643173716,
            "runs": 10,
            "user_ms": 1199.7119999999997000,
            "system_ms": 21.444459999999995000
          },
          "ruby": {
            "mean_ms": 714.88592838000,
            "median_ms": 694.66291628000,
            "stddev_ms": 90.33194544934418000,
            "min_ms": 634.65883278000,
            "max_ms": 953.9567077800001000,
            "cv": 0.12635854457793710140,
            "runs": 10,
            "user_ms": 606.1443000000001000,
            "system_ms": 24.49296000
          },
          "nim": {
            "mean_ms": 40.52879518000001000,
            "median_ms": 21.272457780000004000,
            "stddev_ms": 26.753837342443274000,
            "min_ms": 18.576082780000003000,
            "max_ms": 84.08833278000,
            "cv": 0.66011923679501956018,
            "runs": 10,
            "user_ms": 19.732999999999994000,
            "system_ms": 1.36726000
          },
          "logos_release": {
            "mean_ms": 18.663740780000004000,
            "median_ms": 18.461728780000002000,
            "stddev_ms": 3.583073376328546000,
            "min_ms": 13.116957780000002000,
            "max_ms": 25.170873780000005000,
            "cv": 0.19198045121630462508,
            "runs": 10,
            "user_ms": 13.5154000,
            "system_ms": 2.04656000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "primes",
      "name": "Primes (Trial Division)",
      "description": "Trial division prime counting. Measures nested loops with early exit.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable count be 0.\nLet mutable i be 2.\nWhile i is at most n:\n    Let mutable isPrime be 1.\n    Let mutable d be 2.\n    While d * d is at most i:\n        If i % d equals 0:\n            Set isPrime to 0.\n            Break.\n        Set d to d + 1.\n    If isPrime equals 1:\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut count = 0;\n    for i in 2..(n + 1) {\n        let mut isPrime = 1;\n        let mut d = 2;\n        while ((d * d) <= i) {\n            if ((i % d) == 0) {\n                isPrime = 0;\n                break;\n            }\n            d = (d + 1);\n        }\n        if (isPrime == 1) {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 7.378968499999999000,
            "median_ms": 6.0900227000,
            "stddev_ms": 5.268246515270645000,
            "min_ms": 2.5703357000,
            "max_ms": 19.1615017000,
            "cv": 0.71395433050983287351,
            "runs": 10,
            "user_ms": 1.88296000,
            "system_ms": 1.58242000
          },
          "cpp": {
            "mean_ms": 3.1633892000000005000,
            "median_ms": 2.5574597000,
            "stddev_ms": 1.740195231390065000,
            "min_ms": 1.4593356999999998000,
            "max_ms": 6.8787517000000005000,
            "cv": 0.55010468879076426161,
            "runs": 10,
            "user_ms": 1.63816000,
            "system_ms": 0.5935200000000002000
          },
          "rust": {
            "mean_ms": 4.4185807999999995000,
            "median_ms": 3.7644187000,
            "stddev_ms": 2.7177334949859905000,
            "min_ms": 2.5088346999999995000,
            "max_ms": 11.6261267000,
            "cv": 0.61506932157628322821,
            "runs": 10,
            "user_ms": 2.06306000,
            "system_ms": 0.88482000
          },
          "zig": {
            "mean_ms": 2.2762015000,
            "median_ms": 2.0422931999999998000,
            "stddev_ms": 0.8310083304314101000,
            "min_ms": 1.4374187000,
            "max_ms": 4.2171267000,
            "cv": 0.36508557367676372236,
            "runs": 10,
            "user_ms": 1.67716000,
            "system_ms": 0.47432000000000013000
          },
          "go": {
            "mean_ms": 4.3346475000,
            "median_ms": 4.159522200000001000,
            "stddev_ms": 1.1597918250780851000,
            "min_ms": 3.0864596999999995000,
            "max_ms": 6.8582927000,
            "cv": 0.26756312366301645058,
            "runs": 10,
            "user_ms": 2.11856000,
            "system_ms": 1.4891200000000002000
          },
          "java": {
            "mean_ms": 110.13328080000002000,
            "median_ms": 108.9562097000,
            "stddev_ms": 31.877401382184534000,
            "min_ms": 66.4101267000,
            "max_ms": 185.48008470000002000,
            "cv": 0.28944385521460401469,
            "runs": 10,
            "user_ms": 28.716059999999998000,
            "system_ms": 36.630819999999994000
          },
          "js": {
            "mean_ms": 90.262135000,
            "median_ms": 89.6720222000,
            "stddev_ms": 13.409021492843691000,
            "min_ms": 74.7950017000,
            "max_ms": 121.87408570000001000,
            "cv": 0.14855644055886436765,
            "runs": 10,
            "user_ms": 44.01066000000001000,
            "system_ms": 7.658319999999999000
          },
          "python": {
            "mean_ms": 856.9296685000001000,
            "median_ms": 815.9558352000,
            "stddev_ms": 215.50748934846867000,
            "min_ms": 634.4984187000,
            "max_ms": 1264.6819187000,
            "cv": 0.25148795434484206430,
            "runs": 10,
            "user_ms": 145.73326000,
            "system_ms": 31.60412000
          },
          "ruby": {
            "mean_ms": 131.19952669999999000,
            "median_ms": 117.01821070000001000,
            "stddev_ms": 38.680775360548265000,
            "min_ms": 106.1397927000,
            "max_ms": 234.45654370000002000,
            "cv": 0.29482404649976734975,
            "runs": 10,
            "user_ms": 87.16776000,
            "system_ms": 18.09322000
          },
          "nim": {
            "mean_ms": 6.1535267000,
            "median_ms": 6.6736677000,
            "stddev_ms": 2.184397418099046000,
            "min_ms": 2.5892937000,
            "max_ms": 9.324085700000002000,
            "cv": 0.35498300805277175444,
            "runs": 10,
            "user_ms": 2.19636000,
            "system_ms": 1.5788200000000003000
          },
          "logos_release": {
            "mean_ms": 9.996485099999999000,
            "median_ms": 11.4296062000,
            "stddev_ms": 3.457320861657226000,
            "min_ms": 5.2456677000000005000,
            "max_ms": 13.4474597000,
            "cv": 0.34585365026525436884,
            "runs": 10,
            "user_ms": 3.36476000,
            "system_ms": 2.37372000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "sieve",
      "name": "Sieve of Eratosthenes",
      "description": "Classic prime sieve. Measures indexed array mutation and tight loops.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "100000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To sieve (limit: Int) -> Int:\n    Let mutable flags be a new Seq of Bool.\n    Let mutable i be 0.\n    While i is at most limit:\n        Push false to flags.\n        Set i to i + 1.\n    Let mutable count be 0.\n    Set i to 2.\n    While i is at most limit:\n        If item (i + 1) of flags equals false:\n            Set count to count + 1.\n            Let mutable j be i * i.\n            While j is at most limit:\n                Set item (j + 1) of flags to true.\n                Set j to j + i.\n        Set i to i + 1.\n    Return count.\n\n## Main\nLet arguments be args().\nLet limit be parseInt(item 2 of arguments).\nShow sieve(limit).",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn sieve(limit: i64) -> i64 {\n    let mut flags: Vec<bool> = vec![false; (limit + 1) as usize];\n    let mut i = 0;\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked((limit as usize) <= flags.len()); }\n    for i in 2..(limit + 1) {\n        if (flags[i as usize] == false) {\n            count = (count + 1);\n            let mut j = (i * i);\n            while (j <= limit) {\n                flags[(j) as usize] = true;\n                j = (j + i);\n            }\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let arguments = args();\n    let limit = parseInt(arguments[1].clone());\n    show(&sieve(limit));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 1.4592255799999992000,
            "median_ms": 1.669808699999999000,
            "stddev_ms": 0.9846576062598608000,
            "min_ms": 0,
            "max_ms": 3.1687461999999984000,
            "cv": 0.67478093843438609390,
            "runs": 10,
            "user_ms": 0.724000,
            "system_ms": 0.6827799999999998000
          },
          "cpp": {
            "mean_ms": 0.9379801599999991000,
            "median_ms": 0.8024751999999987000,
            "stddev_ms": 0.958310583699139000,
            "min_ms": 0,
            "max_ms": 3.253412199999999000,
            "cv": 1.02167468414165595944,
            "runs": 10,
            "user_ms": 0.7193000,
            "system_ms": 0.5279019999999998000
          },
          "rust": {
            "mean_ms": 8.231388359999998000,
            "median_ms": 3.7339541999999986000,
            "stddev_ms": 12.235537744026203000,
            "min_ms": 0,
            "max_ms": 33.5632042000,
            "cv": 1.48644884786194269333,
            "runs": 10,
            "user_ms": 1.1034999999999997000,
            "system_ms": 1.1066239999999998000
          },
          "zig": {
            "mean_ms": 5.619233779999999000,
            "median_ms": 3.562516199999999000,
            "stddev_ms": 5.702252682249221000,
            "min_ms": 0,
            "max_ms": 18.8721212000,
            "cv": 1.01477406093063848551,
            "runs": 10,
            "user_ms": 1.0793000,
            "system_ms": 1.4363019999999998000
          },
          "go": {
            "mean_ms": 16.378595899999997000,
            "median_ms": 16.9186002000,
            "stddev_ms": 12.094831119733442000,
            "min_ms": 0.7195791999999989000,
            "max_ms": 32.593954200000004000,
            "cv": 0.73845347877063406975,
            "runs": 10,
            "user_ms": 1.7934000,
            "system_ms": 2.63458000
          },
          "java": {
            "mean_ms": 109.68507100000002000,
            "median_ms": 97.54530820000001000,
            "stddev_ms": 30.69134271167778000,
            "min_ms": 77.4301632000,
            "max_ms": 165.5872042000,
            "cv": 0.27981330943094137582,
            "runs": 10,
            "user_ms": 25.4532000,
            "system_ms": 38.85408000
          },
          "js": {
            "mean_ms": 65.3021914000,
            "median_ms": 64.2146622000,
            "stddev_ms": 9.921115242894418000,
            "min_ms": 52.096412200000004000,
            "max_ms": 81.9532872000,
            "cv": 0.15192622223232799504,
            "runs": 10,
            "user_ms": 42.5407000,
            "system_ms": 9.188979999999998000
          },
          "python": {
            "mean_ms": 281.3976084000,
            "median_ms": 268.92078770000005000,
            "stddev_ms": 42.65791175161826000,
            "min_ms": 241.8239122000,
            "max_ms": 374.1632872000,
            "cv": 0.15159301457523780433,
            "runs": 10,
            "user_ms": 37.63029999999999000,
            "system_ms": 21.49908000
          },
          "ruby": {
            "mean_ms": 105.99365010000002000,
            "median_ms": 103.66020370000001000,
            "stddev_ms": 11.139804706604315000,
            "min_ms": 94.8704962000,
            "max_ms": 135.2687042000,
            "cv": 0.10509879314557460360,
            "runs": 10,
            "user_ms": 54.697699999999995000,
            "system_ms": 25.52218000
          },
          "nim": {
            "mean_ms": 0.7061982799999994000,
            "median_ms": 0,
            "stddev_ms": 1.1961380562745053000,
            "min_ms": 0,
            "max_ms": 3.018954199999999000,
            "cv": 1.69377084333100657829,
            "runs": 10,
            "user_ms": 0.7821000000000002000,
            "system_ms": 0.36942399999999987000
          },
          "logos_release": {
            "mean_ms": 1.562146659999999000,
            "median_ms": 0.8872666999999988000,
            "stddev_ms": 2.329533161746976000,
            "min_ms": 0,
            "max_ms": 7.3796211999999995000,
            "cv": 1.49123844860186014240,
            "runs": 10,
            "user_ms": 1.6813000000000002000,
            "system_ms": 0.4620799999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "matrix_mult",
      "name": "Matrix Multiply",
      "description": "O(n^3) matrix multiply. Measures cache locality and triple-nested loops.",
      "reference_size": "100",
      "sizes": [
        "50",
        "100",
        "200",
        "300",
        "500",
        "700"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable a be a new Seq of Int.\nLet mutable b be a new Seq of Int.\nLet mutable c be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Let mutable j be 0.\n    While j is less than n:\n        Push (i * n + j) % 100 to a.\n        Push (j * n + i) % 100 to b.\n        Push 0 to c.\n        Set j to j + 1.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n:\n    Let mutable k be 0.\n    While k is less than n:\n        Let mutable j be 0.\n        While j is less than n:\n            Let idx be i * n + j + 1.\n            Set item idx of c to (item idx of c + item (i * n + k + 1) of a * item (k * n + j + 1) of b) % 1000000007.\n            Set j to j + 1.\n        Set k to k + 1.\n    Set i to i + 1.\nLet mutable checksum be 0.\nSet i to 1.\nWhile i is at most n * n:\n    Set checksum to (checksum + item i of c) % 1000000007.\n    Set i to i + 1.\nShow checksum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut a = Seq::<i64>::default();\n    let mut b = Seq::<i64>::default();\n    let mut c = Seq::<i64>::default();\n    for i in 0..n {\n        for j in 0..n {\n            a.push((((i * n) + j) % 100));\n            b.push((((j * n) + i) % 100));\n            c.push(0);\n        }\n    }\n    let mut i = 0;\n    for i in 0..n {\n        for k in 0..n {\n            unsafe { std::hint::assert_unchecked((n as usize) <= b.len()); }\n            for j in 0..n {\n                let idx = (((i * n) + j) + 1);\n                c[(idx - 1) as usize] = ((c[(idx - 1) as usize] + (a[(((i * n) + k)) as usize] * b[(((k * n) + j)) as usize])) % 1000000007);\n            }\n        }\n    }\n    i = (0_i64).max(n);\n    let mut checksum = 0;\n    unsafe { std::hint::assert_unchecked(((n * n) as usize) <= c.len()); }\n    for i in 0..(n * n) {\n        checksum = ((checksum + c[i as usize]) % 1000000007);\n    }\n    show(&checksum);\n}",
      "scaling": {
        "100": {
          "c": {
            "mean_ms": 5.957162440000002000,
            "median_ms": 6.407038240000001000,
            "stddev_ms": 2.6761743986744627000,
            "min_ms": 0.9644122400000003000,
            "max_ms": 10.08491224000,
            "cv": 0.44923643187988370542,
            "runs": 10,
            "user_ms": 1.49228000,
            "system_ms": 1.4755799999999996000
          },
          "cpp": {
            "mean_ms": 3.4879583400000006000,
            "median_ms": 2.8451417400000003000,
            "stddev_ms": 2.0532410801745427000,
            "min_ms": 1.025787240000001000,
            "max_ms": 7.019496240000001000,
            "cv": 0.58866559747228584926,
            "runs": 10,
            "user_ms": 1.3743800000000001000,
            "system_ms": 0.9331799999999998000
          },
          "rust": {
            "mean_ms": 8.175470940000002000,
            "median_ms": 7.83795374000,
            "stddev_ms": 1.7611540749216472000,
            "min_ms": 5.39549624000,
            "max_ms": 11.68182924000,
            "cv": 0.21541928139024695367,
            "runs": 10,
            "user_ms": 2.2667800000000004000,
            "system_ms": 2.0565799999999997000
          },
          "zig": {
            "mean_ms": 8.69682074000,
            "median_ms": 4.189537240000001000,
            "stddev_ms": 9.924580908481887000,
            "min_ms": 1.644246240000001000,
            "max_ms": 31.246079240000002000,
            "cv": 1.14117344776752142185,
            "runs": 10,
            "user_ms": 1.73338000,
            "system_ms": 0.9816799999999997000
          },
          "go": {
            "mean_ms": 5.224362540000001000,
            "median_ms": 5.177662240000001000,
            "stddev_ms": 1.1141058654409873000,
            "min_ms": 2.769663240000001000,
            "max_ms": 6.866329240000002000,
            "cv": 0.21325202010980407319,
            "runs": 10,
            "user_ms": 2.55398000,
            "system_ms": 1.6339799999999997000
          },
          "java": {
            "mean_ms": 126.11869584000,
            "median_ms": 114.94697524000,
            "stddev_ms": 38.89444079035893000,
            "min_ms": 92.43103724000,
            "max_ms": 223.00516224000,
            "cv": 0.30839552004012325980,
            "runs": 10,
            "user_ms": 33.326180000000004000,
            "system_ms": 39.844979999999995000
          },
          "js": {
            "mean_ms": 74.80297504000002000,
            "median_ms": 73.56124574000,
            "stddev_ms": 12.51611244273248000,
            "min_ms": 57.720120240000006000,
            "max_ms": 94.30566224000,
            "cv": 0.16732105154961596903,
            "runs": 10,
            "user_ms": 48.05878000,
            "system_ms": 10.481179999999998000
          },
          "python": {
            "mean_ms": 654.99558754000,
            "median_ms": 618.6820792400001000,
            "stddev_ms": 115.70250385627098000,
            "min_ms": 503.64120424000,
            "max_ms": 936.3042462400001000,
            "cv": 0.17664623404688986647,
            "runs": 10,
            "user_ms": 364.26678000,
            "system_ms": 23.512979999999996000
          },
          "ruby": {
            "mean_ms": 198.20981674000002000,
            "median_ms": 190.76812074000002000,
            "stddev_ms": 17.521363047587682000,
            "min_ms": 186.97982924000,
            "max_ms": 231.43595424000002000,
            "cv": 0.08839805886391174830,
            "runs": 10,
            "user_ms": 168.47227999999997000,
            "system_ms": 15.533879999999996000
          },
          "nim": {
            "mean_ms": 5.16664604000,
            "median_ms": 4.78062124000,
            "stddev_ms": 1.3224708208952245000,
            "min_ms": 4.265746240000002000,
            "max_ms": 8.752538240000001000,
            "cv": 0.25596311623763266352,
            "runs": 10,
            "user_ms": 4.531180000000001000,
            "system_ms": 0.2085799999999998000
          },
          "logos_release": {
            "mean_ms": 6.382816640000001000,
            "median_ms": 3.7816622400000006000,
            "stddev_ms": 7.778012988402661000,
            "min_ms": 3.0547872400000006000,
            "max_ms": 28.39045424000,
            "cv": 1.21858631182653866450,
            "runs": 10,
            "user_ms": 2.72518000,
            "system_ms": 0.8490799999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "prefix_sum",
      "name": "Prefix Sum",
      "description": "Sequential prefix sum scan. Measures read-modify-write bandwidth.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push ((seed / 65536) % 32768) % 1000 to arr.\n    Set i to i + 1.\nSet i to 2.\nWhile i is at most n:\n    Set item i of arr to (item i of arr + item (i - 1) of arr) % 1000000007.\n    Set i to i + 1.\nShow item n of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push((((seed / 65536) % 32768) % 1000));\n    }\n    let mut i = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 2..(n + 1) {\n        arr[(i - 1) as usize] = ((arr[(i - 1) as usize] + arr[((i - 1) - 1) as usize]) % 1000000007);\n    }\n    show(&arr[(n - 1) as usize]);\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 2.1491881600000013000,
            "median_ms": 2.0780924600000013000,
            "stddev_ms": 0.25768840317546757000,
            "min_ms": 1.768592460000001000,
            "max_ms": 2.784967460000002000,
            "cv": 0.11990034561490763755,
            "runs": 10,
            "user_ms": 0.99016000,
            "system_ms": 0.6099400000000002000
          },
          "cpp": {
            "mean_ms": 2.2830049600000013000,
            "median_ms": 2.2451549600000014000,
            "stddev_ms": 0.33815038958929036000,
            "min_ms": 1.7298844600000017000,
            "max_ms": 2.888009460000001000,
            "cv": 0.14811636221293630805,
            "runs": 10,
            "user_ms": 1.0453599999999997000,
            "system_ms": 0.7299400000000003000
          },
          "rust": {
            "mean_ms": 2.7718880600000016000,
            "median_ms": 2.5914674600000013000,
            "stddev_ms": 0.9271268933669577000,
            "min_ms": 1.9894674600000016000,
            "max_ms": 5.272467460000001000,
            "cv": 0.33447486813986173916,
            "runs": 10,
            "user_ms": 1.4393599999999996000,
            "system_ms": 0.6449400000000003000
          },
          "zig": {
            "mean_ms": 1.7275967600000012000,
            "median_ms": 1.764988460000001000,
            "stddev_ms": 0.28755328659110205000,
            "min_ms": 0.987301460000001000,
            "max_ms": 1.9947174600000016000,
            "cv": 0.16644699344718720719,
            "runs": 10,
            "user_ms": 1.0521599999999997000,
            "system_ms": 0.4294400000000003000
          },
          "go": {
            "mean_ms": 3.273238260000001000,
            "median_ms": 3.0599879600000015000,
            "stddev_ms": 0.5751875113709155000,
            "min_ms": 2.674425460000001000,
            "max_ms": 4.684801460000002000,
            "cv": 0.17572430287152861407,
            "runs": 10,
            "user_ms": 1.8451599999999996000,
            "system_ms": 0.9621400000000002000
          },
          "java": {
            "mean_ms": 71.89929675999998000,
            "median_ms": 66.68565446000,
            "stddev_ms": 17.46063881251364000,
            "min_ms": 63.88780046000,
            "max_ms": 121.33963446000,
            "cv": 0.24284853398215135556,
            "runs": 10,
            "user_ms": 23.253459999999997000,
            "system_ms": 28.235839999999995000
          },
          "js": {
            "mean_ms": 52.74882996000001000,
            "median_ms": 48.91342546000001000,
            "stddev_ms": 8.31140605558745000,
            "min_ms": 47.85088446000001000,
            "max_ms": 71.90167546000,
            "cv": 0.15756569504745557818,
            "runs": 10,
            "user_ms": 38.91476000,
            "system_ms": 5.74814000
          },
          "python": {
            "mean_ms": 199.21991736000,
            "median_ms": 194.07615546000,
            "stddev_ms": 19.890058231688237000,
            "min_ms": 181.31259246000,
            "max_ms": 246.29088346000,
            "cv": 0.09983970727056342656,
            "runs": 10,
            "user_ms": 57.75265999999999000,
            "system_ms": 12.29854000
          },
          "ruby": {
            "mean_ms": 82.01270916000,
            "median_ms": 75.66544696000,
            "stddev_ms": 19.775935740402727000,
            "min_ms": 73.07492546000,
            "max_ms": 138.03930146000,
            "cv": 0.24113257497470928565,
            "runs": 10,
            "user_ms": 53.718159999999994000,
            "system_ms": 14.864539999999999000
          },
          "nim": {
            "mean_ms": 2.9777255600000013000,
            "median_ms": 2.4760509600000014000,
            "stddev_ms": 1.8448803603314074000,
            "min_ms": 1.8530924600000014000,
            "max_ms": 8.170133460000001000,
            "cv": 0.61956023923554815258,
            "runs": 10,
            "user_ms": 1.4083599999999996000,
            "system_ms": 0.5919400000000002000
          },
          "logos_release": {
            "mean_ms": 4.150633860000002000,
            "median_ms": 3.6807169600000015000,
            "stddev_ms": 1.2332477814397415000,
            "min_ms": 2.9991754600000014000,
            "max_ms": 6.868675460000001000,
            "cv": 0.29712275836340353705,
            "runs": 10,
            "user_ms": 2.2541599999999994000,
            "system_ms": 0.9350400000000002000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "array_reverse",
      "name": "Array Reverse",
      "description": "Two-pointer in-place reversal. Measures strided cache access.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push (seed / 65536) % 32768 to arr.\n    Set i to i + 1.\nLet mutable lo be 1.\nLet mutable hi be n.\nWhile lo is less than hi:\n    Let tmp be item lo of arr.\n    Set item lo of arr to item hi of arr.\n    Set item hi of arr to tmp.\n    Set lo to lo + 1.\n    Set hi to hi - 1.\nShow \"\" + item 1 of arr + \" \" + item n of arr + \" \" + item (n / 2 + 1) of arr.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push(((seed / 65536) % 32768));\n    }\n    let mut lo = 1;\n    let mut hi = n;\n    unsafe { std::hint::assert_unchecked((hi as usize) <= arr.len()); }\n    while (lo < hi) {\n        let __swap_tmp = arr[(lo - 1) as usize];\n        arr[(lo - 1) as usize] = arr[(hi - 1) as usize];\n        arr[(hi - 1) as usize] = __swap_tmp;\n        lo = (lo + 1);\n        hi = (hi - 1);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", arr[0], \" \", arr[(n - 1) as usize], \" \", arr[((n / 2)) as usize]));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 1.832605819999999000,
            "median_ms": 1.6294638199999992000,
            "stddev_ms": 0.6773133121545993000,
            "min_ms": 0.9398603199999994000,
            "max_ms": 3.3919853199999997000,
            "cv": 0.36959028764549032676,
            "runs": 10,
            "user_ms": 0.64794000,
            "system_ms": 0.61416000
          },
          "cpp": {
            "mean_ms": 2.2887599199999994000,
            "median_ms": 2.2450478199999993000,
            "stddev_ms": 0.5267263369978338000,
            "min_ms": 1.7016103199999997000,
            "max_ms": 3.4576513199999995000,
            "cv": 0.23013612410594551921,
            "runs": 10,
            "user_ms": 0.75464000,
            "system_ms": 0.77326000
          },
          "rust": {
            "mean_ms": 2.64739772000,
            "median_ms": 2.4511518199999997000,
            "stddev_ms": 0.8217386036742395000,
            "min_ms": 1.767402319999999000,
            "max_ms": 4.4624023199999995000,
            "cv": 0.31039484451706768864,
            "runs": 10,
            "user_ms": 0.9776399999999999000,
            "system_ms": 0.77096000
          },
          "zig": {
            "mean_ms": 2.420351419999999000,
            "median_ms": 2.5382973199999993000,
            "stddev_ms": 0.34467199763332156000,
            "min_ms": 1.8706513199999997000,
            "max_ms": 2.9409843199999994000,
            "cv": 0.14240576586738867135,
            "runs": 10,
            "user_ms": 0.81004000,
            "system_ms": 0.8842600000000001000
          },
          "go": {
            "mean_ms": 3.1075722199999994000,
            "median_ms": 3.0918808199999997000,
            "stddev_ms": 0.3448462843417662000,
            "min_ms": 2.5701513199999993000,
            "max_ms": 3.7305263199999992000,
            "cv": 0.11096967662484969265,
            "runs": 10,
            "user_ms": 1.4039399999999998000,
            "system_ms": 1.14126000
          },
          "java": {
            "mean_ms": 69.05332252000002000,
            "median_ms": 66.94763082000,
            "stddev_ms": 5.521809124394605000,
            "min_ms": 63.35027632000001000,
            "max_ms": 79.12223532000001000,
            "cv": 0.07996442347571784009,
            "runs": 10,
            "user_ms": 39.135439999999994000,
            "system_ms": 29.79076000
          },
          "js": {
            "mean_ms": 54.38534732000,
            "median_ms": 48.05900532000,
            "stddev_ms": 14.24370640034604000,
            "min_ms": 46.96944332000,
            "max_ms": 88.84035932000,
            "cv": 0.26190338211020254637,
            "runs": 10,
            "user_ms": 38.67774000,
            "system_ms": 5.863959999999999000
          },
          "python": {
            "mean_ms": 198.61234332000002000,
            "median_ms": 190.12483882000003000,
            "stddev_ms": 20.080846716152925000,
            "min_ms": 182.97586032000002000,
            "max_ms": 240.15294332000,
            "cv": 0.10110573381534040992,
            "runs": 10,
            "user_ms": 53.12093999999999000,
            "system_ms": 12.705159999999998000
          },
          "ruby": {
            "mean_ms": 76.79891432000001000,
            "median_ms": 71.92027682000,
            "stddev_ms": 15.190693553532562000,
            "min_ms": 68.37419332000001000,
            "max_ms": 119.58461032000,
            "cv": 0.19779828514550490616,
            "runs": 10,
            "user_ms": 49.92764000,
            "system_ms": 15.301559999999997000
          },
          "nim": {
            "mean_ms": 2.8991433199999994000,
            "median_ms": 2.9403178199999998000,
            "stddev_ms": 0.7289648654891097000,
            "min_ms": 1.6951523199999997000,
            "max_ms": 4.0895273199999995000,
            "cv": 0.25144147254131260087,
            "runs": 10,
            "user_ms": 1.01294000,
            "system_ms": 0.8825599999999999000
          },
          "logos_release": {
            "mean_ms": 4.35367652000,
            "median_ms": 4.3811098199999995000,
            "stddev_ms": 1.1565206255832667000,
            "min_ms": 2.98931832000,
            "max_ms": 5.87915132000,
            "cv": 0.26564229571729107241,
            "runs": 10,
            "user_ms": 1.9292399999999998000,
            "system_ms": 1.2668599999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "array_fill",
      "name": "Array Fill & Sum",
      "description": "Array push and sum. Measures raw memory bandwidth and allocation.",
      "reference_size": "1000000",
      "sizes": [
        "100000",
        "1000000",
        "5000000",
        "10000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable arr be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push (i * 7 + 3) % 1000000 to arr.\n    Set i to i + 1.\nLet mutable sum be 0.\nSet i to 1.\nWhile i is at most n:\n    Set sum to (sum + item i of arr) % 1000000007.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        arr.push((((i * 7) + 3) % 1000000));\n    }\n    let mut i = (0_i64).max(n);\n    let mut sum = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        sum = ((sum + arr[i as usize]) % 1000000007);\n    }\n    show(&sum);\n}",
      "scaling": {
        "1000000": {
          "c": {
            "mean_ms": 7.438285000000003000,
            "median_ms": 7.501105400000002000,
            "stddev_ms": 0.2157427070684222000,
            "min_ms": 7.080001900000002000,
            "max_ms": 7.749001900000002000,
            "cv": 0.02900436149843977650,
            "runs": 10,
            "user_ms": 4.996639999999999000,
            "system_ms": 1.5365799999999994000
          },
          "cpp": {
            "mean_ms": 7.254039100000001000,
            "median_ms": 7.173792900000002000,
            "stddev_ms": 0.2472888884918028000,
            "min_ms": 6.881251900000001000,
            "max_ms": 7.670084900000002000,
            "cv": 0.03408982017918855247,
            "runs": 10,
            "user_ms": 4.96744000,
            "system_ms": 1.3960799999999996000
          },
          "rust": {
            "mean_ms": 8.009380600000003000,
            "median_ms": 7.843542900000002000,
            "stddev_ms": 0.822262580061875000,
            "min_ms": 7.253751900000003000,
            "max_ms": 10.084834900000002000,
            "cv": 0.10266244309352394765,
            "runs": 10,
            "user_ms": 5.68664000,
            "system_ms": 1.3109799999999996000
          },
          "zig": {
            "mean_ms": 7.784480700000001000,
            "median_ms": 7.8863139000,
            "stddev_ms": 0.5216276301298125000,
            "min_ms": 6.761084900000002000,
            "max_ms": 8.605875900000002000,
            "cv": 0.06700866123668498953,
            "runs": 10,
            "user_ms": 5.548539999999999000,
            "system_ms": 1.3031799999999997000
          },
          "go": {
            "mean_ms": 8.824034900000001000,
            "median_ms": 8.551189400000003000,
            "stddev_ms": 0.8984055187551876000,
            "min_ms": 8.132792900000001000,
            "max_ms": 11.172292900000002000,
            "cv": 0.10181345936825198846,
            "runs": 10,
            "user_ms": 6.053839999999999000,
            "system_ms": 2.1962799999999992000
          },
          "java": {
            "mean_ms": 60.96213500000001000,
            "median_ms": 59.01066840000001000,
            "stddev_ms": 5.584761139312413000,
            "min_ms": 57.670459900000005000,
            "max_ms": 76.1979599000,
            "cv": 0.09161032728450885264,
            "runs": 10,
            "user_ms": 30.338039999999993000,
            "system_ms": 28.751779999999998000
          },
          "js": {
            "mean_ms": 60.234163800000004000,
            "median_ms": 58.6709599000,
            "stddev_ms": 5.733159436750296000,
            "min_ms": 57.412459900000004000,
            "max_ms": 76.3471679000,
            "cv": 0.09518119079043802745,
            "runs": 10,
            "user_ms": 47.27204000,
            "system_ms": 6.421079999999998000
          },
          "python": {
            "mean_ms": 305.51503480000003000,
            "median_ms": 290.41293890000003000,
            "stddev_ms": 33.69185132937665000,
            "min_ms": 274.7248349000,
            "max_ms": 384.2905849000,
            "cv": 0.11027886516757651460,
            "runs": 10,
            "user_ms": 144.00814000,
            "system_ms": 19.387479999999995000
          },
          "ruby": {
            "mean_ms": 150.11460570000001000,
            "median_ms": 150.5110849000,
            "stddev_ms": 2.43103793761804000,
            "min_ms": 146.2909179000,
            "max_ms": 155.2123769000,
            "cv": 0.01619454633532731477,
            "runs": 10,
            "user_ms": 125.88184000,
            "system_ms": 17.69908000
          },
          "nim": {
            "mean_ms": 8.462243000000001000,
            "median_ms": 8.334293400000001000,
            "stddev_ms": 0.7599424740546631000,
            "min_ms": 7.573375900000002000,
            "max_ms": 10.160667900000002000,
            "cv": 0.08980390589760457247,
            "runs": 10,
            "user_ms": 6.308040000000001000,
            "system_ms": 1.1724799999999996000
          },
          "logos_release": {
            "mean_ms": 9.115785000000003000,
            "median_ms": 8.772814400000002000,
            "stddev_ms": 0.9698737536777605000,
            "min_ms": 8.106376900000002000,
            "max_ms": 11.483959900000002000,
            "cv": 0.10639497900375669027,
            "runs": 10,
            "user_ms": 6.410740000000001000,
            "system_ms": 1.5166799999999996000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "collect",
      "name": "Collection Operations",
      "description": "Hash map insert and lookup. Measures hash computation and cache behavior.",
      "reference_size": "10000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "500000",
        "5000000",
        "30000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable m be a new Map of Int to Int with capacity n.\nLet mutable i be 1.\nWhile i is less than n + 1:\n    Set item i of m to i * 2.\n    Set i to i + 1.\nLet mutable found be 0.\nSet i to 1.\nWhile i is less than n + 1:\n    If item i of m equals i * 2:\n        Set found to found + 1.\n    Set i to i + 1.\nShow found.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut m = { let __m: FxHashMap<i64, i64> = FxHashMap::with_capacity_and_hasher((n) as usize, Default::default()); __m };\n    for i in 1..(n + 1) {\n        m.insert(i, (i * 2));\n    }\n    let mut i = (1_i64).max((n + 1));\n    let mut found = 0;\n    for i in 1..(n + 1) {\n        if (m.get(&(i)).copied() == Some((i * 2))) {\n            found = (found + 1);\n        }\n    }\n    show(&found);\n}",
      "scaling": {
        "10000": {
          "c": {
            "mean_ms": 1.7091267999999992000,
            "median_ms": 1.693159899999999000,
            "stddev_ms": 0.6226286820727103000,
            "min_ms": 1.053785399999999000,
            "max_ms": 3.2033263999999995000,
            "cv": 0.36429636588268968191,
            "runs": 10,
            "user_ms": 0.58442000,
            "system_ms": 0.5042200000000001000
          },
          "cpp": {
            "mean_ms": 2.895797499999999000,
            "median_ms": 2.6437638999999994000,
            "stddev_ms": 0.8645696009527837000,
            "min_ms": 1.9602853999999992000,
            "max_ms": 4.6117013999999994000,
            "cv": 0.29856010337490242275,
            "runs": 10,
            "user_ms": 1.21762000,
            "system_ms": 0.8058200000000002000
          },
          "rust": {
            "mean_ms": 6.100026599999999000,
            "median_ms": 2.711826899999999000,
            "stddev_ms": 6.319662851950882000,
            "min_ms": 2.1995763999999992000,
            "max_ms": 22.3416184000,
            "cv": 1.03600578593393068745,
            "runs": 10,
            "user_ms": 1.1759199999999998000,
            "system_ms": 1.0854200000000001000
          },
          "zig": {
            "mean_ms": 2.258218199999999000,
            "median_ms": 2.325722399999999000,
            "stddev_ms": 0.5542564787634771000,
            "min_ms": 1.4059933999999996000,
            "max_ms": 3.4169933999999994000,
            "cv": 0.24543973596682435091,
            "runs": 10,
            "user_ms": 0.8589199999999998000,
            "system_ms": 0.64322000
          },
          "go": {
            "mean_ms": 8.0488642000,
            "median_ms": 3.1987013999999992000,
            "stddev_ms": 13.200279176022013000,
            "min_ms": 3.0412853999999996000,
            "max_ms": 45.3271594000,
            "cv": 1.64001762832848055754,
            "runs": 10,
            "user_ms": 1.47002000,
            "system_ms": 1.2499200000000003000
          },
          "java": {
            "mean_ms": 65.47343100000001000,
            "median_ms": 67.26753540000001000,
            "stddev_ms": 7.317356295320469000,
            "min_ms": 53.3779104000,
            "max_ms": 75.98195240000001000,
            "cv": 0.11176069717990596647,
            "runs": 10,
            "user_ms": 26.954020000000002000,
            "system_ms": 28.89642000
          },
          "js": {
            "mean_ms": 51.388039100000005000,
            "median_ms": 47.663701399999994000,
            "stddev_ms": 8.22907846570186000,
            "min_ms": 46.1282014000,
            "max_ms": 72.42199340000001000,
            "cv": 0.16013606687128599151,
            "runs": 10,
            "user_ms": 36.699720000000005000,
            "system_ms": 6.026619999999999000
          },
          "python": {
            "mean_ms": 161.9976184000,
            "median_ms": 157.28899340000002000,
            "stddev_ms": 14.907920081427375000,
            "min_ms": 151.9071594000,
            "max_ms": 202.4373274000,
            "cv": 0.09202555092271266995,
            "runs": 10,
            "user_ms": 23.82012000,
            "system_ms": 11.563019999999999000
          },
          "ruby": {
            "mean_ms": 59.652630799999995000,
            "median_ms": 59.2909309000,
            "stddev_ms": 1.9592231244777284000,
            "min_ms": 56.9809094000,
            "max_ms": 63.25716040000001000,
            "cv": 0.03284386787644793302,
            "runs": 10,
            "user_ms": 38.99811999999999000,
            "system_ms": 14.614419999999998000
          },
          "nim": {
            "mean_ms": 2.3768141999999997000,
            "median_ms": 2.5631803999999992000,
            "stddev_ms": 0.5156029057518327000,
            "min_ms": 1.5194933999999995000,
            "max_ms": 3.0695353999999992000,
            "cv": 0.21693025300498152740,
            "runs": 10,
            "user_ms": 1.0180199999999997000,
            "system_ms": 0.65562000
          },
          "logos_release": {
            "mean_ms": 9.864381000,
            "median_ms": 4.909326899999999000,
            "stddev_ms": 12.519145520800638000,
            "min_ms": 2.868035399999999000,
            "max_ms": 43.8400354000,
            "cv": 1.26912631626866784646,
            "runs": 10,
            "user_ms": 1.84042000,
            "system_ms": 1.39982000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "two_sum",
      "name": "Two Sum",
      "description": "Interleaved hash insert+lookup. Measures hash table under mixed workload.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "1000000",
        "10000000",
        "60000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet target be n.\nLet mutable arr be a new Seq of Int.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Push ((seed / 65536) % 32768) % n to arr.\n    Set i to i + 1.\nLet mutable seen be a new Map of Int to Int.\nLet mutable count be 0.\nSet i to 1.\nWhile i is at most n:\n    Let x be item i of arr.\n    Let complement be target - x.\n    If complement is at least 0:\n        If seen contains complement:\n            Set count to count + 1.\n    Set seen at x to 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let target = n;\n    let mut arr: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        arr.push((((seed / 65536) % 32768) % n));\n    }\n    let mut i = (0_i64).max(n);\n    let mut seen: FxHashMap<i64, i64> = FxHashMap::with_capacity_and_hasher(n as usize, Default::default());\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= arr.len()); }\n    for i in 0..n {\n        let x = arr[i as usize];\n        let complement = (target - x);\n        if (complement >= 0) {\n            if seen.logos_contains(&complement) {\n                count = (count + 1);\n            }\n        }\n        seen.insert(x, 1);\n    }\n    show(&count);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.7777116399999987000,
            "median_ms": 1.852070139999999000,
            "stddev_ms": 0.2892266011764056000,
            "min_ms": 1.220549139999999000,
            "max_ms": 2.109216139999999000,
            "cv": 0.16269601586025831023,
            "runs": 10,
            "user_ms": 0.5862999999999999000,
            "system_ms": 0.7040400000000001000
          },
          "cpp": {
            "mean_ms": 2.0480366399999992000,
            "median_ms": 2.016528139999999000,
            "stddev_ms": 0.43408433259736534000,
            "min_ms": 1.577341139999999000,
            "max_ms": 3.0475491399999995000,
            "cv": 0.21195144858217258728,
            "runs": 10,
            "user_ms": 0.9056000,
            "system_ms": 0.57754000
          },
          "rust": {
            "mean_ms": 2.451253139999999000,
            "median_ms": 2.036319639999999000,
            "stddev_ms": 1.1818433439248857000,
            "min_ms": 1.900424139999999000,
            "max_ms": 5.750924139999999000,
            "cv": 0.48213843141671046758,
            "runs": 10,
            "user_ms": 0.9844000,
            "system_ms": 0.58744000
          },
          "zig": {
            "mean_ms": 2.068340939999999000,
            "median_ms": 1.7669451399999988000,
            "stddev_ms": 1.1668213611820033000,
            "min_ms": 1.3182581399999987000,
            "max_ms": 5.33559114000,
            "cv": 0.56413395809977240219,
            "runs": 10,
            "user_ms": 0.7293999999999998000,
            "system_ms": 0.6198400000000001000
          },
          "go": {
            "mean_ms": 3.3849115399999996000,
            "median_ms": 3.167236639999999000,
            "stddev_ms": 1.1829424773427584000,
            "min_ms": 2.665966139999999000,
            "max_ms": 6.672840139999999000,
            "cv": 0.34947515270746441420,
            "runs": 10,
            "user_ms": 1.3139999999999998000,
            "system_ms": 1.1108399999999999000
          },
          "java": {
            "mean_ms": 54.94989504000001000,
            "median_ms": 53.578215639999996000,
            "stddev_ms": 5.0262623777298995000,
            "min_ms": 52.25829914000,
            "max_ms": 69.02163314000001000,
            "cv": 0.09146991771451250046,
            "runs": 10,
            "user_ms": 24.000399999999998000,
            "system_ms": 27.809140000000003000
          },
          "js": {
            "mean_ms": 53.423053240000004000,
            "median_ms": 47.12050764000,
            "stddev_ms": 13.235772450125052000,
            "min_ms": 46.12421514000,
            "max_ms": 88.43713214000001000,
            "cv": 0.24775394979137757363,
            "runs": 10,
            "user_ms": 37.43289999999999000,
            "system_ms": 5.8768399999999995000
          },
          "python": {
            "mean_ms": 170.46710323999997000,
            "median_ms": 158.10852813999998000,
            "stddev_ms": 25.87277355866104000,
            "min_ms": 149.90813214000,
            "max_ms": 222.86534114000,
            "cv": 0.15177575653546985534,
            "runs": 10,
            "user_ms": 24.414799999999997000,
            "system_ms": 12.148139999999998000
          },
          "ruby": {
            "mean_ms": 66.31840323999999000,
            "median_ms": 62.29904914000,
            "stddev_ms": 10.58169297794724000,
            "min_ms": 59.03575714000,
            "max_ms": 87.95688214000001000,
            "cv": 0.15955892272697067420,
            "runs": 10,
            "user_ms": 39.76119999999999000,
            "system_ms": 15.20704000
          },
          "nim": {
            "mean_ms": 2.1827991399999995000,
            "median_ms": 1.9422576399999994000,
            "stddev_ms": 0.6696765812021999000,
            "min_ms": 1.5827571399999992000,
            "max_ms": 3.766258139999999000,
            "cv": 0.30679716192402387211,
            "runs": 10,
            "user_ms": 0.7788999999999999000,
            "system_ms": 0.6040399999999999000
          },
          "logos_release": {
            "mean_ms": 3.3886866399999984000,
            "median_ms": 3.374945139999999000,
            "stddev_ms": 0.21621986777365198000,
            "min_ms": 3.068549139999999000,
            "max_ms": 3.687715139999999000,
            "cv": 0.06380639189867732417,
            "runs": 10,
            "user_ms": 1.6833999999999998000,
            "system_ms": 0.9498399999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "histogram",
      "name": "Histogram",
      "description": "Array-indexed frequency counting. Measures random array access.",
      "reference_size": "100000",
      "sizes": [
        "10000",
        "100000",
        "500000",
        "1000000",
        "5000000",
        "10000000",
        "100000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable counts be a new Seq of Int.\nLet mutable idx be 0.\nWhile idx is less than 1000:\n    Push 0 to counts.\n    Set idx to idx + 1.\nLet mutable seed be 42.\nLet mutable i be 0.\nWhile i is less than n:\n    Set seed to (seed * 1103515245 + 12345) % 2147483648.\n    Let v be ((seed / 65536) % 32768) % 1000.\n    Set item (v + 1) of counts to (item (v + 1) of counts) + 1.\n    Set i to i + 1.\nLet mutable maxFreq be 0.\nLet mutable maxIndex be 0.\nLet mutable distinct be 0.\nSet i to 0.\nWhile i is less than 1000:\n    If item (i + 1) of counts is greater than 0:\n        Set distinct to distinct + 1.\n    If item (i + 1) of counts is greater than maxFreq:\n        Set maxFreq to item (i + 1) of counts.\n        Set maxIndex to i.\n    Set i to i + 1.\nShow \"\" + maxFreq + \" \" + maxIndex + \" \" + distinct.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(LogosIndex::logos_get(&arguments, 2));\n    let mut counts: Vec<i64> = vec![0; 1000 as usize];\n    let mut idx = 0;\n    let mut seed = 42;\n    for i in 0..n {\n        seed = (((seed * 1103515245) + 12345) % 2147483648);\n        let v = (((seed / 65536) % 32768) % 1000);\n        let __set_tmp = (LogosIndex::logos_get(&counts, (v + 1)) + 1);\n        LogosIndexMut::logos_set(&mut counts, (v + 1), __set_tmp);\n    }\n    let mut i = (0_i64).max(n);\n    let mut maxFreq = 0;\n    let mut maxIndex = 0;\n    let mut distinct = 0;\n    i = 0;\n    while (i < 1000) {\n        if (LogosIndex::logos_get(&counts, (i + 1)) > 0) {\n            distinct = (distinct + 1);\n        }\n        if (LogosIndex::logos_get(&counts, (i + 1)) > maxFreq) {\n            maxFreq = LogosIndex::logos_get(&counts, (i + 1));\n            maxIndex = i;\n        }\n        i = (i + 1);\n    }\n    show(&format!(\"{}{}{}{}{}{}\", \"\", maxFreq, \" \", maxIndex, \" \", distinct));\n}",
      "scaling": {
        "100000": {
          "c": {
            "mean_ms": 1.8530150000000002000,
            "median_ms": 1.5441147000000003000,
            "stddev_ms": 0.9072626548189461000,
            "min_ms": 0.8476567000000003000,
            "max_ms": 3.8313657000000004000,
            "cv": 0.48961430685609452814,
            "runs": 10,
            "user_ms": 0.63214000,
            "system_ms": 0.5209600000000002000
          },
          "cpp": {
            "mean_ms": 1.9083357000000002000,
            "median_ms": 1.9183857000000001000,
            "stddev_ms": 0.3057719778589559000,
            "min_ms": 1.4291147000000002000,
            "max_ms": 2.3919897000000004000,
            "cv": 0.16022965868057484223,
            "runs": 10,
            "user_ms": 0.69584000,
            "system_ms": 0.6890600000000001000
          },
          "rust": {
            "mean_ms": 2.5318151000000002000,
            "median_ms": 2.2590732000000004000,
            "stddev_ms": 1.0534802502505894000,
            "min_ms": 1.6872817000000003000,
            "max_ms": 5.380406700000001000,
            "cv": 0.41609683513246655207,
            "runs": 10,
            "user_ms": 0.9216399999999999000,
            "system_ms": 0.7713600000000001000
          },
          "zig": {
            "mean_ms": 2.1546483000,
            "median_ms": 2.0708647000,
            "stddev_ms": 0.5410467643113877000,
            "min_ms": 1.4647816999999999000,
            "max_ms": 3.3973657000,
            "cv": 0.25110676499333450382,
            "runs": 10,
            "user_ms": 0.7413399999999998000,
            "system_ms": 0.7280600000000002000
          },
          "go": {
            "mean_ms": 3.0376358999999998000,
            "median_ms": 3.0341982000,
            "stddev_ms": 0.22358250658155015000,
            "min_ms": 2.7683237000000003000,
            "max_ms": 3.3786567000000005000,
            "cv": 0.07360411647148039194,
            "runs": 10,
            "user_ms": 1.41034000,
            "system_ms": 1.1469600000000003000
          },
          "java": {
            "mean_ms": 73.03644830000001000,
            "median_ms": 72.96798970000001000,
            "stddev_ms": 6.574234224030258000,
            "min_ms": 64.14444870000001000,
            "max_ms": 81.60144870000001000,
            "cv": 0.09001306028773933548,
            "runs": 10,
            "user_ms": 39.46634000,
            "system_ms": 30.28466000
          },
          "js": {
            "mean_ms": 47.5513482000,
            "median_ms": 47.492864700000005000,
            "stddev_ms": 0.3458979507283262000,
            "min_ms": 46.9572397000,
            "max_ms": 48.0396987000,
            "cv": 0.00727419860470593765,
            "runs": 10,
            "user_ms": 37.186439999999994000,
            "system_ms": 5.352859999999999000
          },
          "python": {
            "mean_ms": 191.8704274000,
            "median_ms": 182.15394820000003000,
            "stddev_ms": 30.57590594082449000,
            "min_ms": 175.1769897000,
            "max_ms": 277.63648970000004000,
            "cv": 0.15935705337791148319,
            "runs": 10,
            "user_ms": 45.240539999999996000,
            "system_ms": 12.15026000
          },
          "ruby": {
            "mean_ms": 70.29422730000001000,
            "median_ms": 68.60655270000002000,
            "stddev_ms": 6.838238219503818000,
            "min_ms": 65.83673970000001000,
            "max_ms": 89.20232270000002000,
            "cv": 0.09728022459539600099,
            "runs": 10,
            "user_ms": 47.33094000,
            "system_ms": 14.86236000
          },
          "nim": {
            "mean_ms": 2.3743484000000002000,
            "median_ms": 2.1308022000,
            "stddev_ms": 1.1388265771117264000,
            "min_ms": 1.1136147000000004000,
            "max_ms": 5.2253646999999995000,
            "cv": 0.47963751954503656837,
            "runs": 10,
            "user_ms": 0.8022399999999999000,
            "system_ms": 0.5737600000000002000
          },
          "logos_release": {
            "mean_ms": 3.3845651000000004000,
            "median_ms": 3.1684067000,
            "stddev_ms": 0.46603018446739165000,
            "min_ms": 2.9453647000000005000,
            "max_ms": 4.3444067000,
            "cv": 0.13769278199653822434,
            "runs": 10,
            "user_ms": 1.7270399999999998000,
            "system_ms": 0.9175600000000002000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "knapsack",
      "name": "0/1 Knapsack",
      "description": "0/1 knapsack DP. Measures 2D table fills and conditional max.",
      "reference_size": "500",
      "sizes": [
        "100",
        "500",
        "1000",
        "2000",
        "5000",
        "9000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet capacity be n * 5.\nLet mutable weights be a new Seq of Int.\nLet mutable vals be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push (i * 17 + 3) % 50 + 1 to weights.\n    Push (i * 31 + 7) % 100 + 1 to vals.\n    Set i to i + 1.\nLet cols be capacity + 1.\nLet mutable prev be a new Seq of Int.\nLet mutable curr be a new Seq of Int.\nSet i to 0.\nWhile i is less than cols:\n    Push 0 to prev.\n    Push 0 to curr.\n    Set i to i + 1.\nSet i to 0.\nWhile i is less than n:\n    Let wi be item (i + 1) of weights.\n    Let vi be item (i + 1) of vals.\n    Let mutable w be 0.\n    While w is at most capacity:\n        Set item (w + 1) of curr to item (w + 1) of prev.\n        If w is at least wi:\n            Let take be item (w - wi + 1) of prev + vi.\n            If take is greater than item (w + 1) of curr:\n                Set item (w + 1) of curr to take.\n        Set w to w + 1.\n    Set prev to curr.\n    Set i to i + 1.\nShow item (capacity + 1) of prev.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let capacity = (n * 5);\n    let mut weights: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut vals: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        weights.push(((((i * 17) + 3) % 50) + 1));\n        vals.push(((((i * 31) + 7) % 100) + 1));\n    }\n    let mut i = (0_i64).max(n);\n    let cols = (capacity + 1);\n    let mut prev: Vec<i64> = Vec::with_capacity(cols as usize);\n    let mut curr: Vec<i64> = Vec::with_capacity(cols as usize);\n    for i in 0..cols {\n        prev.push(0);\n        curr.push(0);\n    }\n    unsafe { std::hint::assert_unchecked((n as usize) <= weights.len()); }\n    unsafe { std::hint::assert_unchecked((n as usize) <= vals.len()); }\n    for i in 0..n {\n        let wi = weights[i as usize];\n        let vi = vals[i as usize];\n        unsafe { std::hint::assert_unchecked((capacity as usize) <= prev.len()); }\n        unsafe { std::hint::assert_unchecked((capacity as usize) <= curr.len()); }\n        for w in 0..(capacity + 1) {\n            curr[(w) as usize] = prev[w as usize];\n            if (w >= wi) {\n                let take = (prev[((w - wi)) as usize] + vi);\n                if (take > curr[w as usize]) {\n                    curr[(w) as usize] = take;\n                }\n            }\n        }\n        std::mem::swap(&mut prev, &mut curr);\n    }\n    show(&prev[capacity as usize]);\n}",
      "scaling": {
        "500": {
          "c": {
            "mean_ms": 3.262647580000001000,
            "median_ms": 2.503276880000001000,
            "stddev_ms": 1.706016179057175000,
            "min_ms": 2.092776380000001000,
            "max_ms": 7.24923538000,
            "cv": 0.52289318328925199978,
            "runs": 10,
            "user_ms": 1.4355400000000001000,
            "system_ms": 0.63094000
          },
          "cpp": {
            "mean_ms": 2.5093185800000007000,
            "median_ms": 2.519297380000001000,
            "stddev_ms": 0.5016722239973028000,
            "min_ms": 2.0534853800000005000,
            "max_ms": 3.7565273800000006000,
            "cv": 0.19992368764802381531,
            "runs": 10,
            "user_ms": 1.2667400000000001000,
            "system_ms": 0.58034000
          },
          "rust": {
            "mean_ms": 3.3087138800000004000,
            "median_ms": 3.306567880000001000,
            "stddev_ms": 0.3756484646510916000,
            "min_ms": 2.5808603800000006000,
            "max_ms": 3.8769433800000014000,
            "cv": 0.11353307607579884017,
            "runs": 10,
            "user_ms": 2.1540400000000003000,
            "system_ms": 0.6541399999999999000
          },
          "zig": {
            "mean_ms": 2.587905880000001000,
            "median_ms": 2.635714380000001000,
            "stddev_ms": 0.45615482952374116000,
            "min_ms": 1.6516933800000007000,
            "max_ms": 3.193943380000001000,
            "cv": 0.17626407244908805714,
            "runs": 10,
            "user_ms": 1.3601400000000001000,
            "system_ms": 0.6653400000000002000
          },
          "go": {
            "mean_ms": 4.9381100800000004000,
            "median_ms": 5.089297380000001000,
            "stddev_ms": 0.8083762132079689000,
            "min_ms": 3.4861513800000014000,
            "max_ms": 5.847027380000001000,
            "cv": 0.16370153765546855418,
            "runs": 10,
            "user_ms": 2.43494000,
            "system_ms": 1.84444000
          },
          "java": {
            "mean_ms": 56.43512658000001000,
            "median_ms": 56.23294338000001000,
            "stddev_ms": 1.6623248231255202000,
            "min_ms": 53.810109380000005000,
            "max_ms": 59.94165238000001000,
            "cv": 0.02945549915209421871,
            "runs": 10,
            "user_ms": 26.448339999999997000,
            "system_ms": 27.961740000000002000
          },
          "js": {
            "mean_ms": 54.55186018000,
            "median_ms": 50.99373538000,
            "stddev_ms": 11.325151290079454000,
            "min_ms": 49.88923538000001000,
            "max_ms": 86.68519338000,
            "cv": 0.20760339340786626132,
            "runs": 10,
            "user_ms": 42.17364000,
            "system_ms": 5.32064000
          },
          "python": {
            "mean_ms": 428.65114328000004000,
            "median_ms": 424.59921388000,
            "stddev_ms": 32.60919136699165000,
            "min_ms": 399.17106838000,
            "max_ms": 513.18931838000,
            "cv": 0.07607396335740305541,
            "runs": 10,
            "user_ms": 285.14824000,
            "system_ms": 13.316539999999998000
          },
          "ruby": {
            "mean_ms": 188.34983068000,
            "median_ms": 184.68738088000003000,
            "stddev_ms": 7.715662933390609000,
            "min_ms": 183.50702638000002000,
            "max_ms": 207.32677638000002000,
            "cv": 0.04096453341919515549,
            "runs": 10,
            "user_ms": 162.98554000,
            "system_ms": 15.69214000
          },
          "nim": {
            "mean_ms": 4.581080780000001000,
            "median_ms": 4.297505880000001000,
            "stddev_ms": 1.0112582518749381000,
            "min_ms": 3.558068380000001000,
            "max_ms": 7.136110380000001000,
            "cv": 0.22074665356041547017,
            "runs": 10,
            "user_ms": 3.1262399999999997000,
            "system_ms": 0.60284000
          },
          "logos_release": {
            "mean_ms": 4.727255580000001000,
            "median_ms": 4.521672380000001000,
            "stddev_ms": 0.7611616210688618000,
            "min_ms": 3.639609380000001000,
            "max_ms": 6.009068380000001000,
            "cv": 0.16101554235594379244,
            "runs": 10,
            "user_ms": 2.9378399999999997000,
            "system_ms": 0.9365399999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "coins",
      "name": "Coin Change",
      "description": "Coin change DP. Measures 1D DP with inner-loop additions.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "10000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable coinList be a new Seq of Int.\nPush 1 to coinList.\nPush 5 to coinList.\nPush 10 to coinList.\nPush 25 to coinList.\nPush 50 to coinList.\nPush 100 to coinList.\nLet mutable dp be a new Seq of Int.\nPush 1 to dp.\nLet mutable i be 1.\nWhile i is at most n:\n    Push 0 to dp.\n    Set i to i + 1.\nLet mutable c be 1.\nWhile c is at most 6:\n    Let coin be item c of coinList.\n    Let mutable j be coin.\n    While j is at most n:\n        Set item (j + 1) of dp to (item (j + 1) of dp + item (j - coin + 1) of dp) % 1000000007.\n        Set j to j + 1.\n    Set c to c + 1.\nShow item (n + 1) of dp.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut coinList = Seq::<i64>::default();\n    coinList.push(1);\n    coinList.push(5);\n    coinList.push(10);\n    coinList.push(25);\n    coinList.push(50);\n    coinList.push(100);\n    let mut dp: Vec<i64> = vec![0; (1 + n) as usize];\n    dp[0] = 1;\n    let mut i = 1;\n    unsafe { std::hint::assert_unchecked((6 as usize) <= coinList.len()); }\n    for c in 0..6 {\n        let coin = coinList[c as usize];\n        unsafe { std::hint::assert_unchecked((n as usize) <= dp.len()); }\n        for j in coin..(n + 1) {\n            dp[(j) as usize] = ((dp[j as usize] + dp[((j - coin)) as usize]) % 1000000007);\n        }\n    }\n    show(&dp[n as usize]);\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 2.79325542000,
            "median_ms": 0.5704298000000002000,
            "stddev_ms": 7.048032485932764000,
            "min_ms": 0,
            "max_ms": 22.8293258000,
            "cv": 2.52323236731883402198,
            "runs": 10,
            "user_ms": 0.5271599999999999000,
            "system_ms": 0.4743800000000004000
          },
          "cpp": {
            "mean_ms": 0.7263600200000003000,
            "median_ms": 0.5156798000000001000,
            "stddev_ms": 0.716645711162896000,
            "min_ms": 0,
            "max_ms": 2.4209098000,
            "cv": 0.98662604139872084921,
            "runs": 10,
            "user_ms": 0.56336000,
            "system_ms": 0.44038000000000036000
          },
          "rust": {
            "mean_ms": 0.6761382000,
            "median_ms": 0.7348883000,
            "stddev_ms": 0.3602471029166261000,
            "min_ms": 0.1221588000000001000,
            "max_ms": 1.3392007999999999000,
            "cv": 0.53280099085752897854,
            "runs": 10,
            "user_ms": 0.7803599999999999000,
            "system_ms": 0.4768800000000004000
          },
          "zig": {
            "mean_ms": 0.44702734000000023000,
            "median_ms": 0.5188468000000002000,
            "stddev_ms": 0.33254447880222047000,
            "min_ms": 0,
            "max_ms": 0.8979508000000001000,
            "cv": 0.74390188036870473940,
            "runs": 10,
            "user_ms": 0.55466000,
            "system_ms": 0.3684800000000004000
          },
          "go": {
            "mean_ms": 2.7476924000000005000,
            "median_ms": 1.3034923000,
            "stddev_ms": 4.276125841559603000,
            "min_ms": 0.8249088000000003000,
            "max_ms": 14.786158800000001000,
            "cv": 1.55626075231696321679,
            "runs": 10,
            "user_ms": 1.0217599999999998000,
            "system_ms": 0.9642800000000007000
          },
          "java": {
            "mean_ms": 56.552175999999996000,
            "median_ms": 51.4394928000,
            "stddev_ms": 13.300500994441671000,
            "min_ms": 49.251242800000004000,
            "max_ms": 92.5199508000,
            "cv": 0.23518990665260470155,
            "runs": 10,
            "user_ms": 20.608759999999997000,
            "system_ms": 28.137280000000004000
          },
          "js": {
            "mean_ms": 45.028679800000006000,
            "median_ms": 45.1929923000,
            "stddev_ms": 0.7248853497486498000,
            "min_ms": 43.826741800000006000,
            "max_ms": 45.799866800000005000,
            "cv": 0.01609830341391998135,
            "runs": 10,
            "user_ms": 36.826059999999994000,
            "system_ms": 5.160980000000001000
          },
          "python": {
            "mean_ms": 168.71057550000002000,
            "median_ms": 161.3039923000,
            "stddev_ms": 17.928428497071578000,
            "min_ms": 153.5382418000,
            "max_ms": 201.94728480000002000,
            "cv": 0.10626736613243060079,
            "runs": 10,
            "user_ms": 25.930759999999997000,
            "system_ms": 11.97568000
          },
          "ruby": {
            "mean_ms": 61.54554670000001000,
            "median_ms": 60.2007218000,
            "stddev_ms": 4.328667947456649000,
            "min_ms": 58.6212428000,
            "max_ms": 73.47278380000001000,
            "cv": 0.07033275646337947464,
            "runs": 10,
            "user_ms": 40.51286000,
            "system_ms": 15.82828000
          },
          "nim": {
            "mean_ms": 1.3163092000000004000,
            "median_ms": 1.0861593000000003000,
            "stddev_ms": 0.7142953159826203000,
            "min_ms": 0.6341178000000003000,
            "max_ms": 2.9428258000000007000,
            "cv": 0.54265009769940078132,
            "runs": 10,
            "user_ms": 0.64446000,
            "system_ms": 0.6503800000000004000
          },
          "logos_release": {
            "mean_ms": 2.3688924000,
            "median_ms": 2.3827213000,
            "stddev_ms": 0.3312848435400837000,
            "min_ms": 1.8324508000000005000,
            "max_ms": 2.8644508000000004000,
            "cv": 0.13984799121314404149,
            "runs": 10,
            "user_ms": 1.64416000,
            "system_ms": 0.9680800000000003000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "fannkuch",
      "name": "Fannkuch Redux",
      "description": "Fannkuch permutation benchmark. Measures tight array reversal loops.",
      "reference_size": "8",
      "sizes": [
        "7",
        "8",
        "9",
        "10",
        "11"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable perm1 be a new Seq of Int.\nLet mutable count be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push i to perm1.\n    Push 0 to count.\n    Set i to i + 1.\nLet mutable maxFlips be 0.\nLet mutable checksum be 0.\nLet mutable permCount be 0.\nLet mutable r be n.\nLet mutable done be 0.\nWhile done equals 0:\n    While r is greater than 1:\n        Set item r of count to r.\n        Set r to r - 1.\n    Let mutable perm be a new Seq of Int.\n    Set i to 1.\n    While i is at most n:\n        Push item i of perm1 to perm.\n        Set i to i + 1.\n    Let mutable flips be 0.\n    While item 1 of perm is not 0:\n        Let k be item 1 of perm + 1.\n        Let mutable lo be 1.\n        Let mutable hi be k.\n        While lo is less than hi:\n            Let tmp be item lo of perm.\n            Set item lo of perm to item hi of perm.\n            Set item hi of perm to tmp.\n            Set lo to lo + 1.\n            Set hi to hi - 1.\n        Set flips to flips + 1.\n    If flips is greater than maxFlips:\n        Set maxFlips to flips.\n    If permCount % 2 equals 0:\n        Set checksum to checksum + flips.\n    Otherwise:\n        Set checksum to checksum - flips.\n    Set permCount to permCount + 1.\n    Set done to 1.\n    While done equals 1:\n        If r equals n:\n            Set done to 2.\n        Otherwise:\n            Let perm0 be item 1 of perm1.\n            Set i to 1.\n            While i is at most r:\n                Set item i of perm1 to item (i + 1) of perm1.\n                Set i to i + 1.\n            Set item (r + 1) of perm1 to perm0.\n            Set item (r + 1) of count to (item (r + 1) of count) - 1.\n            If item (r + 1) of count is greater than 0:\n                Set done to 0.\n            Otherwise:\n                Set r to r + 1.\nShow checksum.\nShow maxFlips.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut perm1: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut count: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        perm1.push(i);\n        count.push(0);\n    }\n    let mut i = (0_i64).max(n);\n    let mut maxFlips = 0;\n    let mut checksum = 0;\n    let mut permCount = 0;\n    let mut r = n;\n    let mut done = 0;\n    while (done == 0) {\n        while (r > 1) {\n            count[(r - 1) as usize] = r;\n            r = (r - 1);\n        }\n        let mut perm: Vec<i64> = perm1[..n as usize].to_vec();\n        i = n + 1;\n        let mut flips = 0;\n        while (perm[0] != 0) {\n            let k = (perm[0] + 1);\n            let mut lo = 1;\n            let mut hi = k;\n            unsafe { std::hint::assert_unchecked((hi as usize) <= perm.len()); }\n            while (lo < hi) {\n                let __swap_tmp = perm[(lo - 1) as usize];\n                perm[(lo - 1) as usize] = perm[(hi - 1) as usize];\n                perm[(hi - 1) as usize] = __swap_tmp;\n                lo = (lo + 1);\n                hi = (hi - 1);\n            }\n            flips = (flips + 1);\n        }\n        if (flips > maxFlips) {\n            maxFlips = flips;\n        }\n        if ((permCount % 2) == 0) {\n            checksum = (checksum + flips);\n        } else {\n            checksum = (checksum - flips);\n        }\n        permCount = (permCount + 1);\n        done = 1;\n        while (done == 1) {\n            if (r == n) {\n                done = 2;\n            } else {\n                perm1[0..=(r as usize)].rotate_left(1);\n                count[(r) as usize] = (count[r as usize] - 1);\n                if (count[r as usize] > 0) {\n                    done = 0;\n                } else {\n                    r = (r + 1);\n                }\n            }\n        }\n    }\n    show(&checksum);\n    show(&maxFlips);\n}",
      "scaling": {
        "8": {
          "c": {
            "mean_ms": 3.3873114600000004000,
            "median_ms": 3.2293863600000006000,
            "stddev_ms": 0.3710510967168359000,
            "min_ms": 3.0444283600000004000,
            "max_ms": 4.2123863600000006000,
            "cv": 0.10954147591637051769,
            "runs": 10,
            "user_ms": 2.2442000,
            "system_ms": 0.5687199999999997000
          },
          "cpp": {
            "mean_ms": 3.607603460000001000,
            "median_ms": 3.620928360000001000,
            "stddev_ms": 0.2903232157549965000,
            "min_ms": 3.143928360000001000,
            "max_ms": 4.059344360000001000,
            "cv": 0.08047536792056309301,
            "runs": 10,
            "user_ms": 2.2916000,
            "system_ms": 0.6918199999999996000
          },
          "rust": {
            "mean_ms": 4.801740860000001000,
            "median_ms": 4.786740860000001000,
            "stddev_ms": 0.2477686536577798000,
            "min_ms": 4.51192836000,
            "max_ms": 5.33217836000,
            "cv": 0.05159975535576481493,
            "runs": 10,
            "user_ms": 3.4544999999999992000,
            "system_ms": 0.6789199999999995000
          },
          "zig": {
            "mean_ms": 3.7628866600000004000,
            "median_ms": 3.827511860000001000,
            "stddev_ms": 0.4003796697444536000,
            "min_ms": 3.068678360000001000,
            "max_ms": 4.254303360000001000,
            "cv": 0.10640226664293246542,
            "runs": 10,
            "user_ms": 2.3764999999999993000,
            "system_ms": 0.6267199999999997000
          },
          "go": {
            "mean_ms": 4.561732360000001000,
            "median_ms": 4.556740360000001000,
            "stddev_ms": 0.4281466273579651000,
            "min_ms": 3.951969360000001000,
            "max_ms": 5.2294283600000015000,
            "cv": 0.09385614796523595394,
            "runs": 10,
            "user_ms": 2.6410999999999995000,
            "system_ms": 1.3146199999999999000
          },
          "java": {
            "mean_ms": 65.06109516000,
            "median_ms": 64.88924086000,
            "stddev_ms": 2.0136436645910674000,
            "min_ms": 61.93605336000001000,
            "max_ms": 69.32951236000001000,
            "cv": 0.03095004256597680364,
            "runs": 10,
            "user_ms": 44.1675000,
            "system_ms": 28.84352000
          },
          "js": {
            "mean_ms": 59.982324360000006000,
            "median_ms": 50.773782860000005000,
            "stddev_ms": 20.23696688526101000,
            "min_ms": 49.737595360000005000,
            "max_ms": 105.89447036000,
            "cv": 0.33738217218464936418,
            "runs": 10,
            "user_ms": 41.3541000,
            "system_ms": 5.99562000
          },
          "python": {
            "mean_ms": 237.36952836000,
            "median_ms": 236.68667836000,
            "stddev_ms": 8.452462253238757000,
            "min_ms": 225.74513636000,
            "max_ms": 252.71597036000,
            "cv": 0.03560887663904172826,
            "runs": 10,
            "user_ms": 101.2241000,
            "system_ms": 12.24922000
          },
          "ruby": {
            "mean_ms": 144.97611156000,
            "median_ms": 141.08869886000003000,
            "stddev_ms": 11.262738385451623000,
            "min_ms": 138.52717836000,
            "max_ms": 176.23542836000,
            "cv": 0.07768685657423231140,
            "runs": 10,
            "user_ms": 120.72819999999998000,
            "system_ms": 15.032119999999996000
          },
          "nim": {
            "mean_ms": 4.678378560000001000,
            "median_ms": 4.557511860000001000,
            "stddev_ms": 0.8039095347867609000,
            "min_ms": 3.8825533600000007000,
            "max_ms": 6.72122036000,
            "cv": 0.17183507586584885686,
            "runs": 10,
            "user_ms": 3.242099999999999000,
            "system_ms": 0.6043199999999997000
          },
          "logos_release": {
            "mean_ms": 6.110003260000001000,
            "median_ms": 5.888198860000001000,
            "stddev_ms": 0.7942348072695785000,
            "min_ms": 5.21430336000,
            "max_ms": 8.09942836000,
            "cv": 0.12998926080271491868,
            "runs": 10,
            "user_ms": 4.242699999999999000,
            "system_ms": 1.0143199999999995000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "strings",
      "name": "String Assembly",
      "description": "String concatenation and assembly. Measures allocator throughput and GC pressure.",
      "reference_size": "10000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "500000",
        "5000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable result be \"\" with capacity n * 6.\nLet mutable i be 0.\nWhile i is less than n:\n    Set result to result + i + \" \".\n    Set i to i + 1.\nLet mutable count be 0.\nSet i to 1.\nWhile i is at most length of result:\n    If item i of result equals \" \":\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut result = String::with_capacity(((n * 6)) as usize);\n    for i in 0..n {\n        write!(result, \"{}{}\", i, \" \").unwrap();\n    }\n    let mut i = (0_i64).max(n);\n    let mut count = 0;\n    unsafe { std::hint::assert_unchecked(((result.len() as i64) as usize) <= result.len()); }\n    for i in 1..((result.len() as i64) + 1) {\n        if (result.logos_get_char(i) == ' ') {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "10000": {
          "c": {
            "mean_ms": 1.1660699600000014000,
            "median_ms": 1.0251786600000016000,
            "stddev_ms": 0.6942989664291761000,
            "min_ms": 0.3592411600000017000,
            "max_ms": 2.984115160000002000,
            "cv": 0.59541793395413021909,
            "runs": 10,
            "user_ms": 0.9249399999999997000,
            "system_ms": 0.4769400000000001000
          },
          "cpp": {
            "mean_ms": 0.5436207440000011000,
            "median_ms": 0.5300741600000013000,
            "stddev_ms": 0.34951178757757000,
            "min_ms": 0,
            "max_ms": 1.004741160000001000,
            "cv": 0.64293313203215308644,
            "runs": 10,
            "user_ms": 0.5961399999999999000,
            "system_ms": 0.3796400000000001000
          },
          "rust": {
            "mean_ms": 1.3136575600000014000,
            "median_ms": 1.1500536600000015000,
            "stddev_ms": 0.7659094144635005000,
            "min_ms": 0.5450331600000014000,
            "max_ms": 3.3026161600000015000,
            "cv": 0.58303582134715510163,
            "runs": 10,
            "user_ms": 1.0816399999999996000,
            "system_ms": 0.48084000000000007000
          },
          "zig": {
            "mean_ms": 0.8725366600000013000,
            "median_ms": 0.8949906600000013000,
            "stddev_ms": 0.41602611856101604000,
            "min_ms": 0.0836571600000011000,
            "max_ms": 1.4159491600000016000,
            "cv": 0.47680073243113409144,
            "runs": 10,
            "user_ms": 0.6785399999999998000,
            "system_ms": 0.4442400000000001000
          },
          "go": {
            "mean_ms": 2.0753494600000014000,
            "median_ms": 1.9401576600000013000,
            "stddev_ms": 0.8207599575788891000,
            "min_ms": 1.1692411600000016000,
            "max_ms": 4.184658160000001000,
            "cv": 0.39548036289699786094,
            "runs": 10,
            "user_ms": 1.18784000,
            "system_ms": 1.0003400000000002000
          },
          "java": {
            "mean_ms": 68.58716146000002000,
            "median_ms": 65.58844865999999000,
            "stddev_ms": 9.818165967227191000,
            "min_ms": 63.01719916000001000,
            "max_ms": 96.16728316000,
            "cv": 0.14314874326667007305,
            "runs": 10,
            "user_ms": 28.91874000,
            "system_ms": 27.60534000
          },
          "js": {
            "mean_ms": 49.12859096000001000,
            "median_ms": 47.53619916000,
            "stddev_ms": 3.987305021483831000,
            "min_ms": 45.79311616000001000,
            "max_ms": 58.40969916000001000,
            "cv": 0.08116058172175655225,
            "runs": 10,
            "user_ms": 37.99273999999999000,
            "system_ms": 5.27234000
          },
          "python": {
            "mean_ms": 170.94656176000,
            "median_ms": 156.48594966000,
            "stddev_ms": 36.554487835805935000,
            "min_ms": 147.55553216000,
            "max_ms": 261.66586516000,
            "cv": 0.21383575931247167892,
            "runs": 10,
            "user_ms": 24.08864000,
            "system_ms": 11.592739999999999000
          },
          "ruby": {
            "mean_ms": 63.93032796000,
            "median_ms": 60.31892816000001000,
            "stddev_ms": 9.527665431643982000,
            "min_ms": 57.704990160000004000,
            "max_ms": 90.13561516000,
            "cv": 0.14903201243712158801,
            "runs": 10,
            "user_ms": 39.716440000000006000,
            "system_ms": 14.716139999999999000
          },
          "nim": {
            "mean_ms": 1.3740824600000014000,
            "median_ms": 0.9488861600000014000,
            "stddev_ms": 1.2597226082496674000,
            "min_ms": 0.7274911600000013000,
            "max_ms": 4.906324160000002000,
            "cv": 0.91677366164012174095,
            "runs": 10,
            "user_ms": 0.85524000,
            "system_ms": 0.55524000
          },
          "logos_release": {
            "mean_ms": 2.1943241600000016000,
            "median_ms": 2.0161156600000014000,
            "stddev_ms": 0.4044290087754723000,
            "min_ms": 1.7474071600000014000,
            "max_ms": 2.7803661600000014000,
            "cv": 0.18430686593519163782,
            "runs": 10,
            "user_ms": 1.7182399999999998000,
            "system_ms": 0.8145400000000001000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "binary_trees",
      "name": "Binary Trees",
      "description": "Recursive tree creation and checksum. Measures allocation pressure.",
      "reference_size": "14",
      "sizes": [
        "10",
        "12",
        "14",
        "16",
        "18",
        "20",
        "25",
        "30"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## To makeCheck (depth: Int) -> Int:\n    If depth equals 0:\n        Return 1.\n    Return 1 + makeCheck(depth - 1) + makeCheck(depth - 1).\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet minDepth be 4.\nLet mutable maxDepth be n.\nIf minDepth + 2 is greater than maxDepth:\n    Set maxDepth to minDepth + 2.\n\nLet stretchCheck be makeCheck(maxDepth + 1).\nShow \"stretch tree of depth \" + (maxDepth + 1) + \" check: \" + stretchCheck.\n\nLet longLived be makeCheck(maxDepth).\n\nLet mutable depth be minDepth.\nWhile depth is at most maxDepth:\n    Let mutable iterations be 1.\n    Let mutable p be 0.\n    While p is less than maxDepth - depth + minDepth:\n        Set iterations to iterations * 2.\n        Set p to p + 1.\n    Let mutable totalCheck be 0.\n    Let mutable i be 0.\n    While i is less than iterations:\n        Set totalCheck to totalCheck + makeCheck(depth).\n        Set i to i + 1.\n    Show \"\" + iterations + \" trees of depth \" + depth + \" check: \" + totalCheck.\n    Set depth to depth + 2.\nShow \"long lived tree of depth \" + maxDepth + \" check: \" + longLived.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\n#[inline]\nfn makeCheck(depth: i64) -> i64 {\n    if depth == 0 { return 1; }\n    (2i64 << depth) - 1\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let minDepth = 4;\n    let mut maxDepth = n;\n    if ((minDepth + 2) > maxDepth) {\n        maxDepth = (minDepth + 2);\n    }\n    let stretchCheck = makeCheck((maxDepth + 1));\n    show(&format!(\"{}{}{}{}\", \"stretch tree of depth \", (maxDepth + 1), \" check: \", stretchCheck));\n    let longLived = makeCheck(maxDepth);\n    let mut depth = minDepth;\n    while (depth <= maxDepth) {\n        let mut iterations = 1;\n        for p in 0..((maxDepth - depth) + minDepth) {\n            iterations = (iterations * 2);\n        }\n        let mut totalCheck = 0;\n        for i in 0..iterations {\n            totalCheck = (totalCheck + makeCheck(depth));\n        }\n        show(&format!(\"{}{}{}{}{}{}\", \"\", iterations, \" trees of depth \", depth, \" check: \", totalCheck));\n        depth = (depth + 2);\n    }\n    show(&format!(\"{}{}{}{}\", \"long lived tree of depth \", maxDepth, \" check: \", longLived));\n}",
      "scaling": {
        "14": {
          "c": {
            "mean_ms": 1.9394592800000003000,
            "median_ms": 1.6248383799999998000,
            "stddev_ms": 0.9374732074599316000,
            "min_ms": 1.2956303799999997000,
            "max_ms": 4.447255380000001000,
            "cv": 0.48336833731303265876,
            "runs": 10,
            "user_ms": 0.5008000,
            "system_ms": 0.5890399999999999000
          },
          "cpp": {
            "mean_ms": 1.6588672800000002000,
            "median_ms": 1.5214423800000002000,
            "stddev_ms": 0.651823892286261000,
            "min_ms": 0.9469633800000001000,
            "max_ms": 3.3651293800000003000,
            "cv": 0.39293311776350240714,
            "runs": 10,
            "user_ms": 0.5131000000000001000,
            "system_ms": 0.56824000
          },
          "rust": {
            "mean_ms": 2.40047158000,
            "median_ms": 2.0341508799999997000,
            "stddev_ms": 0.7714594398994388000,
            "min_ms": 1.5002963799999997000,
            "max_ms": 3.89354638000,
            "cv": 0.32137828513655587624,
            "runs": 10,
            "user_ms": 0.815000,
            "system_ms": 0.7779400000000001000
          },
          "zig": {
            "mean_ms": 1.8831716799999998000,
            "median_ms": 1.87062988000,
            "stddev_ms": 0.2839160987342133000,
            "min_ms": 1.5127133799999995000,
            "max_ms": 2.4937133799999996000,
            "cv": 0.15076485152655509887,
            "runs": 10,
            "user_ms": 0.6264000,
            "system_ms": 0.7548399999999999000
          },
          "go": {
            "mean_ms": 13.216258980000001000,
            "median_ms": 6.498608880000001000,
            "stddev_ms": 14.230276271280512000,
            "min_ms": 5.981296380000001000,
            "max_ms": 51.78829638000,
            "cv": 1.07672498645910394556,
            "runs": 10,
            "user_ms": 4.816000,
            "system_ms": 1.23244000
          },
          "java": {
            "mean_ms": 74.51587167999998000,
            "median_ms": 71.29502537999999000,
            "stddev_ms": 10.71266553183313000,
            "min_ms": 65.19467138000,
            "max_ms": 103.31667238000,
            "cv": 0.14376354044192713488,
            "runs": 10,
            "user_ms": 51.786599999999995000,
            "system_ms": 30.008039999999996000
          },
          "js": {
            "mean_ms": 55.65685497999999000,
            "median_ms": 55.51602588000,
            "stddev_ms": 1.0259431185452087000,
            "min_ms": 54.08946338000,
            "max_ms": 57.423672380000006000,
            "cv": 0.01843336492717520928,
            "runs": 10,
            "user_ms": 45.812599999999995000,
            "system_ms": 5.4020399999999994000
          },
          "python": {
            "mean_ms": 383.28264678000,
            "median_ms": 376.92396338000,
            "stddev_ms": 14.748452569465784000,
            "min_ms": 370.61858838000,
            "max_ms": 411.89813038000006000,
            "cv": 0.03847931205174345566,
            "runs": 10,
            "user_ms": 242.64670000000002000,
            "system_ms": 12.29684000
          },
          "ruby": {
            "mean_ms": 177.24258408000002000,
            "median_ms": 171.61685888000003000,
            "stddev_ms": 20.456349750566215000,
            "min_ms": 166.01196338000002000,
            "max_ms": 234.63646338000002000,
            "cv": 0.11541441836197253377,
            "runs": 10,
            "user_ms": 147.7987000,
            "system_ms": 16.20484000
          },
          "nim": {
            "mean_ms": 8.47410508000,
            "median_ms": 7.981421380000001000,
            "stddev_ms": 1.1889726291519315000,
            "min_ms": 7.53471338000,
            "max_ms": 11.103505380000002000,
            "cv": 0.14030657136386742799,
            "runs": 10,
            "user_ms": 6.5160999999999995000,
            "system_ms": 0.7746399999999999000
          },
          "logos_release": {
            "mean_ms": 3.1649550799999994000,
            "median_ms": 2.99725488000,
            "stddev_ms": 0.7679995774261063000,
            "min_ms": 2.4300053799999996000,
            "max_ms": 5.21696338000,
            "cv": 0.24265733889218625042,
            "runs": 10,
            "user_ms": 1.575000,
            "system_ms": 0.8658399999999999000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "loop_sum",
      "name": "Loop Sum",
      "description": "Pure loop accumulation. Measures raw loop overhead with minimal body.",
      "reference_size": "10000000",
      "sizes": [
        "100000",
        "10000000",
        "50000000",
        "100000000",
        "500000000",
        "1000000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable sum be 0.\nLet mutable i be 1.\nWhile i is at most n:\n    Set sum to (sum + i) % 1000000007.\n    Set i to i + 1.\nShow sum.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut sum = 0;\n    for i in 1..(n + 1) {\n        sum = ((sum + i) % 1000000007);\n    }\n    show(&sum);\n}",
      "scaling": {
        "10000000": {
          "c": {
            "mean_ms": 40.10141804000,
            "median_ms": 36.96116354000,
            "stddev_ms": 9.114410706940596000,
            "min_ms": 36.66347604000,
            "max_ms": 65.93131004000001000,
            "cv": 0.22728400022785318940,
            "runs": 10,
            "user_ms": 35.47728000,
            "system_ms": 0.7569999999999999000
          },
          "cpp": {
            "mean_ms": 37.39015994000,
            "median_ms": 36.94691404000,
            "stddev_ms": 1.1182847964728477000,
            "min_ms": 36.25760204000,
            "max_ms": 39.76522604000,
            "cv": 0.02990853203803780519,
            "runs": 10,
            "user_ms": 35.51388000,
            "system_ms": 0.7333999999999997000
          },
          "rust": {
            "mean_ms": 44.00130994000,
            "median_ms": 38.34453904000,
            "stddev_ms": 13.951605236978238000,
            "min_ms": 37.23364304000,
            "max_ms": 81.85839304000,
            "cv": 0.31707249752342800365,
            "runs": 10,
            "user_ms": 35.85608000,
            "system_ms": 1.2411999999999998000
          },
          "zig": {
            "mean_ms": 51.66768074000,
            "median_ms": 47.712955540000004000,
            "stddev_ms": 11.317112300886488000,
            "min_ms": 45.74689304000,
            "max_ms": 83.34968504000001000,
            "cv": 0.21903658416246705328,
            "runs": 10,
            "user_ms": 45.42158000,
            "system_ms": 0.8329999999999999000
          },
          "go": {
            "mean_ms": 38.638243339999996000,
            "median_ms": 37.80691454000,
            "stddev_ms": 2.0115863501660165000,
            "min_ms": 37.28051804000,
            "max_ms": 43.81189304000,
            "cv": 0.05206205500764923512,
            "runs": 10,
            "user_ms": 36.03808000,
            "system_ms": 1.2161000
          },
          "java": {
            "mean_ms": 89.96071004000003000,
            "median_ms": 88.68291404000,
            "stddev_ms": 3.0737324878740563000,
            "min_ms": 86.96806004000002000,
            "max_ms": 95.23343504000001000,
            "cv": 0.03416749919500807971,
            "runs": 10,
            "user_ms": 56.815380000000006000,
            "system_ms": 29.0934000
          },
          "js": {
            "mean_ms": 88.85497244000001000,
            "median_ms": 86.69412254000,
            "stddev_ms": 7.978387221729789000,
            "min_ms": 84.43114304000,
            "max_ms": 111.14997604000001000,
            "cv": 0.08979111694753217237,
            "runs": 10,
            "user_ms": 74.48087999999999000,
            "system_ms": 5.918700000000001000
          },
          "python": {
            "mean_ms": 848.5356974399998000,
            "median_ms": 838.46335204000,
            "stddev_ms": 41.1904251246239000,
            "min_ms": 796.2843510400001000,
            "max_ms": 919.08131004000,
            "cv": 0.04854294904609653932,
            "runs": 10,
            "user_ms": 670.5486800000001000,
            "system_ms": 17.5895000
          },
          "ruby": {
            "mean_ms": 414.85692254000,
            "median_ms": 410.46137254000004000,
            "stddev_ms": 18.120346807421122000,
            "min_ms": 401.17206004000,
            "max_ms": 462.29460204000,
            "cv": 0.04367854511497028278,
            "runs": 10,
            "user_ms": 377.79907999999995000,
            "system_ms": 18.5798000
          },
          "nim": {
            "mean_ms": 43.169064339999993000,
            "median_ms": 39.38147704000,
            "stddev_ms": 12.365026619422525000,
            "min_ms": 38.35789304000,
            "max_ms": 78.30464404000001000,
            "cv": 0.28643258334337405759,
            "runs": 10,
            "user_ms": 37.065980000000005000,
            "system_ms": 1.1137999999999999000
          },
          "logos_release": {
            "mean_ms": 38.376405940000004000,
            "median_ms": 38.40441454000,
            "stddev_ms": 0.2598647216134035000,
            "min_ms": 37.99901804000,
            "max_ms": 38.83939304000,
            "cv": 0.00677147104446653330,
            "runs": 10,
            "user_ms": 36.42018000,
            "system_ms": 1.0684999999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "fib_iterative",
      "name": "Iterative Fibonacci",
      "description": "Iterative fibonacci mod. Measures loop + data dependency chain.",
      "reference_size": "10000000",
      "sizes": [
        "100000",
        "10000000",
        "50000000",
        "100000000",
        "500000000",
        "1000000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable a be 0.\nLet mutable b be 1.\nLet mutable i be 0.\nWhile i is less than n:\n    Let temp be b.\n    Set b to (a + b) % 1000000007.\n    Set a to temp.\n    Set i to i + 1.\nShow a.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut a = 0;\n    let mut b = 1;\n    for i in 0..n {\n        let temp = b;\n        b = ((a + b) % 1000000007);\n        a = temp;\n    }\n    show(&a);\n}",
      "scaling": {
        "10000000": {
          "c": {
            "mean_ms": 40.24553098000001000,
            "median_ms": 36.88085598000,
            "stddev_ms": 10.465020249199304000,
            "min_ms": 36.45835648000,
            "max_ms": 70.00060548000,
            "cv": 0.26002937455092563919,
            "runs": 10,
            "user_ms": 35.3859000,
            "system_ms": 0.7375800000000004000
          },
          "cpp": {
            "mean_ms": 37.349364079999996000,
            "median_ms": 37.14350198000,
            "stddev_ms": 0.7302014022875549000,
            "min_ms": 36.59385548000,
            "max_ms": 38.71277248000,
            "cv": 0.01955057121517542523,
            "runs": 10,
            "user_ms": 35.5775000,
            "system_ms": 0.8282800000000005000
          },
          "rust": {
            "mean_ms": 37.58093908000,
            "median_ms": 37.60027248000,
            "stddev_ms": 0.5440450996761207000,
            "min_ms": 36.67802248000,
            "max_ms": 38.70435548000,
            "cv": 0.01447662333604785216,
            "runs": 10,
            "user_ms": 35.5247000,
            "system_ms": 0.8988800000000003000
          },
          "zig": {
            "mean_ms": 50.180593380000006000,
            "median_ms": 47.72329348000,
            "stddev_ms": 4.572779143752381000,
            "min_ms": 46.49635648000,
            "max_ms": 57.70089748000,
            "cv": 0.09112644621645525175,
            "runs": 10,
            "user_ms": 45.7316000,
            "system_ms": 1.1929800000000004000
          },
          "go": {
            "mean_ms": 38.40670168000,
            "median_ms": 38.30860548000,
            "stddev_ms": 0.9946561049422274000,
            "min_ms": 37.502689480000004000,
            "max_ms": 41.02602248000,
            "cv": 0.02589798294135179691,
            "runs": 10,
            "user_ms": 36.056799999999986000,
            "system_ms": 1.4636800000000004000
          },
          "java": {
            "mean_ms": 91.48988098000001000,
            "median_ms": 90.41366848000001000,
            "stddev_ms": 4.213141299067061000,
            "min_ms": 87.84731448000001000,
            "max_ms": 103.00048148000,
            "cv": 0.04605035282522738876,
            "runs": 10,
            "user_ms": 57.4859000,
            "system_ms": 29.162879999999995000
          },
          "js": {
            "mean_ms": 90.38613518000001000,
            "median_ms": 85.84695998000,
            "stddev_ms": 7.711450573076798000,
            "min_ms": 83.27143948000,
            "max_ms": 107.46643948000001000,
            "cv": 0.08531674197286767037,
            "runs": 10,
            "user_ms": 75.0036000,
            "system_ms": 5.393779999999999000
          },
          "python": {
            "mean_ms": 1152.1018434799999000,
            "median_ms": 1135.0634394799999000,
            "stddev_ms": 74.78300983180758000,
            "min_ms": 1064.7059804799999000,
            "max_ms": 1311.1126894799998000,
            "cv": 0.06491006871920328444,
            "runs": 10,
            "user_ms": 985.4989999999999000,
            "system_ms": 18.23198000
          },
          "ruby": {
            "mean_ms": 687.9521309800001000,
            "median_ms": 679.20514748000,
            "stddev_ms": 20.206975351471475000,
            "min_ms": 673.3908564800001000,
            "max_ms": 739.5720644800001000,
            "cv": 0.02937264737109873856,
            "runs": 10,
            "user_ms": 652.1227999999999000,
            "system_ms": 18.914379999999998000
          },
          "nim": {
            "mean_ms": 41.78418497999999000,
            "median_ms": 38.38418948000,
            "stddev_ms": 7.963748658148072000,
            "min_ms": 37.70827248000,
            "max_ms": 63.40673048000,
            "cv": 0.19059241342053033161,
            "runs": 10,
            "user_ms": 36.8061000,
            "system_ms": 0.6903800000000005000
          },
          "logos_release": {
            "mean_ms": 37.603939180000004000,
            "median_ms": 35.80812698000,
            "stddev_ms": 5.534237412732471000,
            "min_ms": 34.941147480000004000,
            "max_ms": 53.20327248000,
            "cv": 0.14717174672157499248,
            "runs": 10,
            "user_ms": 33.704000,
            "system_ms": 1.0011800000000004000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "graph_bfs",
      "name": "Graph BFS",
      "description": "BFS on generated graph. Measures queue operations and random access.",
      "reference_size": "5000",
      "sizes": [
        "1000",
        "5000",
        "10000",
        "50000",
        "100000",
        "3000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable adj be a new Seq of Int.\nLet mutable adjStarts be a new Seq of Int.\nLet mutable adjCounts be a new Seq of Int.\nLet mutable i be 0.\nWhile i is less than n:\n    Push i * 5 to adjStarts.\n    Push 0 to adjCounts.\n    Push 0 to adj. Push 0 to adj. Push 0 to adj. Push 0 to adj. Push 0 to adj.\n    Set i to i + 1.\nLet mutable primes be a new Seq of Int.\nPush 31 to primes. Push 37 to primes. Push 41 to primes. Push 43 to primes. Push 47 to primes.\nLet mutable offsets be a new Seq of Int.\nPush 7 to offsets. Push 13 to offsets. Push 17 to offsets. Push 23 to offsets. Push 29 to offsets.\nLet mutable p be 1.\nWhile p is at most 5:\n    Set i to 0.\n    While i is less than n:\n        Let neighbor be (i * item p of primes + item p of offsets) % n.\n        If neighbor is not i:\n            Let start be item (i + 1) of adjStarts.\n            Let cnt be item (i + 1) of adjCounts.\n            Set item (start + cnt + 1) of adj to neighbor.\n            Set item (i + 1) of adjCounts to cnt + 1.\n        Set i to i + 1.\n    Set p to p + 1.\nLet mutable queue be a new Seq of Int.\nLet mutable dist be a new Seq of Int.\nSet i to 0.\nWhile i is less than n:\n    Push 0 - 1 to dist.\n    Set i to i + 1.\nPush 0 to queue.\nSet item 1 of dist to 0.\nLet mutable front be 1.\nWhile front is at most length of queue:\n    Let v be item front of queue.\n    Let start be item (v + 1) of adjStarts.\n    Let cnt be item (v + 1) of adjCounts.\n    Let mutable e be 0.\n    While e is less than cnt:\n        Let u be item (start + e + 1) of adj.\n        If item (u + 1) of dist equals 0 - 1:\n            Set item (u + 1) of dist to item (v + 1) of dist + 1.\n            Push u to queue.\n        Set e to e + 1.\n    Set front to front + 1.\nLet mutable reachable be 0.\nLet mutable totalDist be 0.\nSet i to 0.\nWhile i is less than n:\n    If item (i + 1) of dist is at least 0:\n        Set reachable to reachable + 1.\n        Set totalDist to totalDist + item (i + 1) of dist.\n    Set i to i + 1.\nShow \"\" + reachable + \" \" + totalDist.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut adj: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut adjStarts: Vec<i64> = Vec::with_capacity(n as usize);\n    let mut adjCounts: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        adjStarts.push((i * 5));\n        adjCounts.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n        adj.push(0);\n    }\n    let mut i = (0_i64).max(n);\n    let mut primes = Seq::<i64>::default();\n    primes.push(31);\n    primes.push(37);\n    primes.push(41);\n    primes.push(43);\n    primes.push(47);\n    let mut offsets = Seq::<i64>::default();\n    offsets.push(7);\n    offsets.push(13);\n    offsets.push(17);\n    offsets.push(23);\n    offsets.push(29);\n    for p in 0..5 {\n        unsafe { std::hint::assert_unchecked((n as usize) <= adjStarts.len()); }\n        unsafe { std::hint::assert_unchecked((n as usize) <= adjCounts.len()); }\n        for i in 0..n {\n            let neighbor = (((i * primes[p as usize]) + offsets[p as usize]) % n);\n            if (neighbor != i) {\n                let start = adjStarts[i as usize];\n                let cnt = adjCounts[i as usize];\n                adj[((start + cnt)) as usize] = neighbor;\n                adjCounts[(i) as usize] = (cnt + 1);\n            }\n        }\n    }\n    let mut queue = Seq::<i64>::default();\n    let mut dist: Vec<i64> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        dist.push((0 - 1));\n    }\n    i = (0_i64).max(n);\n    queue.push(0);\n    dist[0] = 0;\n    let mut front = 1;\n    unsafe { std::hint::assert_unchecked(((queue.len() as i64) as usize) <= queue.len()); }\n    while (front <= (queue.len() as i64)) {\n        let v = queue[(front - 1) as usize];\n        let start = adjStarts[v as usize];\n        let cnt = adjCounts[v as usize];\n        unsafe { std::hint::assert_unchecked((cnt as usize) <= adj.len()); }\n        for e in 0..cnt {\n            let u = adj[((start + e)) as usize];\n            if (dist[u as usize] == (0 - 1)) {\n                dist[(u) as usize] = (dist[v as usize] + 1);\n                queue.push(u);\n            }\n        }\n        front = (front + 1);\n    }\n    let mut reachable = 0;\n    let mut totalDist = 0;\n    unsafe { std::hint::assert_unchecked((n as usize) <= dist.len()); }\n    for i in 0..n {\n        if (dist[i as usize] >= 0) {\n            reachable = (reachable + 1);\n            totalDist = (totalDist + dist[i as usize]);\n        }\n    }\n    show(&format!(\"{}{}{}{}\", \"\", reachable, \" \", totalDist));\n}",
      "scaling": {
        "5000": {
          "c": {
            "mean_ms": 1.9374815200000005000,
            "median_ms": 2.0062358200000005000,
            "stddev_ms": 0.30635861785026076000,
            "min_ms": 1.371860820000001000,
            "max_ms": 2.4653188200000004000,
            "cv": 0.15812208513362268401,
            "runs": 10,
            "user_ms": 0.62692000,
            "system_ms": 0.6852399999999999000
          },
          "cpp": {
            "mean_ms": 2.134077520000001000,
            "median_ms": 2.116131820000001000,
            "stddev_ms": 0.3814424961671594000,
            "min_ms": 1.5736938200000003000,
            "max_ms": 2.934068820000001000,
            "cv": 0.17873881927548687231,
            "runs": 10,
            "user_ms": 0.6344199999999999000,
            "system_ms": 0.6758399999999999000
          },
          "rust": {
            "mean_ms": 2.340444120000001000,
            "median_ms": 2.2799858200000006000,
            "stddev_ms": 0.5062597293563958000,
            "min_ms": 1.5189858200000007000,
            "max_ms": 3.2340688200000007000,
            "cv": 0.21630925730300947483,
            "runs": 10,
            "user_ms": 0.8369199999999999000,
            "system_ms": 0.5997399999999999000
          },
          "zig": {
            "mean_ms": 2.3650484200000007000,
            "median_ms": 2.036006320000001000,
            "stddev_ms": 1.058295333595726000,
            "min_ms": 1.7971108200000004000,
            "max_ms": 5.344944820000001000,
            "cv": 0.44747300928229016417,
            "runs": 10,
            "user_ms": 0.69822000,
            "system_ms": 0.6444399999999998000
          },
          "go": {
            "mean_ms": 2.972760720000001000,
            "median_ms": 2.8244228200000007000,
            "stddev_ms": 0.4652097375818663000,
            "min_ms": 2.526693820000001000,
            "max_ms": 4.084193820000001000,
            "cv": 0.15649081153826135845,
            "runs": 10,
            "user_ms": 1.0954200000000002000,
            "system_ms": 1.1225399999999998000
          },
          "java": {
            "mean_ms": 65.12228161999999000,
            "median_ms": 62.56713182000,
            "stddev_ms": 8.93119100280912000,
            "min_ms": 59.68365282000,
            "max_ms": 90.21627682000,
            "cv": 0.13714493381734067952,
            "runs": 10,
            "user_ms": 33.648019999999994000,
            "system_ms": 29.237839999999998000
          },
          "js": {
            "mean_ms": 49.72141512000,
            "median_ms": 48.03250732000,
            "stddev_ms": 4.370817506337942000,
            "min_ms": 46.800610820000005000,
            "max_ms": 58.59348582000,
            "cv": 0.08790613653672578738,
            "runs": 10,
            "user_ms": 38.25611999999999000,
            "system_ms": 5.60514000
          },
          "python": {
            "mean_ms": 176.20941492000003000,
            "median_ms": 165.92736082000004000,
            "stddev_ms": 18.481970994757357000,
            "min_ms": 159.50294382000002000,
            "max_ms": 209.61481882000002000,
            "cv": 0.10488639896539163795,
            "runs": 10,
            "user_ms": 34.54692000,
            "system_ms": 12.672639999999999000
          },
          "ruby": {
            "mean_ms": 66.80988171999999000,
            "median_ms": 63.29767282000001000,
            "stddev_ms": 9.372856981113347000,
            "min_ms": 61.96111082000,
            "max_ms": 92.86602782000,
            "cv": 0.14029147694640385606,
            "runs": 10,
            "user_ms": 43.37472000,
            "system_ms": 14.423539999999999000
          },
          "nim": {
            "mean_ms": 2.0562232200000002000,
            "median_ms": 2.069423320000001000,
            "stddev_ms": 0.2205393051414344000,
            "min_ms": 1.7735688200000007000,
            "max_ms": 2.440693820000001000,
            "cv": 0.10725455436761110914,
            "runs": 10,
            "user_ms": 0.79452000,
            "system_ms": 0.6928399999999999000
          },
          "logos_release": {
            "mean_ms": 3.5011444200000004000,
            "median_ms": 3.5548813200000006000,
            "stddev_ms": 0.3175016179780997000,
            "min_ms": 2.8406108200000005000,
            "max_ms": 3.917777820000001000,
            "cv": 0.09068509604013983054,
            "runs": 10,
            "user_ms": 1.8098200000000002000,
            "system_ms": 1.0956399999999997000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    },
    {
      "id": "string_search",
      "name": "Naive String Search",
      "description": "Naive O(nm) string search. Measures character-level access and inner loop.",
      "reference_size": "50000",
      "sizes": [
        "10000",
        "50000",
        "100000",
        "500000",
        "1000000",
        "50000000"
      ],
      "logos_source": "## To native args () -> Seq of Text\n## To native parseInt (s: Text) -> Int\n\n## Main\nLet arguments be args().\nLet n be parseInt(item 2 of arguments).\nLet mutable text be \"\".\nLet mutable pos be 0.\nWhile pos is less than n:\n    If pos is greater than 0:\n        If pos % 1000 equals 0:\n            If pos + 5 is at most n:\n                Set text to text + \"XXXXX\".\n                Set pos to pos + 5.\n    If pos is less than n:\n        Let mutable ch be \"a\".\n        If pos % 5 equals 1:\n            Set ch to \"b\".\n        If pos % 5 equals 2:\n            Set ch to \"c\".\n        If pos % 5 equals 3:\n            Set ch to \"d\".\n        If pos % 5 equals 4:\n            Set ch to \"e\".\n        Set text to text + ch.\n        Set pos to pos + 1.\nLet needle be \"XXXXX\".\nLet needleLen be 5.\nLet textLen be length of text.\nLet mutable count be 0.\nLet mutable i be 1.\nWhile i is at most textLen - needleLen + 1:\n    Let mutable match be 1.\n    Let mutable j be 0.\n    While j is less than needleLen:\n        If item (i + j) of text is not item (j + 1) of needle:\n            Set match to 0.\n            Set j to needleLen.\n        Set j to j + 1.\n    If match equals 1:\n        Set count to count + 1.\n    Set i to i + 1.\nShow count.",
      "generated_rust": "#[allow(unused_imports)]\nuse std::fmt::Write as _;\nuse logicaffeine_data::*;\nuse logicaffeine_system::*;\n\nfn args() -> Vec<String> {\n    logicaffeine_system::env::args()\n}\n\nfn parseInt(s: String) -> i64 {\n    logicaffeine_system::text::parseInt(s)\n}\n\nfn main() {\n    let arguments = args();\n    let n = parseInt(arguments[1].clone());\n    let mut text = String::from(\"\");\n    let mut pos = 0;\n    while (pos < n) {\n        if (pos > 0) {\n            if ((pos % 1000) == 0) {\n                if ((pos + 5) <= n) {\n                    text.push_str(\"XXXXX\");\n                    pos = (pos + 5);\n                }\n            }\n        }\n        if (pos < n) {\n            let mut ch: u8 = b'a';\n            if ((pos % 5) == 1) {\n                ch = b'b';\n            }\n            if ((pos % 5) == 2) {\n                ch = b'c';\n            }\n            if ((pos % 5) == 3) {\n                ch = b'd';\n            }\n            if ((pos % 5) == 4) {\n                ch = b'e';\n            }\n            text.push(ch as char);\n            pos = (pos + 1);\n        }\n    }\n    let needle = String::from(\"XXXXX\");\n    let needleLen = 5;\n    let textLen = (text.len() as i64);\n    let mut count = 0;\n    for i in 1..(((textLen - needleLen) + 1) + 1) {\n        let mut r#match = 1;\n        let mut j = 0;\n        unsafe { std::hint::assert_unchecked((needleLen as usize) <= text.len()); }\n        unsafe { std::hint::assert_unchecked((needleLen as usize) <= needle.len()); }\n        while (j < needleLen) {\n            if (text.as_bytes()[((i + j) - 1) as usize] != needle.as_bytes()[(j) as usize]) {\n                r#match = 0;\n                break;\n            }\n            j = (j + 1);\n        }\n        if (r#match == 1) {\n            count = (count + 1);\n        }\n    }\n    show(&count);\n}",
      "scaling": {
        "50000": {
          "c": {
            "mean_ms": 0.8225273399999997000,
            "median_ms": 0.8189943399999995000,
            "stddev_ms": 0.23809383413279654000,
            "min_ms": 0.4266188399999994000,
            "max_ms": 1.24949384000,
            "cv": 0.28946616428919751997,
            "runs": 10,
            "user_ms": 0.5885600000000002000,
            "system_ms": 0.5505399999999998000
          },
          "cpp": {
            "mean_ms": 0.8669318399999997000,
            "median_ms": 0.8020363399999998000,
            "stddev_ms": 0.43454838666980857000,
            "min_ms": 0.34157783999999927000,
            "max_ms": 1.81891084000,
            "cv": 0.50124861796494718705,
            "runs": 10,
            "user_ms": 0.5841600000000002000,
            "system_ms": 0.5484399999999995000
          },
          "rust": {
            "mean_ms": 3.07557734000,
            "median_ms": 1.2072648399999997000,
            "stddev_ms": 6.010150398809913000,
            "min_ms": 0.83441084000,
            "max_ms": 20.170327840000002000,
            "cv": 1.95415355700660514035,
            "runs": 10,
            "user_ms": 0.9503600000000002000,
            "system_ms": 0.8113399999999996000
          },
          "zig": {
            "mean_ms": 0.7616067399999996000,
            "median_ms": 0.7686403399999996000,
            "stddev_ms": 0.17837799828233046000,
            "min_ms": 0.4937858399999993000,
            "max_ms": 1.06470284000,
            "cv": 0.23421273593551778925,
            "runs": 10,
            "user_ms": 0.6059600000000002000,
            "system_ms": 0.45463999999999975000
          },
          "go": {
            "mean_ms": 4.67448994000,
            "median_ms": 1.8437233399999997000,
            "stddev_ms": 5.454984803504619000,
            "min_ms": 1.3739938399999997000,
            "max_ms": 16.58091084000,
            "cv": 1.16696898988397844321,
            "runs": 10,
            "user_ms": 1.17416000,
            "system_ms": 1.2470399999999994000
          },
          "java": {
            "mean_ms": 58.604456640000004000,
            "median_ms": 54.79995284000,
            "stddev_ms": 10.568891705389221000,
            "min_ms": 52.34603584000,
            "max_ms": 87.86311884000,
            "cv": 0.18034279833550249735,
            "runs": 10,
            "user_ms": 23.42126000,
            "system_ms": 29.028939999999993000
          },
          "js": {
            "mean_ms": 47.34158573999999000,
            "median_ms": 47.389098840000005000,
            "stddev_ms": 0.3508027842891061000,
            "min_ms": 46.71957684000,
            "max_ms": 47.72716084000,
            "cv": 0.00741003451417354601,
            "runs": 10,
            "user_ms": 37.90826000,
            "system_ms": 5.69864000
          },
          "python": {
            "mean_ms": 188.27770253999998000,
            "median_ms": 178.68959834000,
            "stddev_ms": 23.662458508171582000,
            "min_ms": 171.00424384000001000,
            "max_ms": 241.86286884000002000,
            "cv": 0.12567849612008328319,
            "runs": 10,
            "user_ms": 43.41676000,
            "system_ms": 12.602039999999998000
          },
          "ruby": {
            "mean_ms": 82.23069833999999000,
            "median_ms": 78.72634834000,
            "stddev_ms": 8.91797224166318000,
            "min_ms": 75.67549384000,
            "max_ms": 103.74074384000001000,
            "cv": 0.10845064460951020891,
            "runs": 10,
            "user_ms": 57.27466000,
            "system_ms": 16.09114000
          },
          "nim": {
            "mean_ms": 2.43980674000,
            "median_ms": 2.46486934000,
            "stddev_ms": 0.4203972979177489000,
            "min_ms": 1.7889948399999996000,
            "max_ms": 3.0954938399999996000,
            "cv": 0.17230762216754467200,
            "runs": 10,
            "user_ms": 1.7405600000000004000,
            "system_ms": 0.8674399999999997000
          },
          "logos_release": {
            "mean_ms": 2.5512898399999992000,
            "median_ms": 2.6296193399999996000,
            "stddev_ms": 0.41260992670263713000,
            "min_ms": 1.9025358399999996000,
            "max_ms": 3.16249384000,
            "cv": 0.16172601020613058192,
            "runs": 10,
            "user_ms": 1.76506000,
            "system_ms": 0.9587399999999998000
          }
        }
      },
      "compilation": {},
      "timeouts": {}
    }
  ],
  "summary": {
    "geometric_mean_speedup_vs_c": {
      "c": 1.000,
      "cpp": 1.034,
      "go": 0.560,
      "java": 0.042,
      "js": 0.055,
      "logos_release": 0.578,
      "nim": 0.750,
      "python": 0.010,
      "ruby": 0.023,
      "rust": 0.771,
      "zig": 0.995
    }
  }
}

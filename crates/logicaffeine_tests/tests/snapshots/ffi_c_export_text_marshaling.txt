use logicaffeine_data::*;
use logicaffeine_system::*;

use std::ffi::{CStr, CString};

// ═══ LogicAffeine Universal ABI Runtime ═══

#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LogosStatus {
    Ok = 0,
    Error = 1,
    RefinementViolation = 2,
    NullPointer = 3,
    OutOfBounds = 4,
    DeserializationFailed = 5,
    InvalidHandle = 6,
    ContainsNullByte = 7,
    ThreadPanic = 8,
    MemoryExhausted = 9,
}

pub type LogosHandle = *mut std::ffi::c_void;

fn logos_error_store() -> &'static std::sync::Mutex<std::collections::HashMap<std::thread::ThreadId, String>> {
    use std::sync::OnceLock;
    static STORE: OnceLock<std::sync::Mutex<std::collections::HashMap<std::thread::ThreadId, String>>> = OnceLock::new();
    STORE.get_or_init(|| std::sync::Mutex::new(std::collections::HashMap::new()))
}

fn logos_set_last_error(msg: String) {
    let mut store = logos_error_store().lock().unwrap_or_else(|e| e.into_inner());
    store.insert(std::thread::current().id(), msg);
}

thread_local! {
    static LOGOS_ERROR_CACHE: std::cell::RefCell<Option<std::ffi::CString>> = std::cell::RefCell::new(None);
}

#[no_mangle]
pub extern "C" fn logos_last_error() -> *const std::os::raw::c_char {
    let msg = logos_error_store().lock().unwrap_or_else(|e| e.into_inner())
        .get(&std::thread::current().id()).cloned();
    match msg {
        Some(s) => match std::ffi::CString::new(s) {
            Ok(cstr) => {
                let ptr = cstr.as_ptr();
                LOGOS_ERROR_CACHE.with(|cache| { cache.borrow_mut().replace(cstr); });
                LOGOS_ERROR_CACHE.with(|cache| {
                    cache.borrow().as_ref().map_or(std::ptr::null(), |c| c.as_ptr())
                })
            }
            Err(_) => std::ptr::null(),
        }
        None => std::ptr::null(),
    }
}

#[no_mangle]
pub extern "C" fn logos_get_last_error() -> *const std::os::raw::c_char {
    logos_last_error()
}

#[no_mangle]
pub extern "C" fn logos_clear_error() {
    let mut store = logos_error_store().lock().unwrap_or_else(|e| e.into_inner());
    store.remove(&std::thread::current().id());
}

#[no_mangle]
pub extern "C" fn logos_free_string(ptr: *mut std::os::raw::c_char) {
    if !ptr.is_null() {
        unsafe { drop(std::ffi::CString::from_raw(ptr)); }
    }
}

pub const LOGOS_ABI_VERSION: u32 = 1;

#[no_mangle]
pub extern "C" fn logos_version() -> *const std::os::raw::c_char {
    concat!(env!("CARGO_PKG_VERSION"), "\0").as_ptr() as *const std::os::raw::c_char
}

#[no_mangle]
pub extern "C" fn logos_abi_version() -> u32 {
    LOGOS_ABI_VERSION
}

struct HandleEntry {
    data: usize,
    generation: u64,
}

struct HandleRegistry {
    entries: std::collections::HashMap<u64, HandleEntry>,
    counter: u64,
}

impl HandleRegistry {
    fn new() -> Self {
        HandleRegistry { entries: std::collections::HashMap::new(), counter: 0 }
    }
    fn register(&mut self, ptr: usize) -> (u64, u64) {
        self.counter += 1;
        let id = self.counter;
        let generation = id;
        self.entries.insert(id, HandleEntry { data: ptr, generation });
        (id, generation)
    }
    fn validate_handle(&self, id: u64, generation: u64) -> bool {
        self.entries.get(&id).map_or(false, |e| e.generation == generation)
    }
    fn deref(&self, id: u64) -> Option<usize> {
        self.entries.get(&id).map(|e| e.data)
    }
    fn free(&mut self, id: u64) -> Result<usize, ()> {
        if let Some(entry) = self.entries.remove(&id) { Ok(entry.data) } else { Err(()) }
    }
}

fn logos_handle_registry() -> &'static std::sync::Mutex<HandleRegistry> {
    use std::sync::OnceLock;
    static REGISTRY: OnceLock<std::sync::Mutex<HandleRegistry>> = OnceLock::new();
    REGISTRY.get_or_init(|| std::sync::Mutex::new(HandleRegistry::new()))
}

fn greet(name: String) -> String {
    return String::from("hello");
}

#[no_mangle]
pub extern "C" fn logos_greet(name: *const std::os::raw::c_char, out: *mut *mut std::os::raw::c_char) -> LogosStatus {
    if name.is_null() { logos_set_last_error("NullPointer: text parameter 'name' is null".to_string()); return LogosStatus::NullPointer; }
    let name = unsafe { std::ffi::CStr::from_ptr(name).to_string_lossy().into_owned() };
    if out.is_null() { logos_set_last_error("NullPointer: output parameter is null".to_string()); return LogosStatus::NullPointer; }
    match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
    let result = greet(name);
    match std::ffi::CString::new(result) {
        Ok(cstr) => {
            unsafe { *out = cstr.into_raw(); }
            LogosStatus::Ok
        }
        Err(_) => {
            logos_set_last_error("Return value contains null byte".to_string());
            LogosStatus::ContainsNullByte
        }
    }
    })) {
        Ok(__v) => __v,
        Err(__panic) => {
            let __msg = if let Some(s) = __panic.downcast_ref::<String>() { s.clone() } else if let Some(s) = __panic.downcast_ref::<&str>() { s.to_string() } else { "Unknown panic".to_string() };
            logos_set_last_error(__msg);
            LogosStatus::ThreadPanic
        }
    }
}

fn main() {
    show(&42);
}